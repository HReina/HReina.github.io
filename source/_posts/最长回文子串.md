---
title: 最长回文子串
date: 2022-03-14 14:56:15
tags: 
      - c++
      - 算法
categories: 
      - 算法
      - 动态规划
      - 回文子串
comments: true
---

> ​                                              給一个字符串s，找到s中的最长的回文子串

> 最长回文子串和回文子串

<!-- more -->

#### 最长回文子串

```c++
class Solution {
public:
    //定义一个函数来寻找最长回文串
    string palindrome(string s, int l, int r) {
    // 防止索引越界
    while (l >=0 && r < s.size() && s[l] == s[r]) {
        // 双指针，向两边展开
        l--; 
        r++;
    }
    // 返回以 s[l] 和 s[r] 为中心的最长回文串
    return s.substr(l+1, r-l-1);
    }

    string longestPalindrome(string s) {
    string res;
    for (int i = 0; i < s.size(); i++) {
        // 以 s[i] 为中心的最长回文子串
        string s1 = palindrome(s, i, i);
        // 以 s[i] 和 s[i+1] 为中心的最长回文子串
        string s2 = palindrome(s, i, i + 1);
        // res = longest(res, s1, s2)
        res = res.size() > s1.size() ? res : s1;
        res = res.size() > s2.size() ? res : s2;
    }
    return res;
    } 
};
```

时间复杂度：O(N^2^)

空间复杂度：O(1)

#### 回文子串

```c++
class Solution {
public:
    int countSubstrings(string s) {
        int result=0;
        for(int i=0; i<s.size(); i++){
            int a=Substring(s,i,i);
            int b=Substring(s,i,i+1);
            result += a+b;
        }
        return result;
    }

    //定义一个函数来寻找回文串并计数
    int palindrome(string s, int left, int right){
        int result=0;
        while(left>=0 && right<s.size() && s[left]==s[right]){
            left--;
            right++;
            result++;
        }
        return result;
    }
};
```

时间复杂度：O(N^2^)

空间复杂度：O(1)
