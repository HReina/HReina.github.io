---
title: 零钱兑换
date: 2022-05-19 21:42:09
tags:
   - c++
   - 算法
categories: 
      - 算法
      - 动态规划
      - 零钱兑换
comments: true
---

>  零钱兑换 I   II

<!-- more -->

#### 322.零钱兑换 I

> 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
>
> 你可以认为每种硬币的数量是无限的。

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //动态规划，dp[i]=x，表示目标金额为i时对应的最少硬币个数为x
        vector<int> dp(amount+1, amount+1);
        dp[0]=0;
        for(int i=0;i<dp.size();i++){
            for(int coin : coins){
                if(i-coin>=0){
                    dp[i]=min(dp[i], dp[i-coin]+1);
                }
            }
        }
        return dp[amount]==amount+1 ? -1 : dp[amount];
    }
};
```

#### 518.零钱兑换 II

> 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
>
> 假设每一种面额的硬币有无限个。 
>
> 题目数据保证结果符合 32 位带符号整数。

> 思路：
>
> `dp[i][j]` 表示从前`i`种硬币中选，且总金额恰好为`j`的所有选法集合的方案数
>
> 按照第`i`种硬币可以选 `0`个,`1`个，`2`个，`3`个，，，，`k`个划分集合 `dp[i][j]`，其中`k*coins[i] <= j`
>
> 第`i` 种硬币选` 0` 个，`dp[i][j]=dp[i-1][j]`
>
> 第`i` 种硬币选` 1` 个，`dp[i][j]=dp[i-1][j-coins[i]]`
>
> 第`i` 种硬币选` k` 个，`dp[i][j]=dp[i-1][j-k*coins[i]]`
>
> 状态计算：
>
> `dp[i][j] = dp[i-1][j]+dp[i-1][j-coins[i]]+dp[i-1][j-2*coins[i]]...+dp[i-1][j-k*coins[i]]`

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n=coins.size();
        vector<vector<int>> dp(n+1,vector<int>(amount+1));
        //base case
        dp[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=amount;j++){
                for(int k=0;k*coins[i-1]<=j;k++){
                    dp[i][j] += dp[i-1][j-k*coins[i-1]];
                }
            }
        }
        return dp[n][amount];
    }
};
```