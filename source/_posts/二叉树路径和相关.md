---
title: 二叉树路径和相关
date: 2022-05-19 21:43:43
tags:
   - c++
   - 算法
categories: 
      - 数据结构
      - 二叉树
      - 二叉树路径和相关
---

> 二叉树路径和相关

<!-- more -->

##### 112.路径和

> 给你二叉树的根节点` root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true ；否则，返回 false `。
>

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) return false;
        if(root->val==targetSum && root->left==nullptr && root->right==nullptr){
            return true;
        }
        return hasPathSum(root->left, targetSum-root->val) || 
               hasPathSum(root->right, targetSum-root->val);
    }
};
```

##### 113.路径总和 II

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
>

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> temp;
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        dfs(root, targetSum);
        return res;
    }
    void dfs(TreeNode* root, int targetSum){
        //结束条件
        if(root==nullptr) return;
        
        temp.push_back(root->val);
        if(root->val==targetSum && root->left==nullptr && root->right==nullptr){
            res.push_back(temp);
        }
        dfs(root->left, targetSum-root->val);
        dfs(root->right, targetSum-root->val);
        temp.pop_back();
    }
};
```

##### 437.路径总和 III

> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的路径的数目。
>
> 路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>

```c++
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) return 0;
        int res = dfs(root, targetSum);
        res += pathSum(root->left, targetSum);
        res += pathSum(root->right, targetSum);
        return res;
    }

    int dfs(TreeNode* root, long long targetSum){
        if(root==nullptr) return 0;

        int res=0;
        if(root->val==targetSum){
            res++;
        }
        res += dfs(root->left, targetSum-root->val);
        res += dfs(root->right, targetSum-root->val);
        return res;
    }
};
```

##### 129. 求根节点到叶子节点数字之和

> 给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
>
> 每条从根节点到叶节点的路径都代表一个数字：
>
> * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
>
> 计算从根节点到叶节点生成的 所有数字之和 。
>
> ![num1tree](/images/num1tree.jpg)

```c++
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
    int dfs(TreeNode* root, int prevSum){
        if(root==nullptr) return 0;
        int sum = prevSum*10 + root->val;
        if(root->left==nullptr && root->right==nullptr){
            return sum;
        }else{
            return dfs(root->left, sum)+dfs(root->right, sum);
        }
    }
};
```

##### 124.二叉树中的最大路径和

> 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
>
> 路径和 是路径中各节点值的总和。
>
> 给你一个二叉树的根节点 root ，返回其 最大路径和 。
>
> 示例；
>
> ![exx2](/images/exx2.jpg)
>
> ```c++
> 输入：root = [-10,9,20,null,null,15,7]
> 输出：42
> 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
> ```

```c++
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return res;
    }
    int res=INT_MIN;
    int dfs(TreeNode* root){
        if(root==nullptr) return 0;

        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftVal = max(dfs(root->left), 0);
        int rightVal = max(dfs(root->right), 0);

        //节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int curVal = root->val+leftVal+rightVal;

        //更新答案
        res = max(curVal, res);
        
        // 返回节点的最大贡献值
        return root->val + max(leftVal, rightVal);
    }
};
```

##### 687.最长同值路径

> 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。
>
> 两个节点之间的路径长度 由它们之间的边数表示。
>
> 示例1：
>
> ![ex2222](/images/ex2222.jpg)
>
> ```c++
> 输入：root = [1,4,5,4,4,5]
> 输出：2
> ```

```c++
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        dfs(root);
        return res;
    }
    int res=0;
    int dfs(TreeNode* root){
        if(root==nullptr) return 0;

        int leftVal = dfs(root->left);
        int rightVal = dfs(root->right);

        int temp_left=0, temp_right=0;
        if(root->left!=nullptr && root->left->val==root->val){
            temp_left += leftVal+1;
        }
        if(root->right!=nullptr && root->right->val==root->val){
            temp_right += rightVal+1;
        }
        res = max(res, temp_left+temp_right);

        return max(temp_left, temp_right);
    }
};
```

##### 257.二叉树的所有路径

> 给你一个二叉树的根节点 `root` ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

```c++
class Solution {
public:
    vector<string> res;
    vector<string> binaryTreePaths(TreeNode* root) {
        dfs(root, "");
        return res;
    }
    void dfs(TreeNode* root, string s){
        if(root==nullptr) return ;

        s +=to_string(root->val);

        if(root->left==nullptr && root->right==nullptr){
            res.push_back(s);
        }
        
        s +="->";
        dfs(root->left, s);
        dfs(root->right, s);
    }
};
```

##### 1080.根到叶路径上的不足节点

> 给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）
>
> 假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。
>
> 请你删除所有不足节点，并返回生成的二叉树的根。
>

```c++
class Solution {
public:
    TreeNode* sufficientSubset(TreeNode* root, int limit) {
        return dfs(root, limit);
    }
    TreeNode* dfs(TreeNode* root, int limit){
        TreeNode* left=root->left;
        TreeNode* right=root->right;
        if(left==nullptr && right==nullptr){
            return root->val >= limit ? root : nullptr;
        }
        limit -= root->val;
        if(left!=nullptr){
            root->left=dfs(left, limit);
        }
        if(right!=nullptr){
            root->right=dfs(right, limit);
        }
        if(root->left==nullptr&&root->right==nullptr){
            return nullptr;
        }
        return root;
    }
};
```