---
title: 二叉树层序遍历
date: 2022-05-02 21:43:56
tags:
   - c++
   - 算法
categories: 
      - 算法
      - 二叉树
      - 二叉树层序遍历
comments: true
---

> 二叉树的层序遍历

<!-- more -->

##### 102.二叉树的层序遍历

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。（即逐层地，从左到右访问所有节点）
>
> 示例1：
>
> ```c++
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]
> ```

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root==nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            vector<int> temp;
            int n=q.size();
            for(int i=0;i<n;i++){
                TreeNode* cur=q.front();
                q.pop();
                temp.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res.push_back(temp);
        }
        return res;
    }
};
```

##### 107.二叉树的层序遍历 II

> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
>
> 示例1：
>
> ```c++
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[15,7],[9,20],[3]]
> ```

```c++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> res;
        if(root==nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            vector<int> temp;
            int n=q.size();
            for(int i=0;i<n;i++){
                TreeNode* cur=q.front();
                q.pop();
                temp.push_back(cur->val);
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res.push_back(temp);
        }
        //转置一下
        reverse(res.begin(), res.end()); 
        
        return res;
    }
};
```

##### 103.二叉树的锯齿形层序遍历

> 按照之字形顺序
>
> 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
>
> 示例1：
>
> ```c++
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[20,9],[15,7]]
> ```

```c++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root==nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        int step=1;
        while(!q.empty()){
            deque<int> temp;
            int n=q.size();
            for(int i=0;i<n;i++){
                TreeNode* cur=q.front();
                q.pop();
                if(step%2!=0){
                    temp.push_back(cur->val);
                }
                if(step%2==0){
                    temp.push_front(cur->val);
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res.push_back(vector<int>{temp.begin(), temp.end()});
            step++;
        }
        return res;
    }
};
```

##### offer II 二叉树每层的最大值

>  给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。
>
> 示例1：
>
> ```c++
> 输入: root = [1,3,2,5,3,null,9]
> 输出: [1,3,9]
> 解释:
>           1
>          / \
>         3   2
>        / \   \  
>       5   3   9
> ```

```c++
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> res;
        if(root==nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int maxVal =INT_MIN;
            int n=q.size();
            for(int i=0;i<n;i++){
                TreeNode* cur=q.front();
                q.pop();
                if(cur->val>maxVal){
                    maxVal=cur->val;
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
            res.push_back(maxVal);
        }
        return res;
    }
};
```

##### 429.N叉树的层序遍历

> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）
>
> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）
>
> ![narytreeexample](/images/narytreeexample.png)
>
> ```c++
> 输入：root = [1,null,3,2,4,null,5,6]
> 输出：[[1],[3,2,4],[5,6]]
> ```

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        if(root==NULL) return res;
        queue<Node*> q;
        q.push(root);
        while(!q.empty()){
            vector<int> temp;
            int n=q.size();
            for(int i=0;i<n;i++){
                Node* cur=q.front();
                q.pop();
                temp.push_back(cur->val);
                for(Node* child : cur->children){
                    q.push(child);
                }
            }
            res.push_back(temp);
        }
        return res;
    }
};
```

##### offer II 二叉树的右侧视图

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
> 示例1：
>
> ![tree](/images/tree.jpg)
>
> ```c++
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> ```

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(root==nullptr) return res;
        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()){
            int n=q.size();
            for(int i=0;i<n;i++){
                TreeNode* cur=q.front();
                q.pop();
                if(i==n-1){//找到每一层最右侧的节点
                    res.push_back(cur->val);
                }
                if(cur->left) q.push(cur->left);
                if(cur->right) q.push(cur->right);
            }
        }
        return res;
    }
};
```

