---
title: C++对C语言的加强
date: 2022-03-05 20:38:49
tags:
    - c++
categories:
    - C++语法
comments: true
---

> ​                                                                               C++对C语言的加强

<!-- more -->

##### namespace 命名空间

* 当使用的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。若不引入using namespace std ,需要这样做。std::cout。 
* C++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 
* C++命名空间的定义： namespace name { … } 
* using namespace NameSpaceA; 
* namespce定义可嵌套。 

##### “实用性“增强

```c++
// C语⾔中的变量都必须在作⽤域开始的位置定义！！
// C++中更强调语⾔的“实⽤性”，所有的变量都可以在需要使⽤时再定义。
```

##### 变量检测增强

```c++
/*
	在C语⾔中，重复定义多个同名的全局变量是合法的
	在C++中，不允许定义多个同名的全局变量
	C语⾔中多个同名的全局变量最终会被链接到全局数据区的同⼀个地址空间上
	int	g_var;
	int	g_var =	1;
	C++直接拒绝这种⼆义性的做法。
*/

#include<iostream>
int	g_var;	
int	g_var =	1;	
int	main(int argc, char	*argv[])	
{	
	printf("g_var =	%d\n", g_var);	
	return 0;	
}	
```

##### struct 类型增强

```c++
/*
	C语⾔的struct定义了⼀组变量的集合，C编译器并不认为这是⼀种新的类型
	C++中的struct是⼀个新类型的定义声明
*/
```

##### C++ 中所有变量和函数都必须有类型

```c++
/*
	C++中所有的变量和函数都必须有类型
	C语⾔中的默认类型在C++中是不合法的

在C语言中 
    int f( )；表示返回值为int，接受任意参数的函数 
    int f(void)；表示返回值为int的无参函数 
在C++中 
    int f( );和int f(void)具有相同的意义，都表示返回值为int的无参函数
C++更加强调类型，任意的程序元素都必须显示指明类型
*/
```

##### 新增bool 类型关键字

```c++
/*
	C++中的布尔类型
	C++在C语⾔的基本类型系统之上增加了bool
	C++中的bool可取的值只有true和false
	理论上bool只占⽤⼀个字节，
	如果多个bool变量定义在⼀起，可能会各占⼀个bit，这取决于编译器的实现
	true代表真值，编译器内部⽤1来表⽰
	false代表⾮真值，编译器内部⽤0来表⽰
	bool类型只有true（⾮0）和false（0）两个值
	C++编译器会在赋值时将⾮0值转换为true，0值转换为false
*/
```

##### 三目运算符功能增强

* C语言返回变量的值 C++语言是返回变量本身 

  >C语言中的三目运算符返回的是变量值，不能作为左值使用 
  >C++中的三目运算符可直接返回变量本身，因此可以出现在程序的任何地方 

* 注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用 

  > (a < b ? 1 : b )= 30; 

* C语言如何支持类似C++的特性呢？ 

  > 当左值的条件：要有内存空间；C++编译器帮助程序员取了一个地址

##### const 增强

###### const 基础知识

const修饰指针有三种情况
1. const修饰指针 --- 常量指针
2. const修饰常量 --- 指针常量
3. const即修饰指针，又修饰常量

```c++
int main() {
    
    int a = 10;
    int b = 10;
    
    //const修饰的是指针，指针指向可以改，指针指向的值不可以更改
    const int * p1 = &a;
    p1 = &b; //正确
    //*p1 = 100; 报错
   
    //const修饰的是常量，指针指向不可以改，指针指向的值可以更改
    int * const p2 = &a;
    //p2 = &b; //错误
    *p2 = 100; //正确
    
    //const既修饰指针又修饰常量
    const int * const p3 = &a;
    //p3 = &b; //错误
    //*p3 = 100; //错误
   
    system("pause");
   return 0;
}

```

> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量

合理的利用const的好处，

1. 指针做函数参数，可以有效的提高代码可读性，减少bug；
2. 清楚的分清参数的输入和输出特性

###### const 和 #define

C++中的const修饰的，是一个真正的常量，而不是C中变量（只读）。在const修饰的常量编译期间，就已经确定下来了

C++中的const常量类似于宏定义

> const int c = 5;   ≈   #define c 5

C++中的const常量与宏定义不同

* const常量是由编译器处理的，提供类型检查和作用域检查
* 宏定义由预处理器处理，单纯的文本替换

> * C语言中的const变量 
>
>   > C语言中const变量是只读变量，有自己的存储空间
>
> * C++中的const常量可能分配存储空间,也可能不分配存储空间 
>
>   > 当const常量为全局，并且需要在其它文件中使用，会分配存储空间 
>   > 当使用&操作符，取const常量的地址时，会分配存储空间 
>   > 当const int &a = 10; const修饰引用时，也会分配存储空间 

##### 真正的枚举

c 语言中枚举本质就是整型,枚举变量可以用任意整型赋值。而 c++中枚举变量, 只能用被枚举出来的元素初始化。

```c++
#include<iostream>
using namespace	std;	
enum season{SPR,SUM,AUT,WIN};	
int	main()	
{	
	enum season	s =	SPR;	
	//s	= 0;				    //	error,	但是C语⾔可以通过
	s =	SUM;	
    cout<< "s =	" << s <<endl;	//1
	return 0;	
}
```