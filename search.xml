<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基本计算器</title>
      <link href="/2022/08/15/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2022/08/15/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基本计算器</p></blockquote><span id="more"></span><h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：由于只有+、-操作，将括号展开，借助于栈</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; sign;      <span class="hljs-comment">//栈顶记录当前符号</span><br>        sign.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);        <span class="hljs-comment">//默认为 +</span><br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> op = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s)&#123;    <span class="hljs-comment">//遍历 空格自动跳过</span><br>            <span class="hljs-keyword">if</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;   <span class="hljs-comment">//遇到数值</span><br>                num = num*<span class="hljs-number">10</span> + (ch-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            res += op * num;  <span class="hljs-comment">//计算一个运算符</span><br>            num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//数值清空</span><br><br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;+&#x27;</span>) op = sign.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) op = -sign.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;(&#x27;</span>) sign.<span class="hljs-built_in">push</span>(op); <span class="hljs-comment">//进入左括号，把左括号之前的符号置于栈顶</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;)&#x27;</span>) sign.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//退出括号，弹出栈顶符号</span><br>        &#125;<br><br>        res += op*num;   <span class="hljs-comment">//计算最后一个数</span><br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈 </category>
          
          <category> 基本计算器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆波兰表达式求值</title>
      <link href="/2022/08/14/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2022/08/14/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>逆波兰表达式求值</p></blockquote><span id="more"></span><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-type">int</span> n=tokens.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;+&quot;</span> || tokens[i]==<span class="hljs-string">&quot;-&quot;</span> || tokens[i]==<span class="hljs-string">&quot;*&quot;</span> || tokens[i]==<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                <span class="hljs-type">int</span> num2 = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num1 = stk.<span class="hljs-built_in">top</span>();<br>                stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;+&quot;</span>)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(num1+num2);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;-&quot;</span>)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(num1-num2);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(num1*num2);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;/&quot;</span>)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(num1/num2);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//数字入栈</span><br>                stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈 </category>
          
          <category> 逆波兰表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流中的中位数</title>
      <link href="/2022/07/31/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/07/31/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据流中的中位数</p></blockquote><span id="more"></span><h4 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <br>    <span class="hljs-comment">//大顶堆 存较小值</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; min_pq;<br>    <span class="hljs-comment">//小根堆 存较大值</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; max_pq;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-comment">//先加入到较小值部分</span><br>        min_pq.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-comment">//将较小值中最大值 移入较大值部分</span><br>        max_pq.<span class="hljs-built_in">push</span>(min_pq.<span class="hljs-built_in">top</span>());<br>        min_pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//平衡数量</span><br>        <span class="hljs-keyword">if</span>(min_pq.<span class="hljs-built_in">size</span>() &lt; max_pq.<span class="hljs-built_in">size</span>())&#123;<br>            min_pq.<span class="hljs-built_in">push</span>(max_pq.<span class="hljs-built_in">top</span>());<br>            max_pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//奇数个数</span><br>        <span class="hljs-keyword">if</span>(min_pq.<span class="hljs-built_in">size</span>()&gt;max_pq.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)min_pq.<span class="hljs-built_in">top</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//偶数个数</span><br>            <span class="hljs-built_in">return</span> (<span class="hljs-type">double</span>)(min_pq.<span class="hljs-built_in">top</span>()+max_pq.<span class="hljs-built_in">top</span>())/<span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj-&gt;addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
          <category> 数据流中的中位数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长递增子序列相关</title>
      <link href="/2022/07/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/07/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最长递增子序列及其变种</p></blockquote><span id="more"></span><h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i]表示以nums[i]结尾的最长递增子序列的长度</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-comment">//寻找nums[0...j-1]中比nums[i]小的元素</span><br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                    <span class="hljs-comment">//把nums[i]接在后面，形成长度为dp[j]+1，且以nums[i]为结尾的递增子序列</span><br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354.俄罗斯套娃信封问题"></a><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354.俄罗斯套娃信封问题</a></h4><blockquote><p>这道题目是最长递增子序列的一个变种，相当于在二维平面中找一个最长递增子序列，其长度就是最多能嵌套的信封个数。</p><p>思路：先对宽w进行升序排序，如果遇到w相等，则按照高度h降序排序；之后把所有的h作为一个数组，在这个数组上计算最长递增子序列的长度就是答案。</p><p>但是此方法：leetcode会超时</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">Cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&gt;b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;<br>        <span class="hljs-comment">//按照 w 升序排列，如果 w 相等，则按照 h 降序排列</span><br>        <span class="hljs-built_in">sort</span>(envelopes.<span class="hljs-built_in">begin</span>(), envelopes.<span class="hljs-built_in">end</span>(), Cmp);<br>        <span class="hljs-type">int</span> n=envelopes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            nums[i]=envelopes[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">LIS</span>(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//最长递增子序列</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res=<span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划，最长上升子序列的变形</span><br><br>        <span class="hljs-comment">//按照第一个值，宽 升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>]&gt;intervals[j][<span class="hljs-number">0</span>] &amp;&amp; intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">1</span>])<br>                 <span class="hljs-comment">// 如果w, h严格升序，尝试更新dp[i]</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//leetcode 也会超时</span><br></code></pre></td></tr></table></figure><h4 id="面试题-17-08-马戏团人塔"><a href="#面试题-17-08-马戏团人塔" class="headerlink" title="面试题 17.08.马戏团人塔"></a><a href="https://leetcode.cn/problems/circus-tower-lcci/">面试题 17.08.马戏团人塔</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bestSeqAtIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height, vector&lt;<span class="hljs-type">int</span>&gt;&amp; weight)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划</span><br>        <span class="hljs-type">int</span> n=height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//将身高和体重一一对应起来</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; nums;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            nums.<span class="hljs-built_in">push_back</span>(&#123;height[i], weight[i]&#125;);<br>        &#125;<br>        <br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i][<span class="hljs-number">0</span>]&gt;nums[j][<span class="hljs-number">0</span>] &amp;&amp; nums[i][<span class="hljs-number">1</span>]&gt;nums[j][<span class="hljs-number">1</span>])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//leetcode 会超时</span><br></code></pre></td></tr></table></figure><h4 id="面试题-08-13-堆箱子"><a href="#面试题-08-13-堆箱子" class="headerlink" title="面试题 08.13.堆箱子"></a><a href="https://leetcode.cn/problems/pile-box-lcci/">面试题 08.13.堆箱子</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pileBox</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; box)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=box.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(box.<span class="hljs-built_in">begin</span>(), box.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//dp[i]表示以第i个结尾的箱子，</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i]=box[i][<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(box[i][<span class="hljs-number">0</span>]&gt;box[j][<span class="hljs-number">0</span>] &amp;&amp; box[i][<span class="hljs-number">1</span>]&gt;box[j][<span class="hljs-number">1</span>] &amp;&amp; box[i][<span class="hljs-number">2</span>]&gt;box[j][<span class="hljs-number">2</span>])&#123;<br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i], dp[j]+box[i][<span class="hljs-number">2</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 最长递增子序列相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2022/07/08/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/07/08/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单工厂、工厂方法、抽象工厂</p></blockquote><span id="more"></span><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><h5 id="定义与结构"><a href="#定义与结构" class="headerlink" title="定义与结构"></a>定义与结构</h5><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，简单工厂模式中专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p>直白地讲，简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。</p><p>简单工厂模式并不在 GoF 23 种设计模式之列，与其说其是设计模式，不如说是一种编程习惯。</p><p>简单工厂模式中包含如下角色：</p><ul><li><p>Factory：工厂角色</p><p>工厂角色负责实现创建所有实例的内部逻辑。</p></li><li><p>Product：抽象产品角色</p><p>抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。</p></li><li><p>ConcreteProduct：具体产品角色</p><p>具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</p></li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：</p><ul><li>实现了对象创建和使用的分离。</li><li>不需要记住具体类名，记住参数即可，减少使用者记忆量。</li></ul><p>缺点：</p><ul><li>对工厂类职责过重，一旦不能工作，系统受到影响。</li><li>增加系统中类的个数，复杂度和理解度增加。</li><li>违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。</li></ul><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li></ul><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象水果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruit</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> :<span class="hljs-keyword">public</span> AbstractFruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是苹果!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> :<span class="hljs-keyword">public</span> AbstractFruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是香蕉!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> :<span class="hljs-keyword">public</span> AbstractFruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是鸭梨!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//水果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactor</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> AbstractFruit * <span class="hljs-title">CreateFruit</span><span class="hljs-params">(string flag)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&quot;apple&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&quot;banana&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&quot;pear&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>FruitFactor* factory = <span class="hljs-keyword">new</span> FruitFactor;<br>AbstractFruit* fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">&quot;apple&quot;</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">&quot;banana&quot;</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">&quot;pear&quot;</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">delete</span> factory;<br>factory = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><h5 id="定义与结构-1"><a href="#定义与结构-1" class="headerlink" title="定义与结构"></a>定义与结构</h5><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><p>直白地讲，“工厂方法模式”是对简单工厂模式的进一步抽象化，只是工厂方法把产品的实例化操作推迟到子类。</p><p>工厂方法模式由4个要素构成：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 createProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点</p><ul><li>用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><p>缺点</p><ul><li>类的个数容易过多，增加复杂度。</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。</li><li>抽象产品只能生产一种产品。</li></ul><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><p>在工厂方法模式中，客户端不需知道具体产品类的类名，只需知道创建具体产品的工厂类；对于抽象工厂抽象工厂类，只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。</p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象水果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruit</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> :<span class="hljs-keyword">public</span> AbstractFruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是苹果!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> :<span class="hljs-keyword">public</span> AbstractFruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是香蕉!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> :<span class="hljs-keyword">public</span> AbstractFruit &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是鸭梨!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//苹果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//香蕉工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//鸭梨工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PearFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>AbstractFruitFactory* factory = <span class="hljs-literal">NULL</span>;<br>AbstractFruit* fruit = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//创建一个苹果工厂</span><br>factory = <span class="hljs-keyword">new</span> AppleFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br><br><span class="hljs-comment">//创建一个香蕉工厂</span><br>factory = <span class="hljs-keyword">new</span> BananaFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br><br><span class="hljs-comment">//创建一个鸭梨工厂</span><br>factory = <span class="hljs-keyword">new</span> PearFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br>fruit = <span class="hljs-literal">NULL</span>;<br>factory = <span class="hljs-literal">NULL</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><h5 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h5><p>为了更清晰地理解工厂方法模式，先理解两个概念：</p><ul><li><p>产品等级 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p></li><li><p>产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</p><p><img src="/images/%E4%BA%A7%E5%93%81%E7%BB%93%E6%9E%84.png" alt="产品结构"></p></li></ul><h5 id="定义与结构-2"><a href="#定义与结构-2" class="headerlink" title="定义与结构"></a>定义与结构</h5><p>抽象工厂模式(Abstract Factory Pattern)：提供一个接口，用于创建创建一系列相关或相互依赖对象的家族，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p><p>抽象工厂模式与工厂方法模式区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。</p><p>抽象工厂模式同工厂方法模式一样，也是由4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。</p><ul><li>AbstractFactory：抽象工厂</li><li>ConcreteFactory：具体工厂</li><li>AbstractProduct：抽象产品</li><li>Product：具体产品</li></ul><h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点</p><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建，从具体的产品解耦出来。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><p>缺点</p><ul><li>开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）</li></ul><h5 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li></ul><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApple</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//中国苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaApple</span> :<span class="hljs-keyword">public</span> AbstractApple &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;中国苹果！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//美国苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAApple</span> :<span class="hljs-keyword">public</span> AbstractApple &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;美国苹果！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//日本苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanApple</span> :<span class="hljs-keyword">public</span> AbstractApple &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;日本苹果！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//抽象香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBanana</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//中国香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaBanana</span> :<span class="hljs-keyword">public</span> AbstractBanana &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;中国香蕉！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//美国香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USABanan</span> :<span class="hljs-keyword">public</span> AbstractBanana &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;美国香蕉！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//日本香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanBanan</span> :<span class="hljs-keyword">public</span> AbstractBanana &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;日本香蕉！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//抽象鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPear</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><br><span class="hljs-comment">//中国鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaPear</span>:<span class="hljs-keyword">public</span> AbstractPear&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;中国鸭梨！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//美国鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAPear</span> :<span class="hljs-keyword">public</span> AbstractPear &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;美国鸭梨！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//日本鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanPear</span> :<span class="hljs-keyword">public</span> AbstractPear &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;日本鸭梨！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">//抽象工厂 针对产品族</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//中国工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaApple;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaBanana;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaPear;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//美国工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USAApple;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USABanan;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>  USAPear;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//日本工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanApple;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanBanan;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>  JapanPear;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>AbstractFactory* factory = <span class="hljs-literal">NULL</span>;<br>AbstractApple* apple = <span class="hljs-literal">NULL</span>;<br>AbstractBanana* banana = <span class="hljs-literal">NULL</span>;<br>AbstractPear* pear = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//中国工厂</span><br>factory = <span class="hljs-keyword">new</span> ChinaFactory;<br>apple = factory-&gt;<span class="hljs-built_in">CreateApple</span>();<br>banana = factory-&gt;<span class="hljs-built_in">CreateBanana</span>();<br>pear = factory-&gt;<span class="hljs-built_in">CreatePear</span>();<br><br>apple-&gt;<span class="hljs-built_in">ShowName</span>();<br>banana-&gt;<span class="hljs-built_in">ShowName</span>();<br>pear-&gt;<span class="hljs-built_in">ShowName</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 工厂模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用基础命令</title>
      <link href="/2022/07/07/Linux%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/07/07/Linux%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文详细列举了一些Linux常用基础命令</p></blockquote><span id="more"></span><h2 id="Linux系统的文件"><a href="#Linux系统的文件" class="headerlink" title="Linux系统的文件"></a>Linux系统的文件</h2><h3 id="1、文件与文件夹（目录）"><a href="#1、文件与文件夹（目录）" class="headerlink" title="1、文件与文件夹（目录）"></a>1、文件与文件夹（目录）</h3><p>Linux一切皆文件</p><h3 id="2、Linux系统的文件目录结构"><a href="#2、Linux系统的文件目录结构" class="headerlink" title="2、Linux系统的文件目录结构"></a>2、Linux系统的文件目录结构</h3><p>目录结构：</p><p>Bin：全称binary，含义是二进制，存储的都是一些二进制文件。</p><p>Dev：主要存放的是外接设备。例如：盘、其他的光盘等。不能直接使用，需要挂载。</p><p>Etc：主要存储一些配置文件。</p><p>Home：家。除了root用户以外其他用户的家目录。</p><p>Proc：process，表示进程，存储的是Linux运行时候的进程。</p><p>Root：是root用户自己的家目录。</p><p>Sbin：全称：super binary，存储一些可执行的二进制文件，但必须有super权限的用户才能执行。</p><p>Tmp：“临时的”，存放系统运行时候产生的临时文件。</p><p>Usr：存放用户自己安装的软件 。</p><p>Var：存放程序或系统的日志文件。</p><p>Mnt：挂载的时候，需要挂载到mnt目录下。</p><h2 id="Linux-的基本指令"><a href="#Linux-的基本指令" class="headerlink" title="Linux 的基本指令"></a>Linux 的基本指令</h2><h3 id="指令与选项"><a href="#指令与选项" class="headerlink" title="指令与选项"></a>指令与选项</h3><p>完整指令标准格式：</p><p>#指令  【选项】  【操作对象】</p><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><h4 id="1、ls-指令"><a href="#1、ls-指令" class="headerlink" title="1、ls 指令"></a>1、ls 指令</h4><p>含义：ls（list），列出当前工作目录下的所有文件或文件夹的名称。</p><p>用法2: #ls 路径</p><p>含义：指定路径下的所有文件或文件夹的名称。</p><p>绝对路径：直接从根目录下开始</p><p>相对路径</p><p>相对路径的写法，用到2个符号，“.&#x2F;”表示当前目录下，  “..&#x2F;“表示上一级目录下</p><p> 用法3：#ls  选项  路径    含义：以指定的格式进行显示</p><p>常见语法：</p><p>#ls -l 路径  表示以详细列表的形式进行展示</p><p>#ls -a 路径  表示显示所有的文件或文件夹（包含隐藏文件或文件夹）</p><p>#ls -h 路径  表示在显示文档大小的时候以可读性较高的形式显示</p><p>可以同时使用 #ls -lah  路径</p><p>第一列字符表示文档的类型，其中”-“表示为文件，”d“表示为文件夹。</p><p>Linux中隐藏文件一般都是以”.“开头。</p><p>ls列出的结果颜色说明</p><p>蓝色表示文件夹，黑色表示文件，绿色的其权限为拥有所有权。</p><h4 id="2、pwd-指令"><a href="#2、pwd-指令" class="headerlink" title="2、pwd 指令"></a>2、pwd 指令</h4><p>用法：（print-working-directory） 打印当前工作目录</p><h4 id="3、cd-指令"><a href="#3、cd-指令" class="headerlink" title="3、cd 指令"></a>3、cd 指令</h4><p>（change directory）切换当前工作目录</p><p>语法：#cd  路径</p><p>在Linux中有一个特殊的符号”~“，表示当前用户的家目录</p><p>切换方式：#cd ~</p><h4 id="4、mkdir-指令"><a href="#4、mkdir-指令" class="headerlink" title="4、mkdir 指令"></a>4、mkdir 指令</h4><p>创建目录</p><p>语法：#mkdir  路径    （路径可以是文件夹名称，也可以是一个完整路径）</p><p>例：  #mkdir   &#x2F;root&#x2F;new     在指定目录下创建文件夹。</p><p>语法2：  #mkdir   -p  路径         </p><p>#mkdir  -p  实现多层创建   </p><p>当一次性创建多层不存在的目录的时候，添加 -p参数，否则报错</p><p>-v  参数    能够输出详细的过程</p><p>语法3： #mkdir  路径1  路径2     一次性创建多个文件目录</p><h4 id="5、touch-指令"><a href="#5、touch-指令" class="headerlink" title="5、touch 指令"></a>5、touch 指令</h4><p>作用：创建文件</p><p>语法：#touch 文件路径（可为文件，可为路径）</p><h4 id="6、cp-指令"><a href="#6、cp-指令" class="headerlink" title="6、cp 指令"></a>6、cp 指令</h4><p>作用：复制文件或文件夹到指定的位置</p><p>语法：#cp 被复制的文档路径   指定位置</p><p>复制过去可以通过命令改名字</p><p>例：linux.txt 存在于 &#x2F;home&#x2F;123  下面</p><p>cp  linux.txt    &#x2F;home&#x2F;123&#x2F;linux1.txt</p><p>注意：当使用cp命令进行文件夹复制操作的时候，</p><p>需要添加选项”-r“，否则目录将被忽略。</p><p>(-r  表示递归复制)</p><h4 id="7、mv-指令"><a href="#7、mv-指令" class="headerlink" title="7、mv 指令"></a>7、mv 指令</h4><p>（move移动，复制）作用：移动文档到新的位置</p><p>语法：#mv  需要移动的文档   新位置</p><p>移动后原始文件不在原来的位置</p><p>补充：在Linux中重命名的命令也是mv，语法和移动的语法一样</p><h4 id="8、rm-指令"><a href="#8、rm-指令" class="headerlink" title="8、rm 指令"></a>8、rm 指令</h4><p>作用：移除或删除文档&#x2F;文件&#x2F;文件夹</p><p>语法：#rm  选项  需要移除的文档路径</p><p>在删除的时候如果不带选项，会提示是否删除</p><p>-f   表示强制</p><p>-r   表示递归删除</p><p>可同时删除多个，用空格隔开即可</p><p>一般将 -fr 连着用</p><p>删除一个目录下有公共特性的文档，如都以linux开头，则用：#rm  -rf  linux*    ，用”<em>“，”</em>“ 称为通配符</p><h4 id="9、vim-指令"><a href="#9、vim-指令" class="headerlink" title="9、vim 指令"></a>9、vim 指令</h4><p>指令：vim（是一款文本编辑器）</p><p>语法：#vim  文件的路径</p><p>作用：打开一个文件</p><h4 id="10、输出重定向"><a href="#10、输出重定向" class="headerlink" title="10、输出重定向"></a>10、输出重定向</h4><p>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析统计，则这时候需要使用到输出重定向技术。      </p><p>:                            &gt;     覆盖输出（会覆盖掉原先的文件内容）     </p><p>​                            》    追加输出（不会覆盖掉原始文件的内容，会在原始内容末尾继续添加）</p><p>语法：#正常执行的指令  &gt;或》文件的路径</p><p>注意：文件可以不存在，不存在则新建</p><p>例：使用覆盖重定向，保存ls -la 的执行结果，保存到当前目录下的 ls.txt</p><p> 语法为：#ls -la &gt; ls.txt</p><h4 id="11、cat-指令"><a href="#11、cat-指令" class="headerlink" title="11、cat 指令"></a>11、cat 指令</h4><p>作用1：cat 有直接打开一个文件的功能</p><p>语法：#cat  文件的路径</p><p>作用2：对文件进行合并</p><p>语法：#cat  待合并文件路径1   待合并文件路径2  &gt;  合并后的文件路径</p><h3 id="三、进阶指令"><a href="#三、进阶指令" class="headerlink" title="三、进阶指令"></a>三、进阶指令</h3><h4 id="1、df-指令"><a href="#1、df-指令" class="headerlink" title="1、df 指令"></a>1、df 指令</h4><p>作用：查看磁盘的空间   （列出文件系统的整体磁盘使用量）</p><p>语法：#df  -h</p><p>-h 表示以可读性较高的形式展示大小</p><p>-a  列出所有的文件系统，包括系统特有的 &#x2F;proc等文件系统</p><p>-T  连同该硬盘分区的文件系统名称（如xfs）也列出                                                                                                                                                                                                                  </p><p>​      du 指令：查看文件系统的磁盘使用量（常用在查看目录所占磁盘空间）</p><p>-a：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量</p><p>-s：仅列出总量，而不列出每个各别的目录占用容量                                                                                                                                                                                                                                                                       </p><p>与df不一样的是，du这个命令其实会直接到文件系统内去查找所有的文件数据。</p><h4 id="2、free-指令"><a href="#2、free-指令" class="headerlink" title="2、free 指令"></a>2、free 指令</h4><p>作用：查看内存使用情况</p><p>语法：# free -m</p><p>-m 表示以mb（兆）为单位进行查看</p><h4 id="3、head-指令"><a href="#3、head-指令" class="headerlink" title="3、head 指令"></a>3、head 指令</h4><p>作用：查看一个文件的前n行，如果不指定n，则默认是显示前10行</p><p>语法：#head  -n  文件路径  （n用具体数字表示）</p><h4 id="4、tail-指令"><a href="#4、tail-指令" class="headerlink" title="4、tail 指令"></a>4、tail 指令</h4><p>作用：查看一个文件的末尾n行，如果n不指定，则默认为后10行</p><p>语法：tail  -n  文件路径  （n用具体数字表示）</p><p>作用2：可以通过tail指令来查看一个文件的动态变化</p><p>语法：#tail  -f  文件路径</p><h4 id="5、less-指令"><a href="#5、less-指令" class="headerlink" title="5、less 指令"></a>5、less 指令</h4><p>作用：查看文件，以较少的内容进行输出，按下辅助功能键查看更多</p><p>语法：#less  需要查看的文件路径</p><h4 id="6、wc-指令"><a href="#6、wc-指令" class="headerlink" title="6、wc 指令"></a>6、wc 指令</h4><p>作用：统计文件内容信息，包括行数、单词数、字节数</p><p>语法：wc  -lwc  需要统计的文件路径</p><p>-l ：行数</p><p>-w：单词数（依照空格来判断单词数量）</p><p>-c：字节数</p><p>如：  ls -l | grep “^-“ |wc -l</p><h4 id="7、date-指令"><a href="#7、date-指令" class="headerlink" title="7、date 指令"></a>7、date 指令</h4><p>作用：表示操作时间日期（读取、设置）</p><p>语法1：#date（直接date）</p><p>语法2：#date  +%F  输出形式  2021-03-17    等价于 #date  +“%Y-%m-%d”</p><p>语法3：#date  “+%F%T”   输出年月日时分秒</p><p>语法4：#date  -d  “-1 day”表示1天前的时间   </p><p>​              获取之前或者之后的某个时间      +表示之后  -表示之前   year，day，month</p><p>%F：表示完整的年月日  </p><p>%T：表示完整的时分秒</p><p>%Y：表示四位年份</p><p>%m：表示两位月份（带前导0）</p><p>%d：表示日期（带前导0）</p><p>%H：表示小时（带前导0）</p><p>%M：表示分钟（带前导0）</p><p>%S：表示秒数（带前导0）</p><h4 id="8、cal-指令"><a href="#8、cal-指令" class="headerlink" title="8、cal 指令"></a>8、cal 指令</h4><p>作用：用来操作日历</p><p>语法1：#cal      等价于 #cal  -1</p><p>直接输出当前月份的日历</p><p>语法2：#cal  -3</p><p>表示输出上一个月、本月+下一个月3个月份的日历</p><p>语法3：#cal  -y   年份</p><p>表示输出某一个年份的日历</p><p>例：  #cal   -y  2020   输出2020年的日历</p><h4 id="9、clear-x2F-ctrl-L-指令"><a href="#9、clear-x2F-ctrl-L-指令" class="headerlink" title="9、clear&#x2F;ctrl  +L 指令"></a>9、clear&#x2F;ctrl  +L 指令</h4><p>作用：清除终端中已经存在的命令和结果或信息</p><p>注意：该命令并不是真的清除了之前的信息，而是把之前的信息隐藏到了最上面，通过滚动条可以继续查看以前的信息</p><h4 id="10、管道"><a href="#10、管道" class="headerlink" title="10、管道"></a>10、管道</h4><p>管道符： | （竖线）</p><p>作用：管道一般可用于“过滤”，“特殊”，“扩展处理”。</p><p>语法：管道不能单独使用，必须要配合前面所讲的一些指令来一起使用，起作用主要是辅助作用</p><p>过滤案例：需要通过管道查询出根目录下包含“y”字母的名称</p><p>  #ls  &#x2F;| grep  y</p><p>针对上面这个命令说明：</p><p>1&gt; 管道作为分界线，前面的命令的输出就是后面命令的输入，然后再过滤输出</p><p>2&gt;grep 指令，主要用于过滤</p><h4 id="11、ss-指令"><a href="#11、ss-指令" class="headerlink" title="11、ss 指令"></a>11、ss 指令</h4><p>用于查看端口号</p><p>ss  -tanl</p><h4 id="12、stat-指令"><a href="#12、stat-指令" class="headerlink" title="12、stat 指令"></a>12、stat 指令</h4><p>stat指令：文件&#x2F;文件系统的详细信息显示。</p><p>stat命令主要用于显示文件或文件系统的详细信息，</p><p><img src="https://img-blog.csdn.net/20161001092623041" alt="img"></p><hr><h4 id="13、-which-指令"><a href="#13、-which-指令" class="headerlink" title="13、 which 指令"></a>13、 which 指令</h4><p>which指令会在环境变量 $PATH 设置的目录里查找符合条件的文件。</p><h4 id="14、-locate指令"><a href="#14、-locate指令" class="headerlink" title="14、 locate指令"></a>14、 locate指令</h4><p>locate 要搜索的文件或目录名，非实时的从数据库里快速搜索文件或目录。</p><h4 id="15、-nl-指令"><a href="#15、-nl-指令" class="headerlink" title="15、 nl 指令"></a>15、 nl 指令</h4><p>nl命令在linux]系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 </p><p>1．命令格式：</p><p>nl [选项]… [文件]…</p><p>2．命令参数：</p><p>-b ：指定行号指定的方式，主要有两种：</p><p>​          -b    a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</p><p>​           -b   t ：如果有空行，空的那一行不要列出行号(默认值)；</p><p>-n ：列出行号表示的方法，主要有三种：</p><p>​           -n  ln ：行号在萤幕的最左方显示；</p><p>​           -n  rn ：行号在自己栏位的最右方显示，且不加 0 ；</p><p>​           -n  rz ：行号在自己栏位的最右方显示，且加 0 ；</p><p>-w ：行号栏位的占用的位数。</p><p>-p 在逻辑定界符处不重新开始计算。</p><h3 id="四、高级指令"><a href="#四、高级指令" class="headerlink" title="四、高级指令"></a>四、高级指令</h3><h4 id="1、hostname-指令"><a href="#1、hostname-指令" class="headerlink" title="1、hostname 指令"></a>1、hostname 指令</h4><p>作用：操作服务器的主机名（读取）</p><p>语法：#hostname        表示输出完整的主机名</p><p>语法2：#hostname  -f    表示输出当前主机名中的 FQDN（全限定域名）</p><h4 id="2、id-指令"><a href="#2、id-指令" class="headerlink" title="2、id 指令"></a>2、id 指令</h4><p>作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id）</p><p>该指令如果不指定用户则默认为当前用户</p><p>#语法：#id     默认显示当前执行该命令的用户的基本信息</p><p>#语法2：#id   用户名  显示指定用户的基本信息</p><h4 id="3、whoami-指令"><a href="#3、whoami-指令" class="headerlink" title="3、whoami 指令"></a>3、whoami 指令</h4><p>作用：“我是谁”？显示当前登录的用户名</p><p>语法：#whoami  </p><h4 id="4、ps-ef-指令"><a href="#4、ps-ef-指令" class="headerlink" title="4、ps  -ef 指令"></a>4、ps  -ef 指令</h4><p>指令 ps，作用主要是查看服务器的进程信息。</p><p>选项含义：</p><p>​                  -e：表示列出全部的进程 </p><p>​                  -f ：表示显示全部的列（显示全字段）</p><p>执行结果：</p><p>各列的含义：</p><p>UID：该进程执行的用户id</p><p>PID：进程id</p><p>PPID：该进程的父级进程id</p><p>C：CPU的占用率</p><p>TIME：进程的执行时间</p><p>CMD：该进程的名称或者对应的路径</p><p>STIME：进程的启动时间</p><h4 id="5、top-指令"><a href="#5、top-指令" class="headerlink" title="5、top 指令"></a>5、top 指令</h4><p>作用：查看服务器的进程占用的资源</p><p>语法：进入命令  #top         动态显示</p><p>​           退出命令：按下q键</p><p>输出的结果：</p><p>表头含义：</p><p>PID：进程id</p><p>USER：该进程对应的用户</p><p>PR：优先级</p><p>VIRT：虚拟内存</p><p>在运行top的时候，可以按下方便的快捷键</p><p>M：表示将结果按照内存（MEM）从高到低进行排列；</p><p>P：表示将结果按照cpu使用率从高到低排列；</p><p>1：服务器拥有多个CPU的时候可以使用“1”，快捷键来切换是否展示各个CPU的详细信息；</p><h4 id="6、du-sh-指令"><a href="#6、du-sh-指令" class="headerlink" title="6、du  -sh 指令"></a>6、du  -sh 指令</h4><p>作用：查看目录的大小</p><p>选项含义：</p><p>​                -s：只显示汇总的大小；</p><p>​                -h：以高可读性的形式进行显示；</p><h4 id="7、find-指令"><a href="#7、find-指令" class="headerlink" title="7、find 指令"></a>7、find 指令</h4><p>作用：用于查找文件（其参数有55个之多）</p><p>语法：#find  路径范围  选项  选项值</p><p>选项：</p><p>​          -name：按照文档名称进行搜索（支持模糊搜索）</p><p>​          -type：按照文档类型进行搜索</p><p>​                       文档类型：“-”表示文件，（在使用find的时候需要用f来替换）</p><p>​                                          “d”表示文件夹</p><p>示例：使用find来搜索 httpd.conf</p><p>#find &#x2F; -name  httpd.conf</p><p>示例：搜索etc目录下所有的.conf后缀文件</p><p>#find &#x2F;etc  -name  *conf</p><h4 id="8、service-指令"><a href="#8、service-指令" class="headerlink" title="8、service 指令"></a>8、service 指令</h4><p>作用：用于控制一些软件的服务启动&#x2F;停止&#x2F;重启</p><p>语法：#service  服务名  start&#x2F;stop&#x2F;restart</p><p>例如：</p><p>需要重启本机安装的Apache（网站服务器软件），其服务名为httpd</p><p>#service   httpd  start</p><h4 id="9、kill-指令"><a href="#9、kill-指令" class="headerlink" title="9、kill 指令"></a>9、kill 指令</h4><p>作用：表示杀死进程 (当遇到僵尸进程或者出于某些原因需要关闭进程的时候)</p><p>语法：#kill   进程ID    （语法需要配合ps一起使用）</p><p>与kill命令作用相似但是比kill更加好用的杀死进程的命令：killall</p><p>语法：#killall   进程名称</p><h4 id="10、ifconfig-指令"><a href="#10、ifconfig-指令" class="headerlink" title="10、ifconfig 指令"></a>10、ifconfig 指令</h4><p>作用：用于操作网卡相关的指令</p><p>简单语法：#ifconfig      获取网卡信息</p><h4 id="11、reboot-指令"><a href="#11、reboot-指令" class="headerlink" title="11、reboot 指令"></a>11、reboot 指令</h4><p>作用：重新启动计算机</p><p>语法：#reboot</p><p>语法2：#reboot  -w  模拟重启，但是不重启，只写关机与开机的日志信息</p><h4 id="12、shutdown-指令"><a href="#12、shutdown-指令" class="headerlink" title="12、shutdown 指令"></a>12、shutdown 指令</h4><p>作用：关机（慎用）</p><p>语法：shutdown  -h  now  或者 shutdown  -h  15：25 （指定关机时间）</p><p>如果想要取消关机计划的话，则可以用命令  shutdown -c</p><p>除了shutdown关机以外，还有以下几个关机命令：</p><p>​              #init 0</p><p>​              #halt</p><p>​              #poweroff</p><h4 id="13、up-time-指令"><a href="#13、up-time-指令" class="headerlink" title="13、up time 指令"></a>13、up time 指令</h4><p>作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间）</p><p>语法：#up time</p><h4 id="14、uname-指令"><a href="#14、uname-指令" class="headerlink" title="14、uname 指令"></a>14、uname 指令</h4><p>作用：获取计算机操作系统相关信息</p><p>语法：#uname</p><p>语法2：#uname  -a  表示获取全部的系统信息</p><p>语法3： #uname -r  输出内核发行版本</p><h4 id="15、netstat-指令"><a href="#15、netstat-指令" class="headerlink" title="15、netstat 指令"></a>15、netstat 指令</h4><p>作用：查看网络连接状态</p><p>语法：netstat   -tnlp</p><p>选项：</p><p>​        -t：表示只列出tcp协议的连接</p><p>​        -n：表示将地址从字母组合转化程ip地址，将协议化成端口号来显示</p><p>​        -l：表示过滤出”stat（状态）“列中其值为LISTEN（监听）的连接</p><p>​        -p：显示发起连接的进程pid和进程名称</p><h4 id="16、man-指令"><a href="#16、man-指令" class="headerlink" title="16、man 指令"></a>16、man 指令</h4><p>作用：manual，手册（包含了Linux中全部命令手册，英文）</p><p>语法：#man  命令  （退出按下q键）</p><p>例：通过man命令查询cp 指令的用法</p><p>#man  cp</p><hr><p>前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p><p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。<br>如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p><p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p><hr><h4 id="17、scp-指令"><a href="#17、scp-指令" class="headerlink" title="17、scp 指令"></a>17、scp 指令</h4><p>Linux scp 命令用于 Linux 之间复制文件和目录。</p><p>scp 是 secure copy 的缩写, scp 是 Linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p><p>scp 是加密的，<a href="https://www.runoob.com/linux/linux-comm-rcp.html">rcp</a> 是不加密的，scp 是 rcp 的加强版。</p><ul><li>-p：保留原文件的修改时间，访问时间和访问权限。</li><li>-q： 不显示传输进度条。</li><li>-r： 递归复制整个目录。</li><li>-v：详细方式显示输出。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">scp local_file remote_username<span class="hljs-keyword">@remote</span>_<span class="hljs-attribute">ip</span>:remote_folder <br>或者 <br>scp local_file remote_username<span class="hljs-keyword">@remote</span>_<span class="hljs-attribute">ip</span>:remote_file <br>或者 <br>scp local_file remote_<span class="hljs-attribute">ip</span>:remote_folder <br>或者 <br>scp local_file remote_<span class="hljs-attribute">ip</span>:remote_file <br></code></pre></td></tr></table></figure><ul><li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；</li><li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li></ul><h4 id="18-、nl命令"><a href="#18-、nl命令" class="headerlink" title="18 、nl命令"></a>18 、nl命令</h4><p>nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</p><p><strong>1．****命令格式：</strong></p><p>nl [选项]… [文件]…</p><p><strong>2．****命令参数：</strong></p><p>-b ：指定行号指定的方式，主要有两种：</p><p>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；</p><p>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</p><p>-n ：列出行号表示的方法，主要有三种：</p><p>-n ln ：行号在萤幕的最左方显示；</p><p>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；</p><p>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</p><p>-w ：行号栏位的占用的位数。</p><p>-p 在逻辑定界符处不重新开始计算。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux 常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转数组相关</title>
      <link href="/2022/07/01/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2022/07/01/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>189.旋转数组、寻找旋转排序数组中的最小值 I、寻找旋转排序数组中的最小值 II、搜索旋转排序数组 I、搜索旋转排序数组 II、面试题 10.03.搜索旋转数组</p></blockquote><span id="more"></span><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189.旋转数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        k = k%n;<br><br>        <span class="hljs-comment">//先整个翻转</span><br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//翻转前k个</span><br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//翻转后n-k个</span><br>        <span class="hljs-built_in">reverse</span>(nums, k, n<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(start&lt;end)&#123;<br>            <span class="hljs-type">int</span> temp=nums[start];<br>            nums[start++]=nums[end];<br>            nums[end--]=temp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="153-寻找旋转排序数组中的最小值-I"><a href="#153-寻找旋转排序数组中的最小值-I" class="headerlink" title="153.寻找旋转排序数组中的最小值 I"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153.寻找旋转排序数组中的最小值 I</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//数组中最后一个元素，最小值右边的一定比它小，最小值左边的一定比它大</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])&#123;<br>                right=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154.寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">154.寻找旋转排序数组中的最小值 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//数组中最后一个元素，最小值右边的一定比它小，最小值左边的一定比它大</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])&#123;<br>                right=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//将right左移一位</span><br>                right=right<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33.搜索旋转排序数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target) <span class="hljs-keyword">return</span> mid;<br><br>            <span class="hljs-comment">//右半部分是有序的</span><br>            <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>]&gt;nums[mid])&#123; <br>                <span class="hljs-comment">//target落在右半部分有序区域内</span><br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[n<span class="hljs-number">-1</span>])&#123;<br>                    left = mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//target落在左半部分无序区域内</span><br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//左半部分是有序的</span><br>                <span class="hljs-comment">//target落在左半部分有序区域内</span><br>                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=target &amp;&amp; target&lt;nums[mid])&#123;<br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//target落在右半部分无序区域内</span><br>                    left = mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//解法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k&lt;n &amp;&amp; nums[k] &gt;= nums[k<span class="hljs-number">-1</span>]) k++;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-type">int</span> left_val = <span class="hljs-built_in">BinarySearch</span>(nums, target, <span class="hljs-number">0</span>, k<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> right_val = <span class="hljs-built_in">BinarySearch</span>(nums, target, k, n<span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span>(left_val!=<span class="hljs-number">-1</span>) res=left_val;<br>        <span class="hljs-keyword">if</span>(right_val!=<span class="hljs-number">-1</span>) res=right_val;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//二分查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=low;<br>        <span class="hljs-type">int</span> right=high;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81.搜索旋转排序数组 II"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81.搜索旋转排序数组 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-comment">//重点在于处理重复数字</span><br>            <span class="hljs-comment">//左边有重复数字，将左边界右移</span><br>            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="hljs-number">1</span>]) left++;<br>            <span class="hljs-comment">//右边有重复数字，将右边界左移</span><br>            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right<span class="hljs-number">-1</span>]) right--;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//左半部分是有序</span><br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=nums[mid])&#123;<br>                <span class="hljs-comment">//target落在左半部分有序区域内</span><br>                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=target &amp;&amp; target&lt;nums[mid])&#123;<br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//target落在右半部分无序区域内</span><br>                    left = mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//右半部分是有序</span><br>                <span class="hljs-comment">//target落在右半部分有序区域内</span><br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[n<span class="hljs-number">-1</span>])&#123;<br>                    left = mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//target落在左半部分无序区域内</span><br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03.搜索旋转数组"></a><a href="https://leetcode.cn/problems/search-rotate-array-lcci/">面试题 10.03.搜索旋转数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-comment">//当left符合时直接返回，因为找的是最小的索引</span><br>            <span class="hljs-keyword">if</span>(arr[left]==target) <span class="hljs-keyword">return</span> left;<br><br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//当中间值等于target，将右边界移到中间，因为左边可能还有相等的值</span><br>            <span class="hljs-keyword">if</span>(arr[mid]==target)&#123;<br>                right=mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>]&lt;arr[mid])&#123;      <span class="hljs-comment">//左半部分是有序</span><br>                <span class="hljs-comment">//target落在左半部分有序区域内</span><br>                <span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>]&lt;=target &amp;&amp; target&lt;arr[mid])&#123;<br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//target落在右半部分无序区域内</span><br>                    left = mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[<span class="hljs-number">0</span>]&gt;arr[mid])&#123; <span class="hljs-comment">//右半部分是有序</span><br>                <span class="hljs-comment">//target落在右半部分有序区域内</span><br>                <span class="hljs-keyword">if</span>(arr[mid]&lt;target &amp;&amp; target&lt;=arr[n<span class="hljs-number">-1</span>])&#123;<br>                    left = mid+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//target落在左半部分无序区域内</span><br>                    right = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//当中间数字与左边数字相等时，将左边界右移</span><br>                left=left+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分查找 </category>
          
          <category> 搜索旋转数组相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1</title>
      <link href="/2022/06/30/k8s/"/>
      <url>/2022/06/30/k8s/</url>
      
        <content type="html"><![CDATA[<blockquote><p>kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器—-Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。</p></blockquote><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东哥经典动态规划</title>
      <link href="/2022/06/20/%E4%B8%9C%E5%93%A5%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/06/20/%E4%B8%9C%E5%93%A5%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>labuladong 的经典动态规划题</p></blockquote><span id="more"></span><h4 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53.最大子数组和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> res=INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1800-最大升序子数组和"><a href="#1800-最大升序子数组和" class="headerlink" title="1800.最大升序子数组和"></a><a href="https://leetcode.cn/problems/maximum-ascending-subarray-sum/">1800.最大升序子数组和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAscendingSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i<span class="hljs-number">-1</span>])&#123;<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+nums[i], nums[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i]=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1186-删除一次得到子数组最大和"><a href="#1186-删除一次得到子数组最大和" class="headerlink" title="1186.删除一次得到子数组最大和"></a><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/">1186.删除一次得到子数组最大和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=INT_MIN;<br><br>        <span class="hljs-comment">//dp0[i]代表以arr[i]为结尾的最大连续子数组和</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp0</span><span class="hljs-params">(n)</span></span>;  <br>        <span class="hljs-comment">//dp1[i]代表以arr[i]为结尾的并且删除了一个元素（可能是arr[i]自己）后最大的连续子数组和</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(n)</span></span>; <br><br>        <span class="hljs-comment">//base case</span><br>        dp0[<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>];<br>        dp1[<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">//因为删除元素后不能为空，所以dp1[0]=arr[0];</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp0[i]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>]+arr[i], arr[i]);<br>            dp1[i]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>], dp1[i<span class="hljs-number">-1</span>]+arr[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(dp0[i], res);<br>            res = <span class="hljs-built_in">max</span>(dp1[i], res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152.乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">152.乘积最大子数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//dp_min[i] 以 nums[i] 结尾的连续子数组的乘积的最小值</span><br>        <span class="hljs-comment">//dp_max[i] 以 nums[i] 结尾的连续子数组的乘积的最大值</span><br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp_min</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp_max</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-comment">//base case</span><br>        dp_max[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        dp_min[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp_max[i]=<span class="hljs-built_in">max</span>(dp_max[i<span class="hljs-number">-1</span>]*nums[i], nums[i]);<br>                dp_min[i]=<span class="hljs-built_in">min</span>(dp_min[i<span class="hljs-number">-1</span>]*nums[i], nums[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp_max[i]=<span class="hljs-built_in">max</span>(dp_min[i<span class="hljs-number">-1</span>]*nums[i], nums[i]);<br>                dp_min[i]=<span class="hljs-built_in">min</span>(dp_max[i<span class="hljs-number">-1</span>]*nums[i], nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp_max[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64.最小路径和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划</span><br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br><br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+grid[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]+grid[<span class="hljs-number">0</span>][i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[i][j]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])+grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72.编辑距离</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-comment">//word1[0..i] 和 word2[0..j] 的最小编辑距离是 dp[i][j]</span><br>        <span class="hljs-type">int</span> m=word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j]=j;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>]==word2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];    <span class="hljs-comment">//什么都不做</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//dp[i-1][j] 删除，dp[i][j-1]插入，dp[i-1][j-1]替换</span><br>                    dp[i][j]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300.最长递增子序列</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i]表示以nums[i]结尾的最长递增子序列的长度</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-comment">//寻找nums[0...j-1]中比nums[i]小的元素</span><br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                    <span class="hljs-comment">//把nums[i]接在后面，形成长度为dp[j]+1，且以nums[i]为结尾的递增子序列</span><br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354.俄罗斯套娃信封问题"></a><a href="https://leetcode.cn/problems/russian-doll-envelopes/">354.俄罗斯套娃信封问题</a></h4><blockquote><p>这道题目是最长递增子序列的一个变种，相当于在二维平面中找一个最长递增子序列，其长度就是最多能嵌套的信封个数。</p><p>思路：先对宽w进行升序排序，如果遇到w相等，则按照高度h降序排序；之后把所有的h作为一个数组，在这个数组上计算最长递增子序列的长度就是答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">Cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&gt;b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;<br>        <span class="hljs-comment">//按照 w 升序排列，如果 w 相等，则按照 h 降序排列</span><br>        <span class="hljs-built_in">sort</span>(envelopes.<span class="hljs-built_in">begin</span>(), envelopes.<span class="hljs-built_in">end</span>(), Cmp);<br>        <span class="hljs-type">int</span> n=envelopes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            nums[i]=envelopes[i][<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">LIS</span>(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//最长递增子序列</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res=<span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673.最长递增子序列的个数"></a><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">673.最长递增子序列的个数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//以nums[i]结尾的最长上升子序列的长度</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//以nums[i]结尾的最长上升子序列的个数</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                    <span class="hljs-keyword">if</span>(dp[j]+<span class="hljs-number">1</span> &gt; dp[i])&#123;<br>                        count[i] = count[j];<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]+<span class="hljs-number">1</span> == dp[i])&#123;<br>                        count[i] +=count[j];<br>                    &#125;<br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res=<span class="hljs-built_in">max</span>(res, dp[i]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i]==res) result += count[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143.最长公共子序列</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=text1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=text2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//定义：对于text1[0...i-1] 和 text2[0...j-1]，的最长公共子序列为 dp[i][j]</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>]==text2[j<span class="hljs-number">-1</span>])&#123;<br>                    <span class="hljs-comment">//找到一个lcs中的元素</span><br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//至少有一个字符不在 lcs 中</span><br>                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583.两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583.两个字符串的删除操作</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-comment">//删除之后的结果，就是最长公共子序列;</span><br>        <span class="hljs-type">int</span> m=word1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=word2.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">return</span> m+n<span class="hljs-number">-2</span>*<span class="hljs-built_in">LCS</span>(word1, word2);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCS</span><span class="hljs-params">(string s1, string s2)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=s2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>]==s2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712.两个字符串的最小ASCII删除和"></a><a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">712.两个字符串的最小ASCII删除和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=s1.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-type">int</span> n=s2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//dp[i][j]代表s1[:i]和s2[:j]的最小删除和</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//base case;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+s1[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j]=dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>]+s2[j<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>]==s2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j]+s1[i<span class="hljs-number">-1</span>], dp[i][j<span class="hljs-number">-1</span>]+s2[j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718.最长重复子数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划：dp[i][j]表示 nums1[0...i-1]和nums2[0...j-1]结尾的最长重复子数组</span><br>        <span class="hljs-type">int</span> m=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = INT_MIN;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums1[i<span class="hljs-number">-1</span>]==nums2[j<span class="hljs-number">-1</span>])&#123;<br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 东哥经典动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者模型</title>
      <link href="/2022/06/14/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/06/14/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                                           生产者消费者模型</p></blockquote><span id="more"></span><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>生产者  ——&gt;  放入数据  ——&gt;  缓冲区  &lt;——  消费者</p><p>生产者-消费者问题描述：</p><ul><li>⽣产者在⽣成数据后，放在⼀个缓冲区中；</li><li>消费者从缓冲区取出数据处理；</li><li>任何时刻，只能有⼀个⽣产者或消费者可以访问缓冲区；</li></ul><p>问题分析：</p><ul><li>任何时刻只能有⼀个线程操作缓冲区，说明操作缓冲区是临界代码，<strong>需要互斥</strong>；</li><li>缓冲区空时，消费者必须等待⽣产者⽣成数据；缓冲区满时，⽣产者必须等待消费者取出数据。说明⽣产者和消费者<strong>需要同步</strong>。</li></ul><p>需要三个信号量，分别是：</p><ul><li>互斥信号量 mutex ：⽤于互斥访问缓冲区，初始化值为 1；</li><li>资源信号量 fullBuffer ：⽤于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区⼀开始为空）；</li><li>资源信号量 emptyBuffer ：⽤于⽣产者询问缓冲区是否有空位，有空位则⽣成数据，初始化值为 n （缓冲区⼤⼩）；</li></ul><p>具体实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br>semaphore mutex = <span class="hljs-number">1</span>;         <span class="hljs-comment">//互斥信号量，用于临界区的互斥访问</span><br>semaphore emptyBuffer = N;  <span class="hljs-comment">//表示缓冲区 [空槽] 的个数</span><br>semaphore fullBuffer = <span class="hljs-number">0</span>;   <span class="hljs-comment">//表示缓冲区 [满槽] 的个数</span><br><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">P</span>(emptyBuffer);         <span class="hljs-comment">//将空槽的个数 -1</span><br>        <span class="hljs-built_in">P</span>(mutex);               <span class="hljs-comment">//进入临界区</span><br>        将生产的数据放到缓冲区中； <br>        <span class="hljs-built_in">V</span>(mutex);               <span class="hljs-comment">//离开临界区</span><br>        <span class="hljs-built_in">V</span>(fullBuffer);          <span class="hljs-comment">//将满槽的个数 +1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//消费者线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">P</span>(fullBuffer);          <span class="hljs-comment">//将满槽个数 -1</span><br>        <span class="hljs-built_in">P</span>(mutex);               <span class="hljs-comment">//进入临界区</span><br>        从缓冲区读取数据;<br>        <span class="hljs-built_in">V</span>(mutex);               <span class="hljs-comment">//离开临界区</span><br>        <span class="hljs-built_in">V</span>(emptyBuffer);         <span class="hljs-comment">//将空槽的个数 +1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果消费者线程⼀开始执⾏ P(fullBuffers) ，由于信号量 fullBuffers 初始值为 0，则此时 fullBuffers 的值从 0 变为 -1，说明缓冲区⾥没有数据，消费者只能等待。</p><p>接着，轮到⽣产者执⾏ P(emptyBuffers) ，表示减少 1 个空槽，如果当前没有其他⽣产者线程在临界区执⾏代码，那么该⽣产者线程就可以把数据放到缓冲区，放完后，执⾏V(fullBuffers) ，信号量 fullBuffers 从 -1 变成 0，表明有「消费者」线程正在阻塞等待数据，于是阻塞等待的消费者线程会被唤醒。</p><p>消费者线程被唤醒后，如果此时没有其他消费者线程在读数据，那么就可以直接进⼊临界区，从缓冲区读取数据。最后，离开临界区后，把空槽的个数 + 1。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程/多进程 </category>
          
          <category> 生产者消费者模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现智能指针</title>
      <link href="/2022/06/14/%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2022/06/14/%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 带引用计数的智能指针的实现</p></blockquote><span id="more"></span><h4 id="智能指针的原理"><a href="#智能指针的原理" class="headerlink" title="智能指针的原理"></a>智能指针的原理</h4><p>智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。</p><h4 id="常用的智能指针"><a href="#常用的智能指针" class="headerlink" title="常用的智能指针"></a>常用的智能指针</h4><p>unique_ptr，一个智能指针独占一块内存资源，其生命周期从 unique_ptr 指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁。不支持复制和赋值，直接赋值会编译出错。实在想赋值的话，需要使用：std::move。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//例如：</span><br> <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p2 = p1;    <span class="hljs-comment">// 编译会出错</span><br> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = std::<span class="hljs-built_in">move</span>(p1); <span class="hljs-comment">// 转移所有权, 现在那块内存归p3所有, p1成为无效的指针.</span><br></code></pre></td></tr></table></figure><p>shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。</p><p>weak_ptr，弱引用。 引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。</p><h4 id="智能指针的实现"><a href="#智能指针的实现" class="headerlink" title="智能指针的实现"></a>智能指针的实现</h4><h5 id="C-中智能指针的实现主要依赖于两个技术："><a href="#C-中智能指针的实现主要依赖于两个技术：" class="headerlink" title="C++中智能指针的实现主要依赖于两个技术："></a>C++中智能指针的实现主要依赖于两个技术：</h5><p>1、<strong>析构函数</strong>，对象被销毁时会被调用的一个函数，对于基于栈的对象而言，如果对象离开其作用域则对象会被自动销毁，而此时析构函数也自动会被调用。</p><p>2、<strong>引用计数技术</strong>，维护一个计数器用于追踪资源(如内存)的被引用数，当资源被引用时，计数器值加1，当资源被解引用时，计算器值减1。</p><p>3、<strong>操作符重载</strong>，智能指针的大致实现原理就是在析构函数中，检查所引用对象的引用计数，如果引用计数为0，则真正释放该对象内存。</p><h5 id="实现带引用计数的智能指针"><a href="#实现带引用计数的智能指针" class="headerlink" title="实现带引用计数的智能指针"></a>实现带引用计数的智能指针</h5><p>1、接收不同对象类型的构造函数</p><p>这个构造函数实现，比较简单，直接将引用计数+1即可。</p><p>2、析构函数</p><p>析构函数的实现，不能直接做 delete 操作，而是需要先对引用计数 -1，当引用计数为 0 时，才做 delete 操作。</p><p>3、拷贝构造函数</p><p>拷贝构造函数的实现，底层指针共享，然后将引用计数 +1 即可。</p><p>4、赋值操作符</p><p>赋值操作符的实现，稍微复杂一些，涉及到将新指向对象的引用计数 +1，将原指向对象的引用计数 -1，如果有需要还要销毁原指向对象。</p><p>为了能够使用引用计数技术，我们的智能指针不能再像原生指针那样能用可以指向任意资源对象，我们的智能指针只能指向实现了存在方法 <code>incRefCount</code> 和方法 <code>decRefCount</code> 的资源类了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//带引用计数的智能指针的实现</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">//将智能指针定义成模板类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPointer</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//默认构造函数</span><br><span class="hljs-built_in">SmartPointer</span>() :<span class="hljs-built_in">mPointer</span>(<span class="hljs-literal">NULL</span>) &#123;<br><br>&#125;<br><span class="hljs-comment">//有参构造函数，接收不同指针类型的构造函数</span><br><span class="hljs-built_in">SmartPointer</span>(T *p) :<span class="hljs-built_in">mPointer</span>(p); &#123;<br><br><span class="hljs-comment">//智能指针指向类T，引用计数+1</span><br><span class="hljs-keyword">if</span> (mPointer) mPointer-&gt;<span class="hljs-built_in">incRefCount</span>();<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">SmartPointer</span>(<span class="hljs-type">const</span> SmartPointer &amp;tmp) :<span class="hljs-built_in">mPointer</span>(tmp.mPointer) &#123;<br><br><span class="hljs-comment">//引用计数+1</span><br><span class="hljs-keyword">if</span> (mPointer) mPointer-&gt;<span class="hljs-built_in">incRefCount</span>();<br>&#125;<br><span class="hljs-comment">//赋值操作符重载</span><br>SmartPointer &amp;<span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> SmartPointer &amp;tmp) &#123;<br><br>T *<span class="hljs-built_in">other</span>(tmp.mPointer);<br><span class="hljs-comment">//新指向对象，引用计数值 +1；</span><br><span class="hljs-keyword">if</span> (other) other-&gt;<span class="hljs-built_in">incRefCount</span>();<br><span class="hljs-comment">//原指向对象，引用计数值-1。如果 -1 之后引用计数为0，则销毁原资源对象</span><br><span class="hljs-keyword">if</span> (mPointer &amp;&amp; mPointer-&gt;<span class="hljs-built_in">decRefCount</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">delete</span> mPointer;<br><br><span class="hljs-comment">//智能指针指向新资源对象</span><br>mPointer = other;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">SmartPointer</span>() &#123;<br><span class="hljs-comment">//实现内存资源自动销毁</span><br><span class="hljs-keyword">if</span> (mPointer &amp;&amp; mPointer-&gt;<span class="hljs-built_in">decRefCount</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">delete</span> mPointer;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T *mPointer; <span class="hljs-comment">//指向智能指针实际对应的内存资源，根据参数自动推导规则，定义内部资源指针类型</span><br>&#125;;<br><br><span class="hljs-comment">//引用计数基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">RefBase</span>() : <span class="hljs-built_in">mCount</span>(<span class="hljs-number">0</span>) &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">incRefCount</span><span class="hljs-params">()</span> </span>&#123;<br>mCount++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">decRefCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> mCount--;<br>&#125;<br><span class="hljs-comment">//调试接口，返回对象当前引用计数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRefCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> mCount;<br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RefBase</span>() &#123;<br><br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mCount;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 智能指针测试代码 case 测试智能指针的引用计数功能</span><br><br><span class="hljs-comment">//继承于引用计数基类的SomeClass类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> : <span class="hljs-keyword">public</span> RefBase &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">SomeClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;SomeClass default constructor !&quot;</span> &lt;&lt; std::endl; &#125;<br>~<span class="hljs-built_in">SomeClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;SomeClass deconstructor !&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testcase</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>SomeClass* pSomeClass = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SomeClass</span>();              <span class="hljs-comment">//1</span><br>SmartPointer&lt;SomeClass&gt; spOuter = pSomeClass;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;SomeClass Ref Count (&quot;</span> &lt;&lt; pSomeClass-&gt;<span class="hljs-built_in">getRefCount</span>() &lt;&lt; <span class="hljs-string">&quot;) outer 1.&quot;</span> &lt;&lt; std::endl;<br>&#123; <span class="hljs-comment">// inner 语句块</span><br>SmartPointer&lt;SomeClass&gt; spInner = spOuter;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;SomeClass Ref Count (&quot;</span> &lt;&lt; pSomeClass-&gt;<span class="hljs-built_in">getRefCount</span>() &lt;&lt; <span class="hljs-string">&quot;) inner.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;SomeClass Ref Count (&quot;</span> &lt;&lt; pSomeClass-&gt;<span class="hljs-built_in">getRefCount</span>() &lt;&lt; <span class="hljs-string">&quot;) outer 2.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">// delete pSomeClass ; 不需要也不能执行delete操作!</span><br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;new another SomeClass class for spOuter.&quot;</span> &lt;&lt; std::endl;<br>SmartPointer&lt;SomeClass&gt; spOuter2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SomeClass</span>();<br>spOuter = spOuter2;<span class="hljs-comment">// 1处new出来的SomeClass将会被自动释放  </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">testcase</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 智能指针 </category>
          
          <category> 实现智能指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/2022/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2022/06/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>验证二叉搜索树、二叉搜索树中第k小的元素、把二叉搜索树转换为累加树、二叉搜索树中的搜索、二叉搜索树中的插入操作、删除二叉搜索树中的节点、不同的二叉搜索树 I、不同的二叉搜索树 II</p></blockquote><span id="more"></span><h4 id="BST的遍历框架"><a href="#BST的遍历框架" class="headerlink" title="BST的遍历框架"></a>BST的遍历框架</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root-&gt;val == target)&#123;<br>        <span class="hljs-comment">//找到目标，做点什么</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &lt; target)&#123;<br>        <span class="hljs-built_in">BST</span>(root-&gt;right, target);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root-&gt;val &gt; target)&#123;<br>        <span class="hljs-built_in">BST</span>(root-&gt;left, target);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98.验证二叉搜索树</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-comment">//借助辅助函数，給所有子树节点添加一个 min 和 max 边界</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root, TreeNode* min, TreeNode* max)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">if</span>(min!=<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;val&lt;=min-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(max!=<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;val&gt;=max-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(root-&gt;left, min, root) &amp;&amp; <span class="hljs-built_in">helper</span>(root-&gt;right, root, max);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="230-二叉搜索树中第k小的元素"><a href="#230-二叉搜索树中第k小的元素" class="headerlink" title="230.二叉搜索树中第k小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230.二叉搜索树中第k小的元素</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：利用二叉搜索树中序遍历性质</span><br><br>        <span class="hljs-built_in">traverse</span>(root, k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录结果</span><br>    <span class="hljs-type">int</span> rank=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录排名</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">traverse</span>(root-&gt;left, k);<br><br>        <span class="hljs-comment">//中序</span><br>        rank++;<br>        <span class="hljs-keyword">if</span>(rank==k)&#123;<br>            <span class="hljs-comment">//找多第k小的元素</span><br>            res=root-&gt;val;<br>        &#125;<br><br>        <span class="hljs-built_in">traverse</span>(root-&gt;right, k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转换为累加树</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：利用二叉搜索树中序遍历性质，</span><br>        <span class="hljs-comment">//为求大于等于当前节点的和，先遍历右子树，再根节点，后左子树</span><br><br>        <span class="hljs-built_in">traverse</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录累加和</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-built_in">traverse</span>(root-&gt;right);<br><br>        sum += root-&gt;val; <span class="hljs-comment">//维护累加和</span><br>        root-&gt;val = sum; <span class="hljs-comment">//转化成累加树</span><br><br>        <span class="hljs-built_in">traverse</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700.二叉搜索树中的搜索</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701.二叉搜索树中的插入操作</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">//找到空位置插入新节点</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>            TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">//val 大，则插到右子树上面</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val)&#123;<br>            root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        &#125;<br>        <span class="hljs-comment">//val 小，则插到左子树上面</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val)&#123;<br>            root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450.删除二叉搜索树中的节点</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val==key)&#123;<br>            <span class="hljs-comment">//恰好是末端节点, 直接删除</span><br>            <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-comment">//只有一个非空子节点，删除之后要让他的孩子节点接替他的位置</span><br>            <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>            <span class="hljs-keyword">if</span>(root-&gt;right==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br><br>            <span class="hljs-comment">//有两个非空子节点， 必须找到左子树最大的节点或者右子树最小的节点来接替</span><br>            <span class="hljs-comment">//这里选择右子树最小的节点</span><br><br>            <span class="hljs-comment">//找到右子树最小的节点</span><br>            TreeNode* minNode = <span class="hljs-built_in">getMin</span>(root-&gt;right);<br>            <span class="hljs-comment">//将root改成minNode</span><br>            root-&gt;val = minNode-&gt;val;<br>            <span class="hljs-comment">//转而去删除 minNode</span><br>            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &gt; key)&#123;<br>            root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; key)&#123;<br>            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">getMin</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;<br>        <span class="hljs-comment">//BST最左边的就是最小的</span><br>        <span class="hljs-keyword">while</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>) node=node-&gt;left;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指offer-36-二叉搜索树与双向链表"><a href="#剑指offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指offer 36.二叉搜索树与双向链表"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指offer 36.二叉搜索树与双向链表</a></h4><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/tu-wen-bing-mao-zui-tong-su-yi-dong-de-t-0adg/"><strong>思路</strong></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* pre=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//用于保存中序遍历的前一个节点</span><br>    Node* head=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//用于记录排序链表的头节点</span><br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <br>        <span class="hljs-comment">//连接首尾</span><br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 遍历左子树</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br><br>        <span class="hljs-comment">/*中序遍历位置*/</span><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>) pre-&gt;right = root; <span class="hljs-comment">//将前驱节点的右指针指向当前根节点</span><br>        <span class="hljs-keyword">else</span> head = root; <span class="hljs-comment">//保存链表头节点</span><br>        root-&gt;left = pre; <span class="hljs-comment">//root的left指针指向其前驱</span><br>        pre = root; <span class="hljs-comment">//前驱节点右移</span><br>         <br>        <span class="hljs-comment">// 遍历右子树</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="96-不同的二叉搜索树-I"><a href="#96-不同的二叉搜索树-I" class="headerlink" title="96.不同的二叉搜索树 I"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96.不同的二叉搜索树 I</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i]表示i个节点组成的不同二叉排序树的总数</span><br>        <span class="hljs-comment">// dp[n] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] </span><br>        <span class="hljs-comment">// + dp[2] * d[i - 3] + ... + dp[i - 1] * dp[0];</span><br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                dp[i] += dp[j<span class="hljs-number">-1</span>]*dp[i-j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95.不同的二叉搜索树 II"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95.不同的二叉搜索树 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：</span><br>        <span class="hljs-comment">//遍历不同的节点并使其作为根节点</span><br>        <span class="hljs-comment">//构建左右子树+根节点</span><br>        <span class="hljs-comment">//构成一颗完整的树</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n);<br>        <br>    &#125;<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        vector&lt;TreeNode*&gt; res;<br>        <span class="hljs-keyword">if</span>(low &gt; high)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">nullptr</span>);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">//遍历每一个节点作为根节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=low;i&lt;=high;i++)&#123;<br>            <span class="hljs-comment">//构建左右子树</span><br>            vector&lt;TreeNode*&gt; left = <span class="hljs-built_in">build</span>(low, i<span class="hljs-number">-1</span>);<br>            vector&lt;TreeNode*&gt; right = <span class="hljs-built_in">build</span>(i+<span class="hljs-number">1</span>, high);<br>            <span class="hljs-comment">//遍历左右子树，再利用上根节点[i]来构建完整的树</span><br>            <span class="hljs-keyword">for</span>(TreeNode* leftNode : left)&#123;<br>                <span class="hljs-keyword">for</span>(TreeNode* rightNode : right)&#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>                    root-&gt;left = leftNode;<br>                    root-&gt;right = rightNode;<br>                    res.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指offer 68-I 二叉搜索树的最近公共祖先"></a><a href="">剑指offer 68-I 二叉搜索树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;val&lt;p-&gt;val &amp;&amp; root-&gt;val&lt;q-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;val&gt;p-&gt;val &amp;&amp; root-&gt;val&gt;q-&gt;val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
          <category> 二叉搜索树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳跃游戏</title>
      <link href="/2022/06/11/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/06/11/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>跳跃游戏 I、跳跃游戏 II、跳跃游戏 III</p></blockquote><span id="more"></span><h4 id="55-跳跃游戏-I"><a href="#55-跳跃游戏-I" class="headerlink" title="55.跳跃游戏 I"></a><a href="https://leetcode.cn/problems/jump-game/">55.跳跃游戏 I</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：贪心</span><br>        <span class="hljs-comment">//最远能跳多远，如果能越过最后一格，返回 true，否则返回 false</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> farthest = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-comment">// 更新能跳到的最远距离</span><br>            farthest = <span class="hljs-built_in">max</span>(farthest, i+nums[i]);<br>            <span class="hljs-comment">// 可能碰到了 0，卡住跳不动了</span><br>            <span class="hljs-keyword">if</span>(farthest&lt;=i) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> farthest &gt;= n<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45.跳跃游戏 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//贪心</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>; <span class="hljs-comment">//标记可以选择的跳跃步数的最后一个</span><br>        <span class="hljs-type">int</span> farthest=<span class="hljs-number">0</span>; <span class="hljs-comment">//所有可选择跳跃步数[i...end]中能够跳到的最远距离</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;  <span class="hljs-comment">//记录跳跃次数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-comment">// 更新能跳到的最远距离</span><br>            farthest = <span class="hljs-built_in">max</span>(farthest, i+nums[i]);<br>            <span class="hljs-keyword">if</span>(end==i)&#123; <br>                res++;<br>                end = farthest;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1306-跳跃游戏-III"><a href="#1306-跳跃游戏-III" class="headerlink" title="1306.跳跃游戏 III"></a><a href="https://leetcode.cn/problems/jump-game-iii/">1306.跳跃游戏 III</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canReach</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-comment">//BFS</span><br>        <span class="hljs-keyword">if</span>(arr[start]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isVisited</span><span class="hljs-params">(n)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        isVisited[start] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//可以达到位置 cur+arr[cur]，并且没有被搜索过</span><br>            <span class="hljs-keyword">if</span>(cur+arr[cur]&lt;n &amp;&amp; !isVisited[cur+arr[cur]])&#123;<br>                <span class="hljs-keyword">if</span>(arr[cur+arr[cur]] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                q.<span class="hljs-built_in">push</span>(cur+arr[cur]);<br>                isVisited[cur+arr[cur]] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//可以达到位置 cur-arr[cur]，并且没有被搜索过</span><br>            <span class="hljs-keyword">if</span>(cur-arr[cur]&gt;=<span class="hljs-number">0</span> &amp;&amp; !isVisited[cur-arr[cur]])&#123;<br>                <span class="hljs-keyword">if</span>(arr[cur-arr[cur]] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                q.<span class="hljs-built_in">push</span>(cur-arr[cur]);<br>                isVisited[cur-arr[cur]] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
          <category> 跳跃游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经分享的一些动态规划题合集</title>
      <link href="/2022/06/09/%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2022/06/09/%E9%9D%A2%E7%BB%8F%E5%88%86%E4%BA%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>牛客网面经中的一些动态规划面试题</p></blockquote><span id="more"></span><h4 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983.最低票价"></a><a href="https://leetcode.cn/problems/minimum-cost-for-tickets/">983.最低票价</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mincostTickets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; days, vector&lt;<span class="hljs-type">int</span>&gt;&amp; costs)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划 dp[i]表示到第 i 天结束时的最低消费</span><br>        <span class="hljs-comment">//状态转移方程：</span><br>        <span class="hljs-comment">//如果第 i 天需要通行证：</span><br>        <span class="hljs-comment">//  dp[i]=min(dp[i-1]+costs[0], dp[i-7]+costs[1], dp[i-30]+costs[2]);</span><br>        <span class="hljs-comment">//如果第 i 天不需要通行证：dp[i] = dp[i-1];</span><br><br>        <span class="hljs-type">int</span> n=days.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> lastDay = days[n<span class="hljs-number">-1</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(lastDay+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=lastDay;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==days[index])&#123;<br>               <span class="hljs-type">int</span> day1 = i<span class="hljs-number">-1</span>&gt;<span class="hljs-number">0</span> ? i<span class="hljs-number">-1</span> : <span class="hljs-number">0</span>;<br>               <span class="hljs-type">int</span> day2 = i<span class="hljs-number">-7</span>&gt;<span class="hljs-number">0</span> ? i<span class="hljs-number">-7</span> : <span class="hljs-number">0</span>;<br>               <span class="hljs-type">int</span> day3 = i<span class="hljs-number">-30</span>&gt;<span class="hljs-number">0</span> ? i<span class="hljs-number">-30</span> : <span class="hljs-number">0</span>;<br>               dp[i]=<span class="hljs-built_in">min</span>(dp[day1]+costs[<span class="hljs-number">0</span>], <span class="hljs-built_in">min</span>(dp[day2]+costs[<span class="hljs-number">1</span>], dp[day3]+costs[<span class="hljs-number">2</span>]));<br>               index++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[lastDay];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221.最大正方形</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划</span><br>        <span class="hljs-comment">//dp[i][j]表示以(i,j)为右下角，且只包含1的正方形的边长最大值</span><br>        <span class="hljs-comment">//状态转移方程：dp[i][j]=min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1</span><br>        <span class="hljs-comment">//还要考虑边界条件，如果i和j至少有一个为0，则dp[i][j]=1</span><br><br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span> || n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> maxSide=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> || j==<span class="hljs-number">0</span>)&#123;<br>                        dp[i][j]=<span class="hljs-number">1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        dp[i][j]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br>                    &#125;<br>                    maxSide = <span class="hljs-built_in">max</span>(maxSide, dp[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSide * maxSide;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指-Offer-II-098-路径的数目"><a href="#剑指-Offer-II-098-路径的数目" class="headerlink" title="剑指 Offer II 098. 路径的数目"></a><a href="https://leetcode.cn/problems/2AoeFn/">剑指 Offer II 098. 路径的数目</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br><br>        <span class="hljs-comment">///base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划  dp[i][j]表示达到i,j位置总共的路径数</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j]=<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 面经中出的动态规划面试题合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打家劫舍</title>
      <link href="/2022/06/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/2022/06/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 打家劫舍I II III</p></blockquote><span id="more"></span> <h5 id="198-打家劫舍-I"><a href="#198-打家劫舍-I" class="headerlink" title="198.打家劫舍 I"></a>198.打家劫舍 I</h5><blockquote><p><img src="/images/198.png" alt="198"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//有相应的测试样例才需要，没有不用也行</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-comment">//dp[i]表示长度为i的数组，最多能偷取多少钱</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//对于每家可以选择偷或者不偷</span><br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213.打家劫舍 II"></a>213.打家劫舍 II</h5><blockquote><p><img src="/images/213.png" alt="213"></p></blockquote><blockquote><p><img src="/images/213_1.png" alt="213_1"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">0</span>, n<span class="hljs-number">-2</span>), <span class="hljs-built_in">helper</span>(nums, <span class="hljs-number">1</span>, n<span class="hljs-number">-1</span>));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//dp[i]表示长度为i的数组，最多能偷取多少钱</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(start==<span class="hljs-number">0</span>)&#123;<br>            dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>            dp[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(start==<span class="hljs-number">1</span>)&#123;<br>            dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>            dp[<span class="hljs-number">1</span>]=nums[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=end;i++)&#123;<br>            <span class="hljs-comment">//对于每家可以选择偷或者不偷</span><br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i], dp[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[end];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337.打家劫舍 III"></a>337.打家劫舍 III</h5><blockquote><p><img src="/images/337.png" alt="337"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res = <span class="hljs-built_in">helper</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 长度为2的数组，0：不偷，1：偷</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">helper</span>(root-&gt;left);<br>        vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">helper</span>(root-&gt;right);<br><br>        <span class="hljs-comment">// 偷当前节点，字节点不偷</span><br>        <span class="hljs-type">int</span> res1 = root-&gt;val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 不偷当前节点，字节点可偷可不偷，取决于收益大小</span><br>        <span class="hljs-type">int</span> res2 = <span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">return</span> &#123;res2, res1&#125;;  <span class="hljs-comment">//注意顺序，res2在前，res1在后，因为是后序遍历</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 打家劫舍问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票买卖问题</title>
      <link href="/2022/05/19/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/19/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>买卖股票的最佳时机相关问题</p></blockquote><span id="more"></span><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><blockquote><p>只能交易一次</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp0</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//当天不持有股票</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//当天持有股票</span><br><br>        <span class="hljs-comment">//base case</span><br>        dp0[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp1[<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp0[i]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>], dp1[i<span class="hljs-number">-1</span>]+prices[i]);<br>            dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>], -prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><blockquote><p>交易次数不限</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp0</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//当天没有持有股票</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//当天持有股票</span><br><br>        <span class="hljs-comment">//base case</span><br>        dp0[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp1[<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp0[i]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>], dp1[i<span class="hljs-number">-1</span>]+prices[i]);<br>            dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>], dp0[i<span class="hljs-number">-1</span>]-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123.买卖股票的最佳时机 III"></a>123.买卖股票的最佳时机 III</h5><blockquote><p>最多交易两次</p></blockquote><blockquote><p><img src="/images/123.png" alt="123"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp0</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp1</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)&#123;<br>            dp0[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>            dp1[<span class="hljs-number">0</span>][i]=-prices[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&gt;<span class="hljs-number">0</span>;j--)&#123;<br>                dp0[i][j]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>][j], dp1[i<span class="hljs-number">-1</span>][j]+prices[i]);<br>                dp1[i][j]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>][j], dp0[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]-prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0[n<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188.买卖股票的最佳时机 IV"></a>188.买卖股票的最佳时机 IV</h5><blockquote><p>最多可以交易k次</p></blockquote><blockquote><p><img src="/images/188.png" alt="188"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-type">int</span> k, vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// k = min(n/2, k);</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp0</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k+<span class="hljs-number">1</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp1</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k+<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)&#123;<br>            dp0[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>            dp1[<span class="hljs-number">0</span>][i]=-prices[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=k;j&gt;<span class="hljs-number">0</span>;j--)&#123;<br>                dp0[i][j]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>][j], dp1[i<span class="hljs-number">-1</span>][j]+prices[i]);<br>                dp1[i][j]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>][j], dp0[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]-prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0[n<span class="hljs-number">-1</span>][k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h5><blockquote><p>交易次数不限，含冷冻期</p></blockquote><blockquote><p><img src="/images/309.png" alt="309"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp0</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-comment">//base case</span><br>        dp0[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp1[<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>];<br>        dp0[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp0[<span class="hljs-number">0</span>], dp1[<span class="hljs-number">0</span>]+prices[<span class="hljs-number">1</span>]);<br>        dp1[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp1[<span class="hljs-number">0</span>], -prices[<span class="hljs-number">1</span>]);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            dp0[i]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>], dp1[i<span class="hljs-number">-1</span>]+prices[i]);<br>            dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>], dp0[i<span class="hljs-number">-2</span>]-prices[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h5><blockquote><p>交易次数不限，含手续费</p></blockquote><blockquote><p><img src="/images/714.png" alt="714"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp0</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp1</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">//base case</span><br>        dp0[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp1[<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>]-fee;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp0[i]=<span class="hljs-built_in">max</span>(dp0[i<span class="hljs-number">-1</span>], dp1[i<span class="hljs-number">-1</span>]+prices[i]);<br>            dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>], dp0[i<span class="hljs-number">-1</span>]-prices[i]-fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp0[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 股票买卖问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树路径和相关</title>
      <link href="/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二叉树路径和相关</p></blockquote><span id="more"></span><h4 id="112-路径总和-I"><a href="#112-路径总和-I" class="headerlink" title="112.路径总和 I"></a><a href="https://leetcode.cn/problems/path-sum/">112.路径总和 I</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;val==targetSum) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum-root-&gt;val) || <br>            <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum-root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113.路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113.路径总和 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) &#123;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span></span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <br>        temp.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        sum += root-&gt;val;<br>        <span class="hljs-keyword">if</span>(sum==targetSum &amp;&amp; root-&gt;left==<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum);<br>        sum -= root-&gt;val;<br>        temp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437.路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437.路径总和 III</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">dfs</span>(root, targetSum);<br>        res += <span class="hljs-built_in">pathSum</span>(root-&gt;left, targetSum);<br>        res += <span class="hljs-built_in">pathSum</span>(root-&gt;right, targetSum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> targetSum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val==targetSum)&#123;<br>            res++;<br>        &#125;<br>        res += <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum-root-&gt;val);<br>        res += <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum-root-&gt;val);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="129-求根节点到叶子节点数字之和"><a href="#129-求根节点到叶子节点数字之和" class="headerlink" title="129. 求根节点到叶子节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶子节点数字之和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> prevSum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = prevSum*<span class="hljs-number">10</span> + root-&gt;val;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, sum)+<span class="hljs-built_in">dfs</span>(root-&gt;right, sum);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124.二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span> res=INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 递归计算左右子节点的最大贡献值</span><br>        <span class="hljs-comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span><br>        <span class="hljs-type">int</span> leftVal = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> rightVal = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dfs</span>(root-&gt;right), <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">//节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span><br>        <span class="hljs-type">int</span> curVal = root-&gt;val+leftVal+rightVal;<br><br>        <span class="hljs-comment">//更新答案</span><br>        res = <span class="hljs-built_in">max</span>(curVal, res);<br>        <br>        <span class="hljs-comment">// 返回节点的最大贡献值</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(leftVal, rightVal);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687.最长同值路径"></a><a href="https://leetcode.cn/problems/longest-univalue-path/">687.最长同值路径</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> leftVal = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightVal = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-type">int</span> temp_left=<span class="hljs-number">0</span>, temp_right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;val==root-&gt;val)&#123;<br>            temp_left += leftVal+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right-&gt;val==root-&gt;val)&#123;<br>            temp_right += rightVal+<span class="hljs-number">1</span>;<br>        &#125;<br>        res = <span class="hljs-built_in">max</span>(res, temp_left+temp_right);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(temp_left, temp_right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257.二叉树的所有路径</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, string s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br><br>        s +=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br><br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        <br>        s +=<span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, s);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, s);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="1080-根到叶路径上的不足节点"><a href="#1080-根到叶路径上的不足节点" class="headerlink" title="1080.根到叶路径上的不足节点"></a>1080.根到叶路径上的不足节点</h5><blockquote><p>给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）</p><p>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。</p><p>请你删除所有不足节点，并返回生成的二叉树的根。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sufficientSubset</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, limit);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> limit)</span></span>&#123;<br>        TreeNode* left=root-&gt;left;<br>        TreeNode* right=root-&gt;right;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span> &amp;&amp; right==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> root-&gt;val &gt;= limit ? root : <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        limit -= root-&gt;val;<br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">nullptr</span>)&#123;<br>            root-&gt;left=<span class="hljs-built_in">dfs</span>(left, limit);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right!=<span class="hljs-literal">nullptr</span>)&#123;<br>            root-&gt;right=<span class="hljs-built_in">dfs</span>(right, limit);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
          <category> 二叉树路径和相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的序列化与反序列化</title>
      <link href="/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/05/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二叉树的序列化与反序列化</p></blockquote><span id="more"></span><h5 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297.二叉树的序列化与反序列化"></a>297.二叉树的序列化与反序列化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先序遍历求解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//将二叉树序列化为字符串</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-built_in">helper</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//辅助函数，将二叉树存入string中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* root, string&amp; s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            s += <span class="hljs-string">&quot;#,&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            s += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>            <span class="hljs-built_in">helper</span>(root-&gt;left, s);<br>            <span class="hljs-built_in">helper</span>(root-&gt;right, s);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将字符串反序列化为二叉树</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">//将字符串转化成链表</span><br>        list&lt;string&gt; lst;<br>        <span class="hljs-comment">//借助一个字符串来控制&quot;,&quot;</span><br>        string str; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; ch : data)&#123;<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>                lst.<span class="hljs-built_in">push_back</span>(str);<br>                str.<span class="hljs-built_in">clear</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                str.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!str.<span class="hljs-built_in">empty</span>())&#123;<br>            lst.<span class="hljs-built_in">push_back</span>(str);<br>            str.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(lst);<br>    &#125;<br>    <span class="hljs-comment">//辅助函数，通过链表构造二叉树</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(list&lt;string&gt;&amp; data)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">front</span>()==<span class="hljs-string">&quot;#&quot;</span>)&#123;<br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(data.<span class="hljs-built_in">front</span>()));<br>        data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>());<br>        root-&gt;left=<span class="hljs-built_in">build</span>(data);<br>        root-&gt;right=<span class="hljs-built_in">build</span>(data);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
          <category> 二叉树的序列化与反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表中的两数相加</title>
      <link href="/2022/05/19/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2022/05/19/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                    链表中的两数相加问题</p></blockquote><span id="more"></span><h4 id="2-两数相加-I"><a href="#2-两数相加-I" class="headerlink" title="2.两数相加 I"></a>2.两数相加 I</h4><blockquote><p><img src="/images/2.png" alt="2"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p=dummy;<br>        <span class="hljs-comment">//进位值</span><br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span>(l1 || l2)&#123;<br>            <span class="hljs-comment">//短的那个链表后面用0代替其值</span><br>            <span class="hljs-type">int</span> l1_val = l1 ? l1-&gt;val : <span class="hljs-number">0</span>; <br>            <span class="hljs-type">int</span> l2_val = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-comment">//相加</span><br>            <span class="hljs-type">int</span> sum = l1_val + l2_val + carry; <br>            <span class="hljs-comment">//更新</span><br>            carry = sum/<span class="hljs-number">10</span>; <br>            sum = sum%<span class="hljs-number">10</span>; <br><br>            p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>            p = p-&gt;next;<br>            <br>            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">nullptr</span>) l1=l1-&gt;next;<br>            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">nullptr</span>) l2=l2-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//两个链表全部遍历完毕，进位值不为0，在链表后面添加一个新结点</span><br>        <span class="hljs-keyword">if</span>(carry&gt;<span class="hljs-number">0</span>)&#123;<br>            p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445.两数相加 II"></a>445.两数相加 II</h4><blockquote><p><img src="/images/445.png" alt="445"></p></blockquote><blockquote><p>第一种方法：借助栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-comment">//借助栈，逆序处理所有数位</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; st1, st2;<br>        <span class="hljs-keyword">while</span>(l1)&#123;<br>            st1.<span class="hljs-built_in">push</span>(l1-&gt;val);<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2)&#123;<br>            st2.<span class="hljs-built_in">push</span>(l2-&gt;val);<br>            l2=l2-&gt;next;<br>        &#125;<br><br>        ListNode* p=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>; <span class="hljs-comment">//进位值</span><br>        <span class="hljs-keyword">while</span>(!st1.<span class="hljs-built_in">empty</span>() || !st2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> l1_val = st1.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : st1.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> l2_val = st2.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : st2.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(!st1.<span class="hljs-built_in">empty</span>()) st1.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(!st2.<span class="hljs-built_in">empty</span>()) st2.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-type">int</span> sum=l1_val+l2_val+carry;<br><br>            carry = sum/<span class="hljs-number">10</span>;<br>            sum = sum%<span class="hljs-number">10</span>;<br><br>            <span class="hljs-comment">//反向建立单链表</span><br>            ListNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>            cur-&gt;next = p;<br>            p = cur;<br><br>        &#125;<br>        <span class="hljs-comment">//两个链表全部遍历完毕，进位值不为0，再添加一个新结点</span><br>        <span class="hljs-keyword">if</span>(carry&gt;<span class="hljs-number">0</span>)&#123;<br>            ListNode* cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>            cur-&gt;next = p;<br>            p = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>第二种方法：借助反转链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        l1 = <span class="hljs-built_in">reve</span>(l1);<br>        l2 = <span class="hljs-built_in">reve</span>(l2);<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p=dummy;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 || l2)&#123;<br>            <span class="hljs-type">int</span> val1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> val2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-type">int</span> sum = val1+val2+carry;<br>            carry = sum/<span class="hljs-number">10</span>;<br>            sum = sum%<span class="hljs-number">10</span>;<br>            <br>            p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);<br>            p=p-&gt;next;<br>            <br>            <span class="hljs-keyword">if</span>(l1)&#123;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2)&#123;<br>                l2=l2-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry&gt;<span class="hljs-number">0</span>)&#123;<br>            p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reve</span>(dummy-&gt;next);<br>    &#125;<br>    <br>    <span class="hljs-comment">//反转单链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reve</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* nxt = cur-&gt;next;<br>    <br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nxt;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415.字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415.字符串相加</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=num1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=num2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> || j&gt;=<span class="hljs-number">0</span> || carry!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> val1= i&gt;=<span class="hljs-number">0</span> ? num1[i]-<span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> val2= j&gt;=<span class="hljs-number">0</span> ? num2[j]-<span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br><br>            <span class="hljs-type">int</span> sum = val1+val2+carry;<br><br>            carry = sum/<span class="hljs-number">10</span>;<br>            sum = sum%<span class="hljs-number">10</span>;<br><br>            res.<span class="hljs-built_in">push_back</span>(sum + <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <br>            i--;<br>            j--;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
          <category> 链表中的两数相加 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU/LFU</title>
      <link href="/2022/05/19/LRU_LFU/"/>
      <url>/2022/05/19/LRU_LFU/</url>
      
        <content type="html"><![CDATA[<blockquote><p>LRU&#x2F;LFU</p></blockquote><span id="more"></span><h4 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146.LRU缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146.LRU缓存</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        cap = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">find</span>(key); <span class="hljs-comment">//返回迭代器</span><br>        <span class="hljs-comment">//如果 key 不存在则返回 -1</span><br>        <span class="hljs-keyword">if</span>(it==mp.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//提升为最近使用的，将该结点移动到链表头</span><br>        lst.<span class="hljs-built_in">splice</span>(lst.<span class="hljs-built_in">begin</span>(), lst, it-&gt;second);<br>        <span class="hljs-keyword">return</span> mp[key]-&gt;second;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(key)==mp.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">//key不存在</span><br>            <span class="hljs-keyword">if</span>(lst.<span class="hljs-built_in">size</span>()==cap)&#123;<br>                <span class="hljs-comment">//删除最久未使用的元素</span><br>                mp.<span class="hljs-built_in">erase</span>(lst.<span class="hljs-built_in">back</span>().first);<br>                lst.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//key已存在，抹去</span><br>            lst.<span class="hljs-built_in">erase</span>(mp[key]);<br>        &#125;<br>        <span class="hljs-comment">//插入&#123;key, value&#125;</span><br>        lst.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>        <span class="hljs-comment">//添加mp中 key 到 list迭代器的映射</span><br>        mp[key] = lst.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//缓存容量</span><br>    <span class="hljs-type">int</span> cap;<br>    <span class="hljs-comment">//双向链表，存储 key-value</span><br>    list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; lst;<br>    <span class="hljs-comment">//哈希表，存储 key-(key, value) 迭代器</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; mp;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> LRU/LFU </category>
          
          <category> LRU/LFU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频面试系列</title>
      <link href="/2022/05/19/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"/>
      <url>/2022/05/19/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 接雨水、旋转图像、颠倒字符串中的单词、缺失的第一个正数、螺旋矩阵、比较版本号、Pow(x, n)、数组中的逆序对</p></blockquote><span id="more"></span><h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42.接雨水</a></h4><p><strong>备忘录优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//数组充当备忘录</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l_max</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">r_max</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-comment">// base case</span><br>        l_max[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>        r_max[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>];<br><br>        <span class="hljs-comment">//从左往右计算 l_max</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            l_max[i] = <span class="hljs-built_in">max</span>(l_max[i<span class="hljs-number">-1</span>], height[i]);<br>        &#125;<br>        <span class="hljs-comment">//从右往左计算 r_max</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            r_max[i] = <span class="hljs-built_in">max</span>(r_max[i+<span class="hljs-number">1</span>], height[i]);<br>        &#125;<br><br>        <span class="hljs-comment">//计算答案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            res += <span class="hljs-built_in">min</span>(l_max[i], r_max[i])-height[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>&#125;;<br><span class="hljs-comment">//时间复杂度：O(n)</span><br><span class="hljs-comment">//空间复杂度：O(n)</span><br></code></pre></td></tr></table></figure><p><strong>双指针解法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> l_max = height[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> r_max = height[n<span class="hljs-number">-1</span>];<br><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-comment">//l_max 是 height[0...left] 中的最高的柱子高度</span><br>            l_max = <span class="hljs-built_in">max</span>(l_max, height[left]);<br>            <span class="hljs-comment">//r_max 是 height[right...n-1]中的最高的柱子高度</span><br>            r_max = <span class="hljs-built_in">max</span>(r_max, height[right]);<br><br>            <span class="hljs-comment">//res += min(l_max, r_max)-height[i];</span><br>            <span class="hljs-keyword">if</span>(l_max&lt;r_max)&#123;<br>                res += l_max-height[left];<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res += r_max-height[right];<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;   <br>&#125;;<br><span class="hljs-comment">//时间复杂度：O(n)</span><br><span class="hljs-comment">//空间复杂度：O(1)</span><br></code></pre></td></tr></table></figure><h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48.旋转图像</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：先水平翻转，再沿主对角线翻转</span><br>        <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n-i<span class="hljs-number">-1</span>][j]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="151-颠倒字符串中的单词"><a href="#151-颠倒字符串中的单词" class="headerlink" title="151.颠倒字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151.颠倒字符串中的单词</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        string res;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">//从后往前遍历s</span><br>            <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;   <span class="hljs-comment">//记录每个单词的长度  </span><br>            <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; s[i]==<span class="hljs-string">&#x27; &#x27;</span>) i--;   <span class="hljs-comment">//空格跳过</span><br>            <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;       <span class="hljs-comment">//非空格，则count++</span><br>                i--;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count) res += s.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>, count) + <span class="hljs-string">&quot; &quot;</span>;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">//目的是去掉尾随空格</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41.缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">41.缺失的第一个正数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i]&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]&lt;=n &amp;&amp; nums[nums[i]<span class="hljs-number">-1</span>]!=nums[i])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=i+<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54.螺旋矩阵</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span> || n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br><br>        <span class="hljs-comment">//定义左右上下边界的位置</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> down = m<span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <br>            <span class="hljs-comment">//从左往右走</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left;i&lt;=right;i++) res.<span class="hljs-built_in">push_back</span>(matrix[up][i]);<br>            <span class="hljs-keyword">if</span>(++up &gt; down) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//更新上边界</span><br>            <br>            <span class="hljs-comment">//从上往下走</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=up;i&lt;=down;i++) res.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            <span class="hljs-keyword">if</span>(--right&lt;left) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//更新右边界</span><br><br>            <span class="hljs-comment">//从右往左走</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=right;i&gt;=left;i--) res.<span class="hljs-built_in">push_back</span>(matrix[down][i]);<br>            <span class="hljs-keyword">if</span>(--down&lt;up) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//更新下边界</span><br><br>            <span class="hljs-comment">//从下往上走</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=down;i&gt;=up;i--) res.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            <span class="hljs-keyword">if</span>(++left&gt;right) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//更新左边界</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165.比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165.比较版本号</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=version1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=version2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;m || j&lt;n)&#123;<br>            <span class="hljs-type">long</span> num1=<span class="hljs-number">0</span>, num2=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 将一段连续的字符串转换成数字, num = num*10 是为了去前导 0</span><br>            <span class="hljs-keyword">while</span>(i&lt;m &amp;&amp; version1[i]!=<span class="hljs-string">&#x27;.&#x27;</span>) num1=num1*<span class="hljs-number">10</span> + version1[i++]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;n &amp;&amp; version2[j]!=<span class="hljs-string">&#x27;.&#x27;</span>) num2=num2*<span class="hljs-number">10</span> + version2[j++]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(num1&gt;num2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num1&lt;num2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50.Pow(x, n)"></a><a href="https://leetcode.cn/problems/powx-n/">50.Pow(x, n)</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//快速幂+递归</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> N=n;<br>        <span class="hljs-keyword">return</span> N&gt;=<span class="hljs-number">0</span> ? <span class="hljs-built_in">helper</span>(x, N) : <span class="hljs-number">1.0</span>/<span class="hljs-built_in">helper</span>(x, -N);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">long</span> N)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> y=<span class="hljs-built_in">helper</span>(x, N/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? y*y : y*y*x;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指offer51-数组中的逆序对"><a href="#剑指offer51-数组中的逆序对" class="headerlink" title="剑指offer51.数组中的逆序对"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指offer51.数组中的逆序对</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(nums, temp, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//归并排序</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(low&gt;=high) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mid=low+(high-low)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">mergeSort</span>(nums, temp, low, mid) + <span class="hljs-built_in">mergeSort</span>(nums, temp, mid+<span class="hljs-number">1</span>, high);<br><br>        <span class="hljs-type">int</span> i=low;<br>        <span class="hljs-type">int</span> j=mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<br>            temp[k]=nums[k];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<br>            <span class="hljs-keyword">if</span>(i==mid+<span class="hljs-number">1</span>)&#123;<br>                nums[k]=temp[j++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==high+<span class="hljs-number">1</span>)&#123;<br>                nums[k]=temp[i++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i]&lt;=temp[j])&#123;<br>                nums[k]=temp[i++];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                nums[k]=temp[j++];<br>                res += mid-i+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="386-字典排序"><a href="#386-字典排序" class="headerlink" title="386.字典排序"></a><a href="https://leetcode.cn/problems/lexicographical-numbers/">386.字典排序</a></h4><blockquote><p><img src="D:\Hexo\source\images\字典排序.png" alt="字典排序"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lexicalOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> number=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res[i]=number;<br>            <span class="hljs-keyword">if</span>(number*<span class="hljs-number">10</span>&lt;=n)&#123;<br>                number*=<span class="hljs-number">10</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(number%<span class="hljs-number">10</span>==<span class="hljs-number">9</span> || number+<span class="hljs-number">1</span>&gt;n)&#123;<br>                    number/=<span class="hljs-number">10</span>;<br>                &#125;<br>                number++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="440-字典序的第k小数字"><a href="#440-字典序的第k小数字" class="headerlink" title="440.字典序的第k小数字"></a><a href="https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/">440.字典序的第k小数字</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur=<span class="hljs-number">1</span>;<br>        --k; <span class="hljs-comment">//初始化为 cur=1，k需要自减1</span><br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> step=<span class="hljs-number">0</span>, first=cur, last=cur+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//统计这颗子树下所有节点数（step）</span><br>            <span class="hljs-keyword">while</span>(first&lt;=n)&#123;<br>                 <span class="hljs-comment">//不能超过n的值，并不是所有节点都有十个子节点</span><br>                step += <span class="hljs-built_in">min</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)n+<span class="hljs-number">1</span>, last)-first;  <br>                first *= <span class="hljs-number">10</span>;<br>                last *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(step&lt;=k)&#123; <span class="hljs-comment">//不在子树中</span><br>                ++cur;<br>                k -= step;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//在子树中，进入子树</span><br>                cur *= <span class="hljs-number">10</span>;<br>                --k;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a><a href="https://leetcode.cn/problems/multiply-strings/">43.字符串相乘</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num1==<span class="hljs-string">&quot;0&quot;</span> || num2==<span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br><br>        <span class="hljs-type">int</span> m=num1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=num2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m+n)</span></span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-type">int</span> x = num1[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-type">int</span> y = num2[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                res[i+j+<span class="hljs-number">1</span>] += x * y;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m+n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>            res[i<span class="hljs-number">-1</span>] += res[i]/<span class="hljs-number">10</span>;<br>            res[i] = res[i]%<span class="hljs-number">10</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//将数组res转换成字符串</span><br>        <span class="hljs-comment">//最高位为0，则索引从1开始，否则从0开始</span><br>        <span class="hljs-type">int</span> index = res[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        string s;<br>        <span class="hljs-keyword">while</span>(index &lt; m+n)&#123;<br>            s.<span class="hljs-built_in">push_back</span>(res[index]+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            index++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode.cn/problems/reverse-integer/">7. 整数反转</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)&#123;<br>            <span class="hljs-keyword">if</span>(res&gt;INT_MAX/<span class="hljs-number">10</span> || res&lt;INT_MIN/<span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            res = res*<span class="hljs-number">10</span> + x%<span class="hljs-number">10</span>;<br>            x = x/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 高频面试系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间相关问题</title>
      <link href="/2022/05/19/%E5%8C%BA%E9%97%B4%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/19/%E5%8C%BA%E9%97%B4%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1288.删除被覆盖区间、56.合并区间、986.区间列表的交集、1024.视频拼接</p></blockquote><span id="more"></span><h4 id="1288-删除被覆盖区间"><a href="#1288-删除被覆盖区间" class="headerlink" title="1288.删除被覆盖区间"></a><a href="https://leetcode.cn/problems/remove-covered-intervals/">1288.删除被覆盖区间</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeCoveredIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">//左端点</span><br>        <span class="hljs-type">int</span> r = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">//右端点</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//下一个区间覆盖上一个</span><br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>]&gt;=l &amp;&amp; intervals[i][<span class="hljs-number">1</span>]&lt;=r)&#123;<br>                res++;<br>            &#125;<br>            <span class="hljs-comment">//上一个区间覆盖下一个</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>]==l &amp;&amp; intervals[i][<span class="hljs-number">1</span>]&gt;=r)&#123;<br>                res++;<br>                l = intervals[i][<span class="hljs-number">0</span>];<br>                r = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//下一个区间和上一个区间相交或者没有交集</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                l = intervals[i][<span class="hljs-number">0</span>];<br>                r = intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n-res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56.合并区间</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-comment">//按照起点升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=intervals.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> l=intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">//左端点</span><br>        <span class="hljs-type">int</span> r=intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">//右端点</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>]&gt;r)&#123; <span class="hljs-comment">//当前区间和上一个区间没有交集</span><br>                res.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;); <br>                <span class="hljs-comment">//更新左右端点</span><br>                l=intervals[i][<span class="hljs-number">0</span>]; <br>                r=intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//当前区间和上一个区间有交集</span><br>                <span class="hljs-comment">//左端点不变，右端点更新为 max(r, intervals[i][1])</span><br>                r = <span class="hljs-built_in">max</span>(r, intervals[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后再将最后一个合并或者未合并的独立区间[l,r]加入答案数组中</span><br>        res.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//时间复杂度O(nlogn);</span><br><span class="hljs-comment">//空间复杂度O(n);</span><br></code></pre></td></tr></table></figure><h4 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986.区间列表的交集"></a><a href="https://leetcode.cn/problems/interval-list-intersections/">986.区间列表的交集</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; firstList,         vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; secondList) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> m=firstList.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=secondList.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)&#123;<br>            <span class="hljs-type">int</span> a1 = firstList[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> a2 = firstList[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> b1 = secondList[j][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b2 = secondList[j][<span class="hljs-number">1</span>];<br><br>            <span class="hljs-comment">//两个区间存在交集</span><br>            <span class="hljs-keyword">if</span>(a1&lt;=b2 &amp;&amp; a2&gt;=b1)&#123;<br>                <span class="hljs-comment">//计算交集，加入res</span><br>                res.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">max</span>(a1, b1), <span class="hljs-built_in">min</span>(a2, b2)&#125;);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(b2&lt;a2)&#123;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024.视频拼接"></a><a href="https://leetcode.cn/problems/video-stitching/">1024.视频拼接</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">Comp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>&#123;<br>            <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&gt;b[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>];<br>        &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; clips, <span class="hljs-type">int</span> time)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(time==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//按起点升序排序，起点相同的按终点降序排序；</span><br>        <span class="hljs-built_in">sort</span>(clips.<span class="hljs-built_in">begin</span>(), clips.<span class="hljs-built_in">end</span>(), Comp);<br><br>        <span class="hljs-comment">//记录选择的短视频个数</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> curEnd=<span class="hljs-number">0</span>, nextEnd=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=clips.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; clips[i][<span class="hljs-number">0</span>]&lt;=curEnd)&#123;<br>            <span class="hljs-comment">// 在第 res 个视频的区间内贪心选择下一个视频</span><br>            <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; clips[i][<span class="hljs-number">0</span>]&lt;=curEnd)&#123;<br>                nextEnd = <span class="hljs-built_in">max</span>(nextEnd, clips[i][<span class="hljs-number">1</span>]);<br>                i++;<br>            &#125;<br>            <span class="hljs-comment">//找到下一个视频，更新 curEnd</span><br>            res++;<br>            curEnd = nextEnd;<br>            <span class="hljs-keyword">if</span>(curEnd&gt;=time)&#123;<br>                <span class="hljs-comment">//已经可以拼出区间[0, time]</span><br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//无法拼出</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 贪心 </category>
          
          <category> 区间相关问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/2022/05/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2022/05/19/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 斐波拉契数列、青蛙跳台阶</p></blockquote><span id="more"></span><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><blockquote><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</p><p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>            dp[i]=dp[i]%<span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//这个问题就是斐波那契数列，动态规划</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>            dp[i]=dp[i]%<span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><blockquote><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><code>1 &lt;= n &lt;= 45</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//斐波那契数列</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最长的斐波那契子序列的长度"><a href="#最长的斐波那契子序列的长度" class="headerlink" title="最长的斐波那契子序列的长度"></a>最长的斐波那契子序列的长度</h4><blockquote><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p><p>n &gt;&#x3D; 3<br>对于所有 i + 2 &lt;&#x3D; n，都有 X_i + X_{i+1} &#x3D; X_{i+2}<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p></blockquote><blockquote><p>思路：定义状态转移方程为 f(i, j) 表示以 A[i] 结尾前一个数字是 A[j] 的斐波那契数列长度。如果存在一个数字 k，arr[i]&#x3D;arr[j]+arr[k] (0&lt;&#x3D;k&lt;j&lt;i) 成立，那么 f(i, j) &#x3D; f(j, k) + 1。若不存在这样的 k 那么 f(i, j) &#x3D; 2。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lenLongestFibSubseq</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            mp[arr[i]]=i;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-comment">// 存在 k 使得 arr[i] = arr[j] + arr[k] (0 &lt;= k &lt; j &lt; i)</span><br>                <span class="hljs-type">int</span> temp=arr[i]-arr[j];<br>                <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(temp) &amp;&amp; mp[temp]&lt;j)&#123;<br>                    dp[i][j]=dp[j][mp[temp]]+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// 不存在 k 使得 arr[i] = arr[j] + arr[k] (0 &lt;= k &lt; j &lt; i)</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j]=<span class="hljs-number">2</span>;<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res&gt;<span class="hljs-number">2</span> ? res : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 斐波拉契数列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岛屿问题</title>
      <link href="/2022/05/19/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/19/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回溯算法解决所有岛屿问题</p></blockquote><span id="more"></span><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//遍历grid</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    <span class="hljs-comment">//每发现一个岛屿，岛屿数量+1</span><br>                    res++;<br>                    <span class="hljs-comment">//然后使用dfs将岛屿淹了</span><br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//从grid[i][j]开始，将与之相邻的陆地变成海水</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=m || j&lt;<span class="hljs-number">0</span> || j&gt;=n)&#123;<br>            <span class="hljs-comment">//超出索引边界</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">//已经是海水了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//将grid[i][j]变成海水</span><br>        grid[i][j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-comment">//淹没上下左右的陆地</span><br>        <span class="hljs-built_in">dfs</span>(grid, i<span class="hljs-number">-1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i+<span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1254-统计封闭岛屿的数量"><a href="#1254-统计封闭岛屿的数量" class="headerlink" title="1254.统计封闭岛屿的数量"></a>1254.统计封闭岛屿的数量</h4><blockquote><p>二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。</p><p>请返回 封闭岛屿 的数目。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-comment">//把靠左边的岛屿淹掉</span><br>            <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">//把靠右边的岛屿淹掉</span><br>            <span class="hljs-built_in">dfs</span>(grid, i, n<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-comment">//把靠上边的岛屿淹掉</span><br>            <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-comment">//把靠下边的岛屿淹掉</span><br>            <span class="hljs-built_in">dfs</span>(grid, m<span class="hljs-number">-1</span>, j);<br>        &#125;<br>        <span class="hljs-comment">//遍历grid，剩下的岛屿都是封闭岛屿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//每发现一个岛屿，岛屿数量+1</span><br>                    res++;<br>                    <span class="hljs-comment">//然后使用dfs将岛屿淹了</span><br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//从grid[i][j]开始，将与之相邻的陆地变成海水</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//超出索引边界</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=m || j&lt;<span class="hljs-number">0</span> || j&gt;=n)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//已经是海水了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//将grid[i][j]变成海水</span><br>        grid[i][j]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//淹没上下左右的陆地</span><br>        <span class="hljs-built_in">dfs</span>(grid, i<span class="hljs-number">-1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i+<span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020.飞地的数量"></a>1020.飞地的数量</h4><blockquote><p>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。</p><p>一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。</p><p>返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//将靠边的陆地淹掉</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-built_in">dfs</span>(grid, i, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">dfs</span>(grid, i, n<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-built_in">dfs</span>(grid, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-built_in">dfs</span>(grid, m<span class="hljs-number">-1</span>, j);<br>        &#125;<br>        <span class="hljs-comment">//统计剩下的陆地数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=m || j&lt;<span class="hljs-number">0</span> || j&gt;=n)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        grid[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, i<span class="hljs-number">-1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i+<span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1905-统计子岛屿"><a href="#1905-统计子岛屿" class="headerlink" title="1905.统计子岛屿"></a>1905.统计子岛屿</h4><blockquote><p>给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。</p><p>如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。</p><p>请你返回 grid2 中 子岛屿 的 数目 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid1[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid1[i][j]==<span class="hljs-number">0</span> &amp;&amp; grid2[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">//如果在grid1中是海水，在grid2中是陆地，肯定不是子岛屿，将其淹掉</span><br>                    <span class="hljs-built_in">dfs</span>(grid2, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//grid2中剩下的岛屿都是子岛屿</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid2[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    res++;<br>                    <span class="hljs-built_in">dfs</span>(grid2, i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=m || j&lt;<span class="hljs-number">0</span> || j&gt;=n)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        grid[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(grid, i<span class="hljs-number">-1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i+<span class="hljs-number">1</span>, j);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid, i, j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h4><blockquote><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p><p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>岛屿的面积是岛上值为 1 的单元格的数目。</p><p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">//淹没岛屿，并更新最大岛屿面积</span><br>                    res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">dfs</span>(grid, i, j));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//淹没与grid[i][j]相邻的陆地，并返回淹没的陆地面积</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || i&gt;=m || j&lt;<span class="hljs-number">0</span> || j&gt;=n)&#123;<br>            <span class="hljs-comment">//超出索引边界</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//已经是海水了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//将grid[i][j]变成海水</span><br>        grid[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid, i<span class="hljs-number">-1</span>, j) + <span class="hljs-built_in">dfs</span>(grid, i+<span class="hljs-number">1</span>, j) +<br>               <span class="hljs-built_in">dfs</span>(grid, i, j<span class="hljs-number">-1</span>) + <span class="hljs-built_in">dfs</span>(grid, i, j+<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DFS </category>
          
          <category> 岛屿问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零钱兑换</title>
      <link href="/2022/05/19/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2022/05/19/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 零钱兑换 I   II</p></blockquote><span id="more"></span><h4 id="322-零钱兑换-I"><a href="#322-零钱兑换-I" class="headerlink" title="322.零钱兑换 I"></a>322.零钱兑换 I</h4><blockquote><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//动态规划，dp[i]=x，表示目标金额为i时对应的最少硬币个数为x</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>, amount+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;dp.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> coin : coins)&#123;<br>                <span class="hljs-keyword">if</span>(i-coin&gt;=<span class="hljs-number">0</span>)&#123;<br>                    dp[i]=<span class="hljs-built_in">min</span>(dp[i], dp[i-coin]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount]==amount+<span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518.零钱兑换 II"></a>518.零钱兑换 II</h4><blockquote><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p></blockquote><blockquote><p>思路：</p><p><code>dp[i][j]</code> 表示从前<code>i</code>种硬币中选，且总金额恰好为<code>j</code>的所有选法集合的方案数</p><p>按照第<code>i</code>种硬币可以选 <code>0</code>个,<code>1</code>个，<code>2</code>个，<code>3</code>个，，，，<code>k</code>个划分集合 <code>dp[i][j]</code>，其中<code>k*coins[i] &lt;= j</code></p><p>第<code>i</code> 种硬币选<code> 0</code> 个，<code>dp[i][j]=dp[i-1][j]</code></p><p>第<code>i</code> 种硬币选<code> 1</code> 个，<code>dp[i][j]=dp[i-1][j-coins[i]]</code></p><p>第<code>i</code> 种硬币选<code> k</code> 个，<code>dp[i][j]=dp[i-1][j-k*coins[i]]</code></p><p>状态计算：</p><p><code>dp[i][j] = dp[i-1][j]+dp[i-1][j-coins[i]]+dp[i-1][j-2*coins[i]]...+dp[i-1][j-k*coins[i]]</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=coins.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(amount+<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//base case</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=amount;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k*coins[i<span class="hljs-number">-1</span>]&lt;=j;k++)&#123;<br>                    dp[i][j] += dp[i<span class="hljs-number">-1</span>][j-k*coins[i<span class="hljs-number">-1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 零钱兑换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见二叉树解题集合</title>
      <link href="/2022/05/13/%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>/2022/05/13/%E5%B8%B8%E8%A7%81%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%A2%98%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二叉树思维篇：填充节点的右侧指针、二叉树展开为链表、树的子结构</p></blockquote><span id="more"></span><h4 id="116-填充节点的右侧指针"><a href="#116-填充节点的右侧指针" class="headerlink" title="116.填充节点的右侧指针"></a>116.填充节点的右侧指针</h4><blockquote><p><img src="/images/116_sample.png" alt="116_sample"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="hljs-comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node* node1, Node* node2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node1==<span class="hljs-literal">NULL</span> || node2==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//前序遍历位置</span><br>        <span class="hljs-comment">//将传入的两个节点连起来</span><br>        node1-&gt;next=node2;<br><br>        <span class="hljs-comment">//连接相同父节点的两个字节点</span><br>        <span class="hljs-built_in">traverse</span>(node1-&gt;left, node1-&gt;right);<br>        <span class="hljs-built_in">traverse</span>(node2-&gt;left, node2-&gt;right);<br>        <span class="hljs-comment">//连接跨越父节点的两个子节点</span><br>        <span class="hljs-built_in">traverse</span>(node1-&gt;right, node2-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h4><blockquote><p><img src="/images/114.png" alt="114"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//递归实现，先将root的左右子树开展成单链表，再将右子树接到左子树</span><br>        <span class="hljs-comment">//然后将整个左子树作为原树的右子树</span><br><br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> ;<br>        <br>        <span class="hljs-comment">//将左右子树拉平</span><br>        <span class="hljs-built_in">flatten</span>(root-&gt;left);<br>        <span class="hljs-built_in">flatten</span>(root-&gt;right);<br><br>        <span class="hljs-comment">/***后序遍历位置***/</span><br>        <span class="hljs-comment">//用两个临时节点来存左右子树</span><br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br><br>        <span class="hljs-comment">//将左子树接过去</span><br>        root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>        root-&gt;right = left;<br><br>        TreeNode* p = root;<br>        <span class="hljs-keyword">while</span>(p-&gt;right)&#123;<br>            p = p-&gt;right;<br>        &#125;<br>        p-&gt;right = right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="offer-I-二叉搜索树与双向链表"><a href="#offer-I-二叉搜索树与双向链表" class="headerlink" title="offer I 二叉搜索树与双向链表"></a>offer I 二叉搜索树与双向链表</h4><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p></blockquote><blockquote><p>思路：</p><p>定义两个指针pre和head，pre指针用于保存中序遍历的前一个节点，head指针用于记录排序链表的头节点。</p><p>中序遍历二叉树，遍历顺序就是双线链表的建立顺序。只需要在中序遍历的过程中，修改每个节点的左右指针，将零散的节点连接成双向循环链表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* // Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = NULL;</span><br><span class="hljs-comment">        right = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        left = _left;</span><br><span class="hljs-comment">        right = _right;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Node* pre=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//用于保存中序遍历的前一个节点</span><br>    Node* head=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//用于记录排序链表的头节点</span><br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <br>        <span class="hljs-comment">//连接首尾</span><br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//左子树</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br><br>        <span class="hljs-comment">/*中序遍历位置*/</span><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>) pre-&gt;right = root; <span class="hljs-comment">//将前驱节点的右指针指向当前根节点</span><br>        <span class="hljs-keyword">else</span> head = root; <span class="hljs-comment">//保存链表头节点</span><br>        root-&gt;left = pre; <span class="hljs-comment">//root的left指针指向其前驱</span><br>        pre = root; <span class="hljs-comment">//前驱节点右移</span><br>        <br>        <span class="hljs-comment">//右子树</span><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="offer-26-树的子结构"><a href="#offer-26-树的子结构" class="headerlink" title="offer 26.树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">offer 26.树的子结构</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-comment">//先序遍历树 A 中的每个节点 n_A ; (对应函数 isSubStructure(A, B) )</span><br>        <span class="hljs-comment">//判断树 A 中 以 n_A 为根节点的子树是否包含树 B ; (对应函数 helper(A, B) )</span><br><br>        <span class="hljs-keyword">if</span>(A==<span class="hljs-literal">NULL</span> || B==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(A, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(B==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(A==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(A-&gt;val!=B-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">helper</span>(A-&gt;right, B-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572.另一棵树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572.另一棵树的子树</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(root, subRoot) || <span class="hljs-built_in">isSubtree</span>(root-&gt;left, subRoot) <br>               || <span class="hljs-built_in">isSubtree</span>(root-&gt;right, subRoot);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* a, TreeNode* b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-literal">nullptr</span> &amp;&amp; b==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-literal">nullptr</span> || b==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(a-&gt;val!=b-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(a-&gt;left, b-&gt;left) &amp;&amp; <span class="hljs-built_in">isSame</span>(a-&gt;right, b-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236.二叉树的最近公共祖先</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">//后序遍历</span><br>        <br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(root==p || root==q) <span class="hljs-keyword">return</span> root;<br><br>        TreeNode* left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br><br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">NULL</span> &amp;&amp; right!=<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">NULL</span> &amp;&amp; right==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">return</span> left==<span class="hljs-literal">NULL</span> ? right : left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> o1, <span class="hljs-type">int</span> o2)</span> </span>&#123;<br>        <span class="hljs-comment">// 后序遍历</span><br>        <br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val==o1 || root-&gt;val==o2) <span class="hljs-keyword">return</span> root-&gt;val;<br>        <br>        <span class="hljs-type">int</span> val1 = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, o1, o2);<br>        <span class="hljs-type">int</span> val2 = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, o1, o2);<br>        <br>        <span class="hljs-keyword">if</span>(val1!=<span class="hljs-number">0</span> &amp;&amp; val2!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> root-&gt;val;<br>        <br>        <span class="hljs-keyword">if</span>(val1==<span class="hljs-number">0</span> &amp;&amp; val2==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">return</span> val1==<span class="hljs-number">0</span> ? val2 : val1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="判断是不是完全二叉树"><a href="#判断是不是完全二叉树" class="headerlink" title="判断是不是完全二叉树"></a><a href="https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=2299105&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=295">判断是不是完全二叉树</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-comment">//空树一定是完全二叉树</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">//定义一个首次出现的标记位</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//标记第一次遇到空节点</span><br>                <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//后续访问已经遇到空节点了，说明经过了叶子</span><br>                    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a><a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">//广度优先遍历</span><br><br>        <span class="hljs-comment">//空树一定是完全二叉树</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">//定义一个首次出现的标记位</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//标记第一次遇到空节点</span><br>                <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)&#123;<br>                    flag=<span class="hljs-literal">true</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//后续节点遇到空节点了，说明经过了叶子节点</span><br>                    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="判断是不是平衡二叉树"><a href="#判断是不是平衡二叉树" class="headerlink" title="判断是不是平衡二叉树"></a><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=295&tqId=23250&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=295">判断是不是平衡二叉树</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">maxDepth</span>(pRoot-&gt;left)-<span class="hljs-built_in">maxDepth</span>(pRoot-&gt;right))&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;left) &amp;&amp; <span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
          <category> 常见二叉树解题集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号</title>
      <link href="/2022/05/09/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/09/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 三道括号题目</p></blockquote><span id="more"></span><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h4><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span> || s[i]==<span class="hljs-string">&#x27;[&#x27;</span> || s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123; <span class="hljs-comment">//如果是左括号进栈</span><br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">fun</span>(s[i])==st.<span class="hljs-built_in">top</span>())&#123;<br>                    st.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//和最近的左括号不匹配</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//是否所有的左括号都被匹配了</span><br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="921-使括号有效的最少添加"><a href="#921-使括号有效的最少添加" class="headerlink" title="921.使括号有效的最少添加"></a>921.使括号有效的最少添加</h4><blockquote><p>给你输入一个字符串s，你可以在其中的任意位置插入左括号<code>(</code>或者右括号<code>)</code>，请问至少需要几次插入才能使得s变成一个合法的括号串？</p></blockquote><blockquote><p>思路：以左括号为基准，通过维护对右括号的需求数need，来计算最小的插入次数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//核心思路是以左括号为基准，通过维护对右括号的需求数need,</span><br>        <span class="hljs-comment">//来计算最小的插入次数</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-comment">//记录需要插入的最少次数</span><br>        <span class="hljs-type">int</span> need=<span class="hljs-number">0</span>;   <span class="hljs-comment">//需要多少个右括号来与左括号匹配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-comment">//对右括号的需求+1</span><br>                need++; <br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-comment">//对右括号的需求-1</span><br>                need--;<br>                <span class="hljs-keyword">if</span>(need==<span class="hljs-number">-1</span>)&#123;<br>                    need=<span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">//需要插入一个左括号</span><br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res + need;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1541-平衡括号字符串的最少插入次数"><a href="#1541-平衡括号字符串的最少插入次数" class="headerlink" title="1541.平衡括号字符串的最少插入次数"></a>1541.平衡括号字符串的最少插入次数</h4><blockquote><p>给你一个括号字符串 s ，它只包含字符 ‘(‘ 和 ‘)’ 。一个括号字符串被称为平衡的当它满足：</p><p>任何左括号 ‘(‘ 必须对应两个连续的右括号 ‘))’ 。<br>左括号 ‘(‘ 必须在对应的连续两个右括号 ‘))’ 之前。<br>比方说 “())”， “())(())))” 和 “(())())))” 都是平衡的， “)()”， “()))” 和 “(()))” 都是不平衡的。</p><p>你可以在任意位置插入字符 ‘(‘ 和 ‘)’ 使字符串平衡。</p><p>请你返回让 s 平衡的最少插入次数。</p></blockquote><blockquote><p>相比前一个，这次1个左括号需要匹配两个2个右括号</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minInsertions</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">//核心思路是以左括号为基准，通过维护对右括号的需求数need,</span><br>        <span class="hljs-comment">//来计算最小的插入次数</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-comment">//记录需要插入的最少次数</span><br>        <span class="hljs-type">int</span> need=<span class="hljs-number">0</span>;   <span class="hljs-comment">//记录右括号的需求量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                <span class="hljs-comment">//一个左括号对应两个右括号</span><br>                need += <span class="hljs-number">2</span>;<br>                <span class="hljs-comment">//当对右括号的需求量为奇数时，需要插入一个右括号</span><br>                <span class="hljs-keyword">if</span>(need%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-comment">//插入一个右括号</span><br>                    res++;<br>                    <span class="hljs-comment">//对右括号的需求量-1</span><br>                    need--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                need--;<br>                <span class="hljs-comment">//说明有括号太多了</span><br>                <span class="hljs-keyword">if</span>(need==<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-comment">//插入一个左括号</span><br>                    res++;<br>                    <span class="hljs-comment">//同时，对右括号的需求变为1</span><br>                    need=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res + need;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678.有效的括号字符串"></a>678.有效的括号字符串</h4><blockquote><p>给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><p>1、任何左括号 ( 必须有相应的右括号 )。</p><p>2、任何右括号 ) 必须有相应的左括号 ( 。</p><p>3、左括号 ( 必须在对应的右括号之前 )。</p><p>4、<code>*</code>可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</p><p>5、一个空字符串也被视为有效字符串。</p></blockquote><blockquote><p>思路：双栈，一个栈存储左括号，一个栈存储星号。从左到右遍历字符串，进行如下操作：</p><p>如果遇到左括号，将当前下标进左括号栈</p><p>如果遇到星号，将当前下标进星号栈</p><p>如果遇到右括号，优先和左括号匹配，没有左括号再和星号匹配。</p><p>遍历结束之后，两个栈可能还有元素，将星号看成右括号和左括号进行匹配，而且每个左括号必须要在与其匹配的星号之前。通过之前存入的下标进行判断即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=s.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; st1;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                st1.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                st2.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(!st1.<span class="hljs-built_in">empty</span>())&#123;<br>                    st1.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!st2.<span class="hljs-built_in">empty</span>())&#123;<br>                    st2.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!st1.<span class="hljs-built_in">empty</span>() &amp;&amp; !st2.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> index1=st1.<span class="hljs-built_in">top</span>();<br>            st1.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> index2=st2.<span class="hljs-built_in">top</span>();<br>            st2.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(index1 &gt; index2)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st1.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a></h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//思路：</span><br><span class="hljs-comment">//栈</span><br><span class="hljs-comment">//始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」</span><br><span class="hljs-comment">//对于遇到的每个‘(’ ，我们将它的下标放入栈中</span><br><span class="hljs-comment">//对于遇到的每个‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：</span><br>    <span class="hljs-comment">//如果栈为空，说明当前的右括号为没有被匹配的右括号，</span><br>    <span class="hljs-comment">//我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</span><br>    <span class="hljs-comment">//如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;   <br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123; <span class="hljs-comment">//遇到左括号</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//遇到右括号</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())&#123;  <span class="hljs-comment">//当前右括号为没有被匹配的括号</span><br>                    st.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">//更新栈底元素</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    res = <span class="hljs-built_in">max</span>(res, i-st.<span class="hljs-built_in">top</span>());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h4><blockquote><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p></blockquote><blockquote><p>有关括号问题，只要记住以下性质，思路就很容易想出来：</p><p>1、一个“合法”括号组合的左括号数量一定等于右括号数量</p><p>2、对于一个“合法”的括号字符串组合s，必然对于任何<code>0&lt;=i&lt;s.size()</code>都有：子串s[0…i]中左括号的数量都大于或等于右括号的数量。（因为是从左到右算的）</p></blockquote><blockquote><p>思路：算法输入一个整数<code>n</code>，让你计算<code>n</code>对括号能组成几种合法的括号组合，可以改写程如下问题：</p><p>现在有2n个位置，每个位置可以放置字符<code>(</code>或者<code>)</code>，组成的所有括号组合中，有多少个是合法的？</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    string temp;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//可用的左括号和右括号数量初始为 n</span><br>        <span class="hljs-built_in">dfs</span>(n, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123; <span class="hljs-comment">//可用的左括号为left个，可用的右括号为right个</span><br>        <span class="hljs-comment">//不合法，结束</span><br>        <span class="hljs-keyword">if</span>(left&lt;<span class="hljs-number">0</span> || right&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//若剩下的左括号多，不合法</span><br>        <span class="hljs-keyword">if</span>(right&lt;left) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//当所有括号都恰好用完时，得到一个合法的组合</span><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">0</span> &amp;&amp; right==<span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//尝试添加一个左括号</span><br>        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(left<span class="hljs-number">-1</span>, right);<br>        temp.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-comment">//尝试添加一个右括号</span><br>        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(left, right<span class="hljs-number">-1</span>);<br>        temp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈 </category>
          
          <category> 括号问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>煎饼排序</title>
      <link href="/2022/05/05/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/05/05/%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>煎饼排序</p></blockquote><span id="more"></span><h5 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969.煎饼排序"></a>969.煎饼排序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pancakeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">cakeSort</span>(arr, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cakeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-comment">//寻找最大煎饼的索引</span><br>        <span class="hljs-type">int</span> maxCake=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxCakeIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&gt;maxCake)&#123;<br>                maxCakeIndex=i;<br>                maxCake=arr[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//第一次翻转，将最大煎饼翻到最上面</span><br>        <span class="hljs-built_in">reverse</span>(arr, <span class="hljs-number">0</span>, maxCakeIndex);<br>        <span class="hljs-comment">//记录此次翻转</span><br>        res.<span class="hljs-built_in">push_back</span>(maxCakeIndex+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//第二次翻转，将最大煎饼翻到最下面</span><br>        <span class="hljs-built_in">reverse</span>(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//记录此次翻转</span><br>        res.<span class="hljs-built_in">push_back</span>(n);<br><br>        <span class="hljs-comment">//递归调用，翻转剩下的烧饼</span><br>        <span class="hljs-built_in">cakeSort</span>(arr, n<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">//翻转数组arr[i...j]的元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 递归 </category>
          
          <category> 煎饼排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树层序遍历</title>
      <link href="/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2022/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二叉树的层序遍历</p></blockquote><span id="more"></span><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h4><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。（即逐层地，从左到右访问所有节点）</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107.二叉树的层序遍历 II"></a>107.二叉树的层序遍历 II</h4><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：[[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],[<span class="hljs-number">3</span>]]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-comment">//转置一下</span><br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>()); <br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103.二叉树的锯齿形层序遍历"></a>103.二叉树的锯齿形层序遍历</h4><blockquote><p>按照之字形顺序</p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：[[<span class="hljs-number">3</span>],[<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            deque&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(step%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                    temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(step%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    temp.<span class="hljs-built_in">push_front</span>(cur-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>()&#125;);<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="offer-II-二叉树每层的最大值"><a href="#offer-II-二叉树每层的最大值" class="headerlink" title="offer II 二叉树每层的最大值"></a>offer II 二叉树每层的最大值</h4><blockquote><p> 给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入: root = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,null,<span class="hljs-number">9</span>]<br>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>]<br>解释:<br>          <span class="hljs-number">1</span><br>         / \<br>        <span class="hljs-number">3</span>   <span class="hljs-number">2</span><br>       / \   \  <br>      <span class="hljs-number">5</span>   <span class="hljs-number">3</span>   <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> maxVal =INT_MIN;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;val&gt;maxVal)&#123;<br>                    maxVal=cur-&gt;val;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(maxVal);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h4><blockquote><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）</p><p><img src="/images/narytreeexample.png" alt="narytreeexample"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：root = [<span class="hljs-number">1</span>,null,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,null,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[[<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;Node*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                Node* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">for</span>(Node* child : cur-&gt;children)&#123;<br>                    q.<span class="hljs-built_in">push</span>(child);<br>                &#125;<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//找到每一层最右侧的节点</span><br>                    res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
          <category> 二叉树层序遍历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口最大值</title>
      <link href="/2022/05/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2022/05/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  滑动窗口最大值</p></blockquote><span id="more"></span><h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h4><blockquote><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//优先队列中存储二元组(nums[i], i);</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; pq;<br>        <span class="hljs-comment">//初始将前k个元素放入到优先队列中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            pq.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>        &#125;<br>        <span class="hljs-comment">//存放最终结果</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res=&#123;pq.<span class="hljs-built_in">top</span>().first&#125;;<br>        <span class="hljs-comment">//开始移动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//将下一个元素加入</span><br>            pq.<span class="hljs-built_in">emplace</span>(nums[i], i);<br>            <span class="hljs-comment">//当堆顶元素为滑动窗口最左侧的值，移出堆顶元素</span><br>            <span class="hljs-keyword">while</span>(pq.<span class="hljs-built_in">top</span>().second &lt;= i-k)&#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先队列 </category>
          
          <category> 滑动窗口最大值 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>括号生成</title>
      <link href="/2022/05/01/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/2022/05/01/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 三道括号题目</p></blockquote><blockquote><p> 括号生成</p></blockquote><span id="more"></span><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h4><blockquote><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。</p></blockquote><blockquote><p>有关括号问题，只要记住以下性质，思路就很容易想出来：</p><p>1、一个“合法”括号组合的左括号数量一定等于右括号数量</p><p>2、对于一个“合法”的括号字符串组合s，必然对于任何<code>0&lt;=i&lt;s.size()</code>都有：子串s[0…i]中左括号的数量都大于或等于右括号的数量。（因为是从左到右算的）</p></blockquote><blockquote><p>思路：算法输入一个整数<code>n</code>，让你计算<code>n</code>对括号能组成几种合法的括号组合，可以改写程如下问题：</p><p>现在有2n个位置，每个位置可以放置字符<code>(</code>或者<code>)</code>，组成的所有括号组合中，有多少个是合法的？</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    string temp;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-comment">//可用的左括号和右括号数量初始为 n</span><br>        <span class="hljs-built_in">dfs</span>(n, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123; <span class="hljs-comment">//可用的左括号为left个，可用的右括号为right个</span><br>        <span class="hljs-comment">//不合法，结束</span><br>        <span class="hljs-keyword">if</span>(left&lt;<span class="hljs-number">0</span> || right&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//若剩下的左括号多，不合法</span><br>        <span class="hljs-keyword">if</span>(right&lt;left) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">//当所有括号都恰好用完时，得到一个合法的组合</span><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">0</span> &amp;&amp; right==<span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//尝试添加一个左括号</span><br>        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(left<span class="hljs-number">-1</span>, right);<br>        temp.<span class="hljs-built_in">pop_back</span>();<br><br>        <span class="hljs-comment">//尝试添加一个右括号</span><br>        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(left, right<span class="hljs-number">-1</span>);<br>        temp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DFS </category>
          
          <category> 括号生成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口算法</title>
      <link href="/2022/04/18/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/18/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>滑动窗口算法</p></blockquote><span id="more"></span><h4 id="滑动窗口算法框架"><a href="#滑动窗口算法框架" class="headerlink" title="滑动窗口算法框架"></a>滑动窗口算法框架</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//滑动窗口算法框架</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s, string t)</span></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; need, window;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t) need[c]++;<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> valid=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//c是将移入窗口的字符</span><br>        <span class="hljs-type">char</span> c=s[right];<br>        <span class="hljs-comment">//右移窗口</span><br>        right++;<br>        <span class="hljs-comment">//进行窗口内数据的一系列更新</span><br>        ...<br>        <br>        <span class="hljs-comment">//判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span>(window needs shrink)&#123;<br>            <span class="hljs-comment">//d是将移出窗口的字符</span><br>            <span class="hljs-type">char</span> d=s[left];<br>            <span class="hljs-comment">//左移窗口</span><br>            left++;<br>            <span class="hljs-comment">//进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; need, window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t) need[c]++;<br><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> valid=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//记录最小覆盖子串的起始索引和长度</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>, len=INT_MAX;<br>        <span class="hljs-keyword">while</span>(right&lt;s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-comment">//c是将要移入窗口的字符</span><br>            <span class="hljs-type">char</span> c=s[right];<br>            <span class="hljs-comment">//右移窗口</span><br>            right++;<br>            <span class="hljs-comment">//进行窗口内的一系列更新操作</span><br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>                window[c]++;<br>                <span class="hljs-keyword">if</span>(window[c]==need[c]) valid++;<br>            &#125;<br>            <span class="hljs-comment">//判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span>(valid==need.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-comment">//在这里更新最小覆盖子串</span><br>                <span class="hljs-keyword">if</span>(right-left&lt;len)&#123;<br>                    start=left;<br>                    len=right-left;<br>                &#125;<br>                <span class="hljs-comment">//d是将移出窗口的字符</span><br>                <span class="hljs-type">char</span> d=s[left];<br>                <span class="hljs-comment">//左移窗口</span><br>                left++;<br>                <span class="hljs-comment">//进行窗口内数据的一系列更新操作</span><br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>                    <span class="hljs-keyword">if</span>(window[d]==need[d]) valid--;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len==INT_MAX ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(start, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; need, window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s1) need[c]++;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> valid=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(right &lt; s2.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">char</span> c=s2[right];<br>            right++;<br>            <span class="hljs-comment">//进行窗口内数据的更新操作</span><br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>                window[c]++;<br>                <span class="hljs-keyword">if</span>(window[c]==need[c]) valid++;<br>            &#125;<br>            <span class="hljs-comment">//判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span>(right-left&gt;=s1.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-comment">//判断是否找到了合法的子串</span><br>                <span class="hljs-keyword">if</span>(valid==need.<span class="hljs-built_in">size</span>())&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-type">char</span> d=s2[left];<br>                left++;<br>                <span class="hljs-comment">//进行窗口内数据的一系列更新</span><br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>                    <span class="hljs-keyword">if</span>(window[d]==need[d])<br>                        valid--;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//未找到符合条件的子串</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; window;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录结果</span><br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">char</span> c = s[right];<br>            right++;<br>            <span class="hljs-comment">//进行窗口内数据的更新</span><br>            window[c]++;<br>            <span class="hljs-comment">//判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span>(window[c] &gt; <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//当window[c]值大于1时，说明窗口内存在重复字符，需要收缩</span><br>                <span class="hljs-type">char</span> d = s[left];<br>                left++;<br>                <span class="hljs-comment">//进行窗口内数据的更新</span><br>                window[d]--;<br>            &#125;<br>            <span class="hljs-comment">//更新答案</span><br>            res = <span class="hljs-built_in">max</span>(res, right-left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="找所有字母异位词"><a href="#找所有字母异位词" class="headerlink" title="找所有字母异位词"></a>找所有字母异位词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; need, window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : p) need[c]++;<br><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> valid=<span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res; <span class="hljs-comment">//记录结果</span><br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">char</span> c=s[right];<br>            right++;<br>            <span class="hljs-comment">//进行窗口内数据的更新</span><br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(c))&#123;<br>                window[c]++;<br>                <span class="hljs-keyword">if</span>(window[c]==need[c]) valid++;<br>            &#125;<br>            <span class="hljs-comment">//判断左侧窗口是否要收缩</span><br>            <span class="hljs-keyword">while</span>(right-left&gt;=p.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-comment">//当前窗口符合条件时，把起始索引加入到res</span><br>                <span class="hljs-keyword">if</span>(valid==need.<span class="hljs-built_in">size</span>())&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(left);<br>                &#125;<br>                <span class="hljs-type">char</span> d=s[left];<br>                left++;<br>                <span class="hljs-comment">//进行窗口内数据的更新</span><br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(d))&#123;<br>                    <span class="hljs-keyword">if</span>(window[d]==need[d]) valid--;<br>                    window[d]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//deque&lt;int&gt; window;</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=INT_MAX;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;nums.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-type">int</span> c=nums[right];<br>            right++;<br><br>            <span class="hljs-comment">//进行窗口内的更新</span><br>            <span class="hljs-comment">//window.push_back(c);</span><br>            sum += c;<br>            <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>                res = <span class="hljs-built_in">min</span>(res, right-left);<br>                <span class="hljs-type">int</span> d=nums[left];<br>                left++;<br><br>                <span class="hljs-comment">//进行窗口内的更新</span><br>                <span class="hljs-comment">//window.pop_front();</span><br>                sum -= d;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res==INT_MAX ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分糖果</title>
      <link href="/2022/03/28/%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2022/03/28/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分糖果I (easy)、分糖果 II (easy)、每个小孩最多能分到多少糖果 (medium)、分发糖果 (hard)</p></blockquote><span id="more"></span><h4 id="575-分糖果-I-easy"><a href="#575-分糖果-I-easy" class="headerlink" title="575.分糖果 I (easy)"></a>575.分糖果 I (easy)</h4><blockquote><p>Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p><p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n &#x2F; 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p><p>给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n &#x2F; 2 枚糖的情况下，可以吃到糖的 最多 种类数。</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：candyType = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br>解释：Alice 只能吃 <span class="hljs-number">6</span> / <span class="hljs-number">2</span> = <span class="hljs-number">3</span> 枚糖，由于只有 <span class="hljs-number">3</span> 种糖，她可以每种吃一枚。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distributeCandies</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candyType)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=candyType.<span class="hljs-built_in">size</span>();<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            st.<span class="hljs-built_in">insert</span>(candyType[i]);<br>        &#125;<br>        <span class="hljs-type">int</span> res=st.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(res, n/<span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1103-分糖果-II-easy"><a href="#1103-分糖果-II-easy" class="headerlink" title="1103.分糖果 II (easy)"></a>1103.分糖果 II (easy)</h4><blockquote><p>排排坐，分糖果。</p><p>我们买了一些糖果 candies，打算把它们分给排好队的 n &#x3D; num_people 个小朋友。</p><p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：candies = <span class="hljs-number">7</span>, num_people = <span class="hljs-number">4</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>解释：<br>第一次，ans[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span>，数组变为 [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]。<br>第二次，ans[<span class="hljs-number">1</span>] += <span class="hljs-number">2</span>，数组变为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]。<br>第三次，ans[<span class="hljs-number">2</span>] += <span class="hljs-number">3</span>，数组变为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>]。<br>第四次，ans[<span class="hljs-number">3</span>] += <span class="hljs-number">1</span>（因为此时只剩下 <span class="hljs-number">1</span> 颗糖果），最终数组变为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]。<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distributeCandies</span><span class="hljs-params">(<span class="hljs-type">int</span> candies, <span class="hljs-type">int</span> num_people)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(num_people)</span></span>;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000000</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(k&lt;=candies)&#123;<br>                res[i%num_people] +=k;<br>                candies -=k;<br>                k++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res[i%num_people] +=candies;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2226-每个小孩最多能分到多少糖果-medium"><a href="#2226-每个小孩最多能分到多少糖果-medium" class="headerlink" title="2226.每个小孩最多能分到多少糖果 (medium)"></a>2226.每个小孩最多能分到多少糖果 (medium)</h4><blockquote><p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。</p><p>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。</p><p>返回每个小孩可以拿走的 最大糖果数目 。</p><p>示例1：</p><p>输入：candies &#x3D; [5,8,6], k &#x3D; 3<br>输出：5<br>解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumCandies</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candies, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=candies.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxVal=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(candies[i]&gt;maxVal)&#123;<br>                maxVal=candies[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>; <br>        <span class="hljs-type">int</span> right=maxVal;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fun</span>(candies, k, mid))&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fun</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candies, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=candies.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res += candies[i]/x; <span class="hljs-comment">//注意x不能等于0；</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res&gt;=k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135.分发糖果</a></h4><blockquote><p>思路：</p><p>将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。</p><ul><li>左规则：当<code>ratings[i−1]&lt;ratings[i] </code>时，<code>i</code>号学生的糖果数量将比<code>i−1</code>号孩子的糖果数量多。</li><li>右规则：当<code>ratings[i]&gt;ratings[i+1]</code>时，<code>i</code>号学生的糖果数量将比<code>i+1</code>号孩子的糖果数量多。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-comment">// 左规则：当ratings[i−1]&lt;ratings[i] 时，i号学生的糖果数量将比i−1号孩子的糖果数量多。</span><br>        <span class="hljs-comment">// 右规则：当ratings[i]&gt;ratings[i+1] 时，i号学生的糖果数量将比i+1号孩子的糖果数量多。</span><br>        <span class="hljs-comment">//两趟遍历</span><br>        <span class="hljs-type">int</span> n=ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从左往右遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; ratings[i]&gt;ratings[i<span class="hljs-number">-1</span>])&#123;<br>                left[i]=left[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left[i]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//从右往左遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(i&lt;n<span class="hljs-number">-1</span> &amp;&amp; ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>] &amp;&amp; left[i]&lt;=left[i+<span class="hljs-number">1</span>])&#123;<br>                left[i]=left[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res += left[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分糖果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nSum问题</title>
      <link href="/2022/03/26/nSum%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/26/nSum%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                       前一篇文章对2Sum问题进行了回顾，本文由浅入深对nSum问题进行分析总结。</p></blockquote><span id="more"></span><h4 id="2Sum问题"><a href="#2Sum问题" class="headerlink" title="2Sum问题"></a>2Sum问题</h4><blockquote><p>先看一个基础的2Sum问题，一个数组nums和一个目标值，nums中可能有多对元素之和等于目标值target，请返回所有和为target的元素对，不能出现重复。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">towSumTarget</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)&#123;<br>    <span class="hljs-comment">// 先对数组进行排序</span><br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums,<span class="hljs-built_in">end</span>());<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>, right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(lfet&lt;right)&#123;<br>        <span class="hljs-type">int</span> sum=nums[left]+nums[right];<br>        <span class="hljs-comment">//记录索引left和right最初对应的值</span><br>        <span class="hljs-type">int</span> temp_left=nums[left], temp_right=nums[right];<br>        <span class="hljs-keyword">if</span>(sum&lt;target) left++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target) right++;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-built_in">push_back</span>(&#123;left,right&#125;);<br>            <span class="hljs-comment">//跳过所有重复元素</span><br>            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left]==temp_left) left++;<br>            <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right]==temp_right) right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3Sum问题"><a href="#3Sum问题" class="headerlink" title="3Sum问题"></a>3Sum问题</h4><blockquote><p>输入一个数组，判断其中是否存在三个元素a,b,c使得a+b+c&#x3D;target，如果有请返回满足所有条件且不重复的三元组。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//求和为0的三元组</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">threeSum</span>(nums, <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//求目标值为target的三数之和</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)&#123;<br>        <span class="hljs-comment">//先对整个数组进行排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//穷举三个数的第一个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//对target-nums[i]计算twoSum</span><br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; tuples=<span class="hljs-built_in">twoSum</span>(nums, i+<span class="hljs-number">1</span>, target-nums[i]);<br>            <span class="hljs-comment">//如果存在满足条件的二元组，再加上nums[i]就是最终结果三元组</span><br>            <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; tuple : tuples)&#123;<br>                tuple.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                res.<span class="hljs-built_in">push_back</span>(tuple);<br>            &#125;<br>            <span class="hljs-comment">//跳过第一个数字重复的情况，否则会出现重复结果</span><br>            <span class="hljs-keyword">while</span>(i&lt;n<span class="hljs-number">-1</span> &amp;&amp; nums[i]==nums[i+<span class="hljs-number">1</span>]) i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">twoSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> left=start, right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> sum=nums[left]+nums[right];<br>            <span class="hljs-comment">//记录索引left和right最初对应的值</span><br>            <span class="hljs-type">int</span> left_temp=nums[left], right_temp=nums[right];<br>            <span class="hljs-keyword">if</span>(sum&gt;target) right--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target) left++;<br>            <span class="hljs-keyword">else</span>&#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;left_temp, right_temp&#125;);<br>                <span class="hljs-comment">//跳过所有重复元素</span><br>                <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[left]==left_temp) left++;<br>                <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; nums[right]==right_temp) right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4Sum问题"><a href="#4Sum问题" class="headerlink" title="4Sum问题"></a>4Sum问题</h4><blockquote><p>穷举第一个数字，然后调用3Sum函数计算剩下的三个数，最后进行合并得出结果。</p></blockquote><blockquote><p>思路：</p><p>调用 <code>nSum</code> 求解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//先排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//调用nSum函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">nSum</span>(nums, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, target);<br>    &#125;<br>    <span class="hljs-comment">//求nSum通用递归解法</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">nSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)&#123;<br>        <span class="hljs-type">int</span> sz=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//至少是2Sum,且数组大小不能小于n</span><br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span> || sz&lt;n) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//base case 是2Sum</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> left=start, right=sz<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-type">int</span> sum=nums[left]+nums[right];<br>                <span class="hljs-type">int</span> l_temp=nums[left], r_temp=nums[right];<br>                <span class="hljs-keyword">if</span>(sum&lt;target) left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target) right--;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;l_temp, r_temp&#125;);<br>                    <span class="hljs-comment">//消除重复</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; l_temp==nums[left]) left++;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; r_temp==nums[right]) right--;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//当n&gt;2时，递归计算(n-1)Sum的结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;sz;i++)&#123;<br>                <span class="hljs-comment">//对target-nums[i]计算(n-1)Sum</span><br>                vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; subs=<span class="hljs-built_in">nSum</span>(nums, n<span class="hljs-number">-1</span>, i+<span class="hljs-number">1</span>, target-nums[i]);<br>                <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sub : subs)&#123;<br>                    <span class="hljs-comment">//(n-1)Sum加上nums[i]就是nSum</span><br>                    sub.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    res.<span class="hljs-built_in">push_back</span>(sub);<br>                &#125;<br>                <span class="hljs-comment">//消除重复元素</span><br>                <span class="hljs-keyword">while</span>(i&lt;sz<span class="hljs-number">-1</span> &amp;&amp; nums[i]==nums[i+<span class="hljs-number">1</span>]) i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="nSum问题"><a href="#nSum问题" class="headerlink" title="nSum问题"></a>nSum问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-number">100</span>Sum(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//调用nSum之前需要将原数组进行排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">//调用nSum函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">nSum</span>(nums, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, target);<br>    &#125;<br>    <br>    <span class="hljs-comment">//求nSum通用递归解法</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">nSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)&#123;<br>        <span class="hljs-type">int</span> sz=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">//至少是2Sum,且数组大小不能小于n</span><br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">2</span> || sz&lt;n) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">//base case 是2Sum</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-type">int</span> left=start, right=sz<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-type">int</span> sum=nums[left]+nums[right];<br>                <span class="hljs-type">int</span> l_temp=nums[left], r_temp=nums[right];<br>                <span class="hljs-keyword">if</span>(sum&lt;target) left++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target) right--;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;l_temp, r_temp&#125;);<br>                    <span class="hljs-comment">//消除重复</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; l_temp==nums[left]) left++;<br>                    <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; r_temp==nums[right]) right--;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//当n&gt;2时，递归计算(n-1)Sum的结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;sz;i++)&#123;<br>                <span class="hljs-comment">//对target-nums[i]计算(n-1)Sum</span><br>                vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; subs=<span class="hljs-built_in">nSum</span>(nums, n<span class="hljs-number">-1</span>, i+<span class="hljs-number">1</span>, target-nums[i]);<br>                <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sub : subs)&#123;<br>                    <span class="hljs-comment">//(n-1)Sum加上nums[i]就是nSum</span><br>                    sub.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    res.<span class="hljs-built_in">push_back</span>(sub);<br>                &#125;<br>                <span class="hljs-comment">//消除重复元素</span><br>                <span class="hljs-keyword">while</span>(i&lt;sz<span class="hljs-number">-1</span> &amp;&amp; nums[i]==nums[i+<span class="hljs-number">1</span>]) i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> nSum问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2Sum问题的核心思想</title>
      <link href="/2022/03/26/2Sum%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/26/2Sum%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                              本文简单回顾总结了一下2Sum系列问题的常见解法。</p></blockquote><span id="more"></span><h4 id="2Sum-I"><a href="#2Sum-I" class="headerlink" title="2Sum I"></a>2Sum I</h4><blockquote><p>描述：输入一个数组nums和一个整数target，保证数组中存在两个数的和为target，返回他们的索引。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">//暴力穷举</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]+nums[j]==target)&#123;<br>                    <span class="hljs-keyword">return</span> &#123;i,j&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//构造哈希表，进行元素和索引的相关映射</span><br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            map[nums[i]]=i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> temp=target-nums[i];<br>            <span class="hljs-comment">//如果temp存在而且不是nums[i]本身</span><br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(temp) &amp;&amp; map[temp]!=i)&#123;<br>                <span class="hljs-keyword">return</span> &#123;i,map[temp]&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2Sum-II"><a href="#2Sum-II" class="headerlink" title="2Sum II"></a>2Sum II</h4><blockquote><p>描述：给一个下标从 <strong>1</strong> 开始的整数数组 nums，该数组已按 非递减顺序排列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> sum = nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span>(sum == target) <span class="hljs-keyword">return</span> &#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//注意小标从1开始</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target) right--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &lt; target) left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> nSum问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典回溯</title>
      <link href="/2022/03/20/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF/"/>
      <url>/2022/03/20/%E7%BB%8F%E5%85%B8%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>N皇后问题、复原IP地址</p></blockquote><span id="more"></span><h4 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; res;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">//&#x27;.&#x27;表示空，&#x27;Q&#x27;表示皇后，初始化空棋盘</span><br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n,string(n,<span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>        <span class="hljs-built_in">backtrack</span>(board,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//路径：board中小于row的那些行都已经成功放置了皇后</span><br>    <span class="hljs-comment">//选择列表：第row行的所有列都是放置皇后的选择</span><br>    <span class="hljs-comment">//结束条件：row超过board的最后一行，说明棋盘放满了</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-type">int</span> row)</span></span>&#123;<br>        <span class="hljs-comment">//触发结束条件</span><br>        <span class="hljs-keyword">if</span>(row==board.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n=board[row].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>; col&lt;n;col++)&#123;<br>            <span class="hljs-comment">//排除不合法选择</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board, row, col)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 做选择</span><br>            board[row][col]=<span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-comment">//回溯 进行下一行决策</span><br>            <span class="hljs-built_in">backtrack</span>(board, row+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤销选择</span><br>            board[row][col]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//是否可以在board[row][col]放置皇后</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//检查列中是否有皇后互相冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][col]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查右上方是否有皇后互相冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row<span class="hljs-number">-1</span>,j=col+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;n;i--,j++)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检查左上方是否有皇后冲突</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=row<span class="hljs-number">-1</span>,j=col<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>;i--,j--)&#123;<br>            <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93.复原IP地址</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; res;<br>    string temp;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> cnt, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> &amp;&amp; index==s.<span class="hljs-built_in">size</span>())&#123; <span class="hljs-comment">// 片段满4段，且耗尽所有字符</span><br>            res.<span class="hljs-built_in">push_back</span>(temp.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, temp.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;   <span class="hljs-comment">// 只能存长度1~3的字符串</span><br>            <span class="hljs-keyword">if</span>(index+i&gt;s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//超出范围</span><br>            <span class="hljs-keyword">if</span>(s[index]==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; i!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//0x, 00x非法</span><br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span> &amp;&amp; s.<span class="hljs-built_in">substr</span>(index, i)&gt;<span class="hljs-string">&quot;255&quot;</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//不能大于255</span><br><br>            <span class="hljs-comment">//做选择</span><br>            temp += s.<span class="hljs-built_in">substr</span>(index, i);<br>            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(s, cnt+<span class="hljs-number">1</span>, index+i);<br>            <span class="hljs-comment">//撤销</span><br>            temp = temp.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, temp.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DFS </category>
          
          <category> 经典回溯题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造二叉树</title>
      <link href="/2022/03/16/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/03/16/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文分别介绍了通过二叉树的前序和中序遍历结果构造二叉树以及通过二叉树的中序和后序遍历结果构造二叉树。</p></blockquote><span id="more"></span><h4 id="定义二叉树结构"><a href="#定义二叉树结构" class="headerlink" title="定义二叉树结构"></a>定义二叉树结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Definition for a binary tree node.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>     <span class="hljs-type">int</span> val;<br>     TreeNode *left;<br>     TreeNode *right;<br>     <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<br>                     inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);  <br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; preorder, <span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd,</span></span><br><span class="hljs-params"><span class="hljs-function">                    vector&lt;<span class="hljs-type">int</span>&gt; inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span></span>&#123;<br>                        <span class="hljs-comment">// base case;</span><br>                        <span class="hljs-keyword">if</span>(preStart&gt;preEnd)&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//root节点对应的值就是前序遍历数组的第一个元素；</span><br>                        <span class="hljs-type">int</span> rootVal = preorder[preStart];<br>                        <span class="hljs-comment">//rootVal在中序遍历数组中的索引；</span><br>                        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=inStart;i&lt;=inEnd;i++)&#123;<br>                            <span class="hljs-keyword">if</span>(inorder[i] == rootVal)&#123;<br>                                index=i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-type">int</span> size = index-inStart;<br>                        <span class="hljs-comment">//先构造出当前根节点；</span><br>                        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>                        <span class="hljs-comment">//递归构造左右子树；</span><br>                        root-&gt;left = <span class="hljs-built_in">build</span>(preorder,preStart+<span class="hljs-number">1</span>, preStart+size,<br>                                         inorder,inStart,index<span class="hljs-number">-1</span>);<br>                        root-&gt;right = <span class="hljs-built_in">build</span>(preorder, preStart+size+<span class="hljs-number">1</span>, preEnd,<br>                                         inorder,index+<span class="hljs-number">1</span>,inEnd);<br>                        <span class="hljs-keyword">return</span> root;<br>                   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="从后序与中序遍历序列构造二叉树"><a href="#从后序与中序遍历序列构造二叉树" class="headerlink" title="从后序与中序遍历序列构造二叉树"></a>从后序与中序遍历序列构造二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<br>                     postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; inorder, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd,</span></span><br><span class="hljs-params"><span class="hljs-function">                    vector&lt;<span class="hljs-type">int</span>&gt; postorder, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd)</span></span>&#123;<br>                        <span class="hljs-comment">// base case;</span><br>                        <span class="hljs-keyword">if</span>(postStart&gt;postEnd)&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>                        &#125;<br>                        <span class="hljs-comment">//root节点对应的值就是后序遍历数组的最后一个元素；</span><br>                        <span class="hljs-type">int</span> rootVal = postorder[postEnd];<br>                        <span class="hljs-comment">//rootVal在中序遍历数组中的索引；</span><br>                        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=inStart; i&lt;=inEnd; i++)&#123;<br>                            <span class="hljs-keyword">if</span>(inorder[i]==rootVal)&#123;<br>                                index = i;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-type">int</span> size = index-inStart;<br>                        <span class="hljs-comment">//先构造出当前根节点；</span><br>                        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>                        <span class="hljs-comment">//递归构造左右子树；</span><br>                        root-&gt;left = <span class="hljs-built_in">build</span>(inorder, inStart, index<span class="hljs-number">-1</span>,<br>                                           postorder, postStart, postStart+size<span class="hljs-number">-1</span>);<br>                        root-&gt;right = <span class="hljs-built_in">build</span>(inorder, index+<span class="hljs-number">1</span>, inEnd,<br>                                            postorder, postStart+size, postEnd<span class="hljs-number">-1</span>);<br>                        <span class="hljs-keyword">return</span> root; <br>                    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
          <category> 构造二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Ceph集群</title>
      <link href="/2022/03/14/ceph/"/>
      <url>/2022/03/14/ceph/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​             本文是在基于5台vmare虚拟机，系统为centos7环境上部署安装ceph集群的整个过程。</p></blockquote><p>官方文档：<a href="https://docs.ceph.com/en/latest/install/">安装 Ceph — Ceph 文档</a></p><span id="more"></span><h6 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h6><p>5台vm，系统:centos7，至少1核1G内存每台，每台node角色的机器至少挂载1块不少于5G的空闲盘为<br>osd存储。</p><table><thead><tr><th align="left">主机名</th><th>IP</th><th>作用</th></tr></thead><tbody><tr><td align="left">admin</td><td>192.168.xxx.101</td><td>admin–安装ceph-deploy</td></tr><tr><td align="left">node1</td><td>192.168.xxx.102</td><td>mon&#x2F;mgr&#x2F;osd</td></tr><tr><td align="left">node2</td><td>192.168.xxx.103</td><td>osd</td></tr><tr><td align="left">node2</td><td>192.168.xxx.104</td><td>osd</td></tr><tr><td align="left">ceph-client</td><td>192.168.xxx.105</td><td>client</td></tr></tbody></table><ol><li>给三台node节点添加一块大小5G以上的磁盘。</li><li>IP地址中的xx需要根据自己的vmware分配的nat网段来确定</li><li>所有节点修改主机名并相互解析</li><li>关闭所有机器的防火墙和selinux</li><li>所有节点创建普通用户并设置密码–所有节点都操作</li></ol><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[root@admin ~]</span># systemct1 stop fi rewal1d<br><span class="hljs-string">[root@admin ~]</span># systemct1 disable firewalld<br><span class="hljs-string">[root@admin ~]</span># setenforce <span class="hljs-number">0</span><br><span class="hljs-string">[root@admin ~]</span># sed -i &#x27;s/enforcing/disab1ed/&#x27; /etc/selinux/config<br><span class="hljs-string">[root@admin ~]</span># useradd cephu<br><span class="hljs-string">[root@admin ~]</span># echo <span class="hljs-number">1</span> | passwd --stdin cephu<br><span class="hljs-string">[root@admin ~]</span># hostnamect1 set- hostname admin<br><span class="hljs-string">[root@admin ~]</span># cat &gt;&gt; /etc/hosts &lt;&lt;eof<br><span class="hljs-number">192.168.72.101</span> admin<br><span class="hljs-number">192.168.72.102</span> nodel<br><span class="hljs-number">192.168.72.103</span> node2<br><span class="hljs-number">192.168.72.104</span> node3<br><span class="hljs-number">192.168.72.105</span> ceph-client<br>eof<br></code></pre></td></tr></table></figure><p>  6.确保各 Ceph 节点上新创建的用户都有 sudo 权限–所有节点操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@admin ~]<span class="hljs-comment"># visudo</span><br>root ALL=(ALL) ALL<br>cephu ALL=(root) NOPASSWD:ALL<br></code></pre></td></tr></table></figure><ol start="7"><li>实现ssh无密码登录（admin节点操作）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@admin ~]<span class="hljs-comment"># su - cephu</span><br>[cephu@admin ~]$ ssh-keygen<br>[cephu@admin ~]$ ssh-copy-id cephu@ceph-client<br>[cephu@admin ~]$ ssh-copy-id cephu@node1<br>[cephu@admin ~]$ ssh-copy-id cephu@node2<br>[cephu@admin ~]$ ssh-copy-id cephu@node3<br></code></pre></td></tr></table></figure><ol start="8"><li>在admin节点用root用户添加~&#x2F;.ssh&#x2F;config配置文件，并进行如下设置，这样 ceph-deploy 就能用<br>你所建的用户名登录 Ceph 节点了</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@admin ~]<span class="hljs-comment"># mkdir ~/.ssh</span><br>[root@admin ~]<span class="hljs-comment"># vim ~/.ssh/config</span><br>Host node1<br>Hostname node1<br>User cephu<br>Host node2<br>Hostname node2<br>User cephu<br>Host node3<br>Hostname node3<br>User cephu<br></code></pre></td></tr></table></figure><p>   9.添加下载源，安装ceph-deploy（admin节点，root用户）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@admin ~]<span class="hljs-comment"># vim /etc/yum.repos.d/ceph.repo</span><br>[ceph-noarch]<br>name=Ceph noarch packages<br>baseurl=https://download.ceph.com/rpm-luminous/el7/noarch<br>enabled=1<br>gpgcheck=1<br><span class="hljs-built_in">type</span>=rpm-md<br>gpgkey=https://download.ceph.com/keys/release.asc<br>[root@admin ~]<span class="hljs-comment"># yum makecache</span><br>[root@admin ~]<span class="hljs-comment"># yum update</span><br>[root@admin ~]<span class="hljs-comment"># vim /etc/yum.conf</span><br>keepcache=1<br>[root@admin ~]<span class="hljs-comment"># yum install -y ceph-deploy</span><br></code></pre></td></tr></table></figure><ol start="10"><li>安装 ntp（所有节点）</li></ol><ul><li>选择任何一台机器当ntp时间服务器，其他的节点当时间服务器的客户端跟服务器同步时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@admin ~]<span class="hljs-comment"># yum install -y ntp</span><br>[root@admin ~]<span class="hljs-comment"># vim /etc/ntp.conf</span><br><span class="hljs-comment"># 有4行server的位置，把那4行server行注释掉，填写以下两行</span><br>server 127.127.1.0<br>fudge 127.127.1.0 stratum 10<br>[root@admin ~]<span class="hljs-comment"># systemctl start ntpd</span><br>[root@admin ~]<span class="hljs-comment"># systemctl enable ntpd</span><br><br></code></pre></td></tr></table></figure><ul><li>其他所有节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@ceph-client ~]<span class="hljs-comment"># yum install ntpdate -y</span><br>[root@ceph-client ~]<span class="hljs-comment"># ntpdate admin</span><br></code></pre></td></tr></table></figure><h6 id="部署ceph集群"><a href="#部署ceph集群" class="headerlink" title="部署ceph集群"></a>部署ceph集群</h6><p>   没有特别说明以下所有操作均是在admin节点，cephu用户下执行</p><ol><li>创建cephu操作的目录，所有ceph-deploy命令操作必须在该目录下执行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@admin ~]<span class="hljs-comment"># su - cephu</span><br>[cephu@admin ~]$ <span class="hljs-built_in">mkdir</span> my-cluster<br></code></pre></td></tr></table></figure><ol start="2"><li><p>创建集群</p><p>首先在这里需要先下载一个包并安装否则会报错</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin ~]$ wget<br>https://files.pythonhosted.org/packages/5f/ad/1fde06877a8d7d5c9b60eff7de2d452<br>f639916ae1d48f0b8f97bf97e570a/distribute-0.7.3.zip<br>[cephu@admin ~]$ unzip distribute-0.7.3.zip<br>[cephu@admin ~]$ <span class="hljs-built_in">cd</span> distribute-0.7.3<br>[cephu@admin distribute-0.7.3]$ sudo python setup.py install<br></code></pre></td></tr></table></figure><p>​        创建集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin ~]$ <span class="hljs-built_in">cd</span> my-cluster/<br>[cephu@admin my-cluster]$ ceph-deploy new node1<br>[cephu@admin my-cluster]$ <span class="hljs-built_in">ls</span><br>ceph.conf ceph-deploy-ceph.log ceph.mon.keyring<br></code></pre></td></tr></table></figure><ol start="3"><li><p>安装luminous-12.2.13在(脚本方式在admin节点)</p><p>目标：在node1,node2,node3三个节点上安装ceph和ceph-radosgw主包</p><p><strong>方法1：利用官方脚本全自动安装</strong></p><ul><li>脚本会帮助node1,node2,node3创建epel源和ceph源，且自动安装ceph和ceph-radosgw主包</li><li>这一步时间很长，容易超时，可以利用手动安装</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ceph-deploy install --release luminous node1 node2 node3<br></code></pre></td></tr></table></figure><p>​       如果ceph和ceph-radosgw安装不上，则采用方法2</p><p>​       测试是否安装完成：分别在node1 node2 node3中确认安装版本为12.2.13</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ ceph --version<br>ceph version 12.2.13 (584a20eb0237c657dc0567da126be145106aa47e) luminous<br>(stable)<br></code></pre></td></tr></table></figure><p>​       <strong>方法2：手动部署安装三台机器分别创建：三台node节点相同操作</strong></p><pre><code>  * 安装epel源</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node1 ~]<span class="hljs-comment"># yum install -y epel-release</span><br></code></pre></td></tr></table></figure><pre><code>  * 创建ceph源</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node1 ~]<span class="hljs-comment"># vim /etc/yum.repos.d/ceph.repo</span><br>[Ceph]<br>name=Ceph packages <span class="hljs-keyword">for</span> <span class="hljs-variable">$basearch</span><br>baseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/<span class="hljs-variable">$basearch</span><br>enabled=1<br>gpgcheck=0<br><span class="hljs-built_in">type</span>=rpm-md<br>gpgkey=https://mirrors.aliyun.com/ceph/keys/release.asc<br>priority=1<br>[Ceph-noarch]<br>name=Ceph noarch packages<br>baseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/noarch<br>enabled=1<br>gpgcheck=0<br><span class="hljs-built_in">type</span>=rpm-md<br>gpgkey=https://mirrors.aliyun.com/ceph/keys/release.asc<br>priority=1<br>[ceph-source]<br>name=Ceph <span class="hljs-built_in">source</span> packages<br>baseurl=http://mirrors.aliyun.com/ceph/rpm-luminous/el7/SRPMS<br>enabled=1<br>gpgcheck=0<br><span class="hljs-built_in">type</span>=rpm-md<br>gpgkey=https://mirrors.aliyun.com/ceph/keys/release.asc<br>priority=1<br>[cephu@node1 ~]$ sudo yum install ceph ceph-radosgw -y<br></code></pre></td></tr></table></figure><p>​        测试是否安装完成：分别在node1 node2 node3中确认安装版本为12.2.13</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ ceph --version<br>ceph version 12.2.13 (584a20eb0237c657dc0567da126be145106aa47e) luminous<br>(stable)<br></code></pre></td></tr></table></figure><ol start="4"><li>初始化mon：admin节点–cephu用户执行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ceph-deploy mon create-initial<br></code></pre></td></tr></table></figure><ol start="5"><li>赋予各个节点使用命令免用户名权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ceph-deploy admin node1 node2 node3<br></code></pre></td></tr></table></figure><ol start="6"><li>安装ceph-mgr：只有luminous才有，为使用dashboard做准备</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ceph-deploy mgr create node1<br></code></pre></td></tr></table></figure><ol start="7"><li>添加osd，各个节点上提供存储空间的磁盘大小不能太小，最好5G以上，注意检查你的磁盘名字</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ceph-deploy osd create --data /dev/sdb node1<br>[cephu@admin my-cluster]$ ceph-deploy osd create --data /dev/sdb node2<br>[cephu@admin my-cluster]$ ceph-deploy osd create --data /dev/sdb node3<br></code></pre></td></tr></table></figure><p>​    命令中&#x2F;dev&#x2F;sdb是在各个节点上为osd准备的空闲磁盘（无需分区格式化，如果有分区需要指定具体                  分区），通过如下命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ssh node1 lsblk -f<br></code></pre></td></tr></table></figure><p>​    最后通过如下命令查看集群状态，如果显示health_ok，3个osd up就成功了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ssh node1 sudo ceph -s<br>cluster:<br>   <span class="hljs-built_in">id</span>: 8b765619-0fe7-4826-a79e-d0d0be9c2931<br>   health: HEALTH_OK<br><br>services:<br>   mon: 1 daemons, quorum node1<br>   mgr: node1(active)<br>   osd: 3 osds: 3 up, 3 <span class="hljs-keyword">in</span><br><br>data:<br>   pools: 0 pools, 0 pgs<br>   objects: 0 objects, 0B<br>   usage: 3.01GiB used, 12.0GiB / 15.0GiB avail<br>   pgs:<br><br></code></pre></td></tr></table></figure><h6 id="Dashboard的配置"><a href="#Dashboard的配置" class="headerlink" title="Dashboard的配置"></a>Dashboard的配置</h6><p>在node1上操作，把ceph-mgr和ceph-mon安装在同一个主机上，最好只有一个ceph-mgr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node1 ~]<span class="hljs-comment"># su - cephu</span><br></code></pre></td></tr></table></figure><ol><li>创建管理域秘钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo ceph auth get-or-create mgr.node1 mon <span class="hljs-string">&#x27;allow profile</span><br><span class="hljs-string">mgr&#x27;</span> osd <span class="hljs-string">&#x27;allow *&#x27;</span> mds <span class="hljs-string">&#x27;allow *&#x27;</span><br>[mgr.node1]<br>key = AQCn735fpmEODxAAt6jGd1u956wBIDyvyYmruw==<br></code></pre></td></tr></table></figure><ol start="2"><li>开启 ceph-mgr 管理域</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo ceph-mgr -i node1<br></code></pre></td></tr></table></figure><ol start="3"><li>查看ceph的状态：确认mgr的状态为active</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo ceph status<br>cluster:<br>  <span class="hljs-built_in">id</span>: 8b765619-0fe7-4826-a79e-d0d0be9c2931<br>  health: HEALTH_OK<br><br>services:<br>  mon: 1 daemons, quorum node1<br>  mgr: node1(active, starting)<br>  osd: 3 osds: 3 up, 3 <span class="hljs-keyword">in</span><br><br>data:<br>  pools: 0 pools, 0 pgs<br>  objects: 0 objects, 0B<br>  usage: 3.01GiB used, 12.0GiB / 15.0GiB avail<br>  pgs:<br></code></pre></td></tr></table></figure><ol start="4"><li>打开dashboard模块</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo ceph mgr module <span class="hljs-built_in">enable</span> dashboard<br></code></pre></td></tr></table></figure><ol start="5"><li>绑定开启dashboard模块的ceph-mgr节点的ip地址，ip地址为mgr节点的ip地址,也就是node1的ip<br>地址</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo ceph config-key <span class="hljs-built_in">set</span> mgr/dashboard/node1/server_addr<br>192.168.72.102<br></code></pre></td></tr></table></figure><ol start="6"><li>web登录：浏览器地址栏输入 mgr地址:7000</li></ol><p><img src="/images/ceph.png" alt="ceph"></p><h6 id="配置客户端使用rbd"><a href="#配置客户端使用rbd" class="headerlink" title="配置客户端使用rbd"></a>配置客户端使用rbd</h6><p>创建块设备之前需要创建存储池，存储池相关命令需要在mon节点执行–也就是规划好的node1节点</p><ol><li>创建存储池</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo ceph osd pool create rbd 128 128<br>pool <span class="hljs-string">&#x27;rbd&#x27;</span> created<br></code></pre></td></tr></table></figure><blockquote><p>少于5个osd，pg数量为128<br>5-10个osd，pg数量为512<br>10-50个osd，pg数量为4096</p></blockquote><ol start="2"><li>初始化存储池</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@node1 ~]$ sudo rbd pool init rbd<br></code></pre></td></tr></table></figure><ol start="3"><li><p>准备客户端client：客户端操作<br> 另备一台主机，系统centos7用来作为client。主机名为client，ip：192.168.xx.105。修改hosts文件实现和admin节点的主机名互通。</p></li><li><p>为client安装ceph</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@ceph-client ~]<span class="hljs-comment"># yum -y install python-setuptools</span><br></code></pre></td></tr></table></figure><p>​      需要进行ceph集群环境内容<br>​      需要安装luminous-12.2.13的第2中方式手动安装ceph</p><ol start="5"><li>在admin节点赋予client使用命令免用户名权限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@admin my-cluster]$ ceph-deploy admin ceph-client<br></code></pre></td></tr></table></figure><ol start="6"><li>修改client下该文件的读权限</li><li>修改client下的ceph配置文件：这一步是为了解决映射镜像时出错问题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@ceph-client ~]$ sudo sh -c <span class="hljs-string">&#x27;echo &quot;rbd_default_features = 1&quot; &gt;&gt;</span><br><span class="hljs-string">/etc/ceph/ceph.conf&#x27;</span><br></code></pre></td></tr></table></figure><ol start="8"><li>client节点创建块设备镜像：单位是M，这里是4个G</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@ceph-client ~]$ rbd create foo --size 4096<br></code></pre></td></tr></table></figure><ol start="9"><li>client节点映射镜像到主机</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@ceph-client ~]$ sudo rbd map foo --name client.admin<br></code></pre></td></tr></table></figure><ol start="10"><li>client节点mount块设备</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[cephu@ceph-client ~]$ sudo mkfs.ext4 -m 0 /dev/rbd/rbd/foo<br>[cephu@ceph-client ~]$ sudo <span class="hljs-built_in">mkdir</span> /mnt/ceph-block-device<br>[cephu@ceph-client ~]$ sudo mount /dev/rbd/rbd/foo /mnt/ceph-block-device<br>[cephu@ceph-client ~]<span class="hljs-variable">$sudo</span> mount /dev/rbd/rbd/foo /mnt/ceph-block-device<br>[cephu@ceph-client ceph-block-device]$ sudo <span class="hljs-built_in">touch</span> test.txt<br></code></pre></td></tr></table></figure><p>客户端重起之后，设备需要重新做一下映射(第9步)，不然可能会卡死</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的解题套路</title>
      <link href="/2022/03/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/"/>
      <url>/2022/03/14/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                    本文主要讲解了常见的单链表处理方法</p></blockquote><span id="more"></span><h4 id="定义单链表数据结构"><a href="#定义单链表数据结构" class="headerlink" title="定义单链表数据结构"></a>定义单链表数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">// 第一种 </span><br>Definition <span class="hljs-keyword">for</span> singly-linked list.<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>      <span class="hljs-type">int</span> val;<br>      ListNode *next;<br>      <span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>      <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>      <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x, ListNode *next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>  &#125;;<br> <span class="hljs-comment">// 第二种</span><br> * Definition <span class="hljs-keyword">for</span> singly-linked list.<br> * <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     ListNode *next;<br> *     <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br> * &#125;;<br></code></pre></td></tr></table></figure><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><p>将两个升序链表合并为一个新的升序链表并返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-comment">// 虚拟头节点</span><br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode *p = dummy;<br>        ListNode *p1 = list1, *p2 = list2;<br>        <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">nullptr</span> &amp;&amp; p2 != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-comment">// 比较p1和p2两个指针</span><br>            <span class="hljs-comment">// 将值较小的节点接到p指针</span><br>            <span class="hljs-keyword">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;<br>                p-&gt;next=p2;<br>                p2=p2-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p-&gt;next=p1;<br>                p1=p1-&gt;next;<br>            &#125;<br>            <span class="hljs-comment">// p指针不断前进</span><br>            p=p-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 合并后合并后list1和list2最多只有一个还未被合并完，</span><br>        <span class="hljs-comment">// 直接将链表末尾指向未合并完的链表即可</span><br>        <span class="hljs-keyword">if</span>(p1!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p-&gt;next=p1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p2!=<span class="hljs-literal">nullptr</span>)&#123;<br>            p-&gt;next=p2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;   <br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：<em>O</em>(<em>n</em>+<em>m</em>)，其中 n和 m分别为两个链表的长度。</li><li>空间复杂度：<em>O</em>(1)。</li></ul><p>代码中⽤到⼀个链表的算法题中是很常⻅的「虚拟头结点」技巧，也就是 dummy 节点。有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p><h4 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h4><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p = dummy;<br>        <span class="hljs-comment">// 使用优先级队列</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span>&#123;  <span class="hljs-comment">// 重写仿函数</span><br>            <span class="hljs-keyword">public</span>:<br>                <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a,ListNode* b)</span></span>&#123;<br>                    <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val; <span class="hljs-comment">// 小顶堆</span><br>                    <span class="hljs-comment">// return a-&gt;val &lt; b-&gt;val; // 大顶堆</span><br>                &#125;<br>        &#125;;<br>        priority_queue &lt;ListNode*,vector&lt;ListNode*&gt;,Compare&gt; pq;<br>        <span class="hljs-comment">// 将K个链表的头结点加入优先级队列中</span><br>        <span class="hljs-keyword">for</span>(ListNode* head : lists)&#123;<br>            <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">nullptr</span>)<br>               pq.<span class="hljs-built_in">push</span>(head);<br>        &#125;<br>       <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>           ListNode* node = pq.<span class="hljs-built_in">top</span>();<br>           pq.<span class="hljs-built_in">pop</span>();<br>           p-&gt;next = node;<br>           <span class="hljs-comment">// 将链表中剩下的结点依次加入到优先级队列中</span><br>           <span class="hljs-keyword">if</span>(node-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>               pq.<span class="hljs-built_in">push</span>(node-&gt;next);<br>           &#125;<br>           p = p-&gt;next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O( n log k)，其中 k 是链表的条数，n是这些链表的节点总数。</li></ul><h4 id="返回单链表的倒数第-k-个节点"><a href="#返回单链表的倒数第-k-个节点" class="headerlink" title="返回单链表的倒数第 k 个节点"></a>返回单链表的倒数第 k 个节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针</span><br>        ListNode *fast=head;<br>        ListNode *slow=head;<br>        <span class="hljs-comment">// fast 先走 k 步</span><br>        <span class="hljs-keyword">while</span>(k--&gt;<span class="hljs-number">0</span>)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// fast 和 slow 同时走 n-k步</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)&#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O( n )。</li></ul><h4 id="删除链表的倒数第k个结点"><a href="#删除链表的倒数第k个结点" class="headerlink" title="删除链表的倒数第k个结点"></a>删除链表的倒数第k个结点</h4><p>给一个链表，删除链表的倒数第 <code>k</code>个结点，并且返回链表的头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针</span><br>        ListNode *fast=head;<br>        ListNode *slow=head;<br>        <span class="hljs-comment">// fast 先走 k 步</span><br>        <span class="hljs-keyword">while</span>(k--&gt;<span class="hljs-number">0</span>)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// fast=nullptr表示删除的就是第一个结点(头结点)</span><br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> head-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// fast 和 slow 同时走 n-k+1步</span><br>        <span class="hljs-comment">// 此处找到的是倒数第k+1个结点</span><br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            fast=fast-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// slow 指向倒数第k+1个结点，然后删除第k个结点</span><br>        slow-&gt;next=slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>时间复杂度：O( n )。</li></ul><h4 id="链表的中间结点"><a href="#链表的中间结点" class="headerlink" title="链表的中间结点"></a>链表的中间结点</h4><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>        ListNode *fast=head;<br>        ListNode *slow=head;<br>        <span class="hljs-comment">// 快指针⾛到末尾时停⽌</span><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//当链表的长度是奇数时，slow恰巧停在中点位置；如果长度是偶数，slow最终的位置是中间偏右：</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针</span><br>        ListNode *fast=head;<br>        ListNode *slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 快指针⾛两步，慢指针走一步</span><br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，说明含有环</span><br>            <span class="hljs-keyword">if</span>(slow==fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <br>          <span class="hljs-comment">// 不含环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>返回链表中环的入口结点，如果无环则返回NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-comment">// 快指针走到末尾时停止</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 快指针走两步，慢指针走一步</span><br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">NULL</span>||fast-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// fast 遇到空指针说明没有环</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-comment">// 重新指向头结点</span><br>        slow = head;<br>        <span class="hljs-comment">// 快慢指针同步前进，相交点就是环起点</span><br>        <span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>            fast=fast-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">两个链表是否相交</a></h4><blockquote><p>思路：让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相<br>当于「逻辑上」两条链表接在了⼀起，p1和p2就能达到相交结点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span><br>        ListNode *p1=headA, *p2=headB;<br>        <span class="hljs-keyword">while</span>(p1!=p2)&#123;<br>            <span class="hljs-comment">// p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表</span><br>            <span class="hljs-keyword">if</span>(p1==<span class="hljs-literal">NULL</span>)&#123;<br>                p1=headB;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p1=p1-&gt;next;<br>            &#125;<br>            <span class="hljs-comment">// p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表</span><br>            <span class="hljs-keyword">if</span>(p2==<span class="hljs-literal">NULL</span>)&#123;<br>                p2=headA;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p2=p2-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//时间复杂度：O(n)。</span><br><span class="hljs-comment">//空间复杂度：O(1)。</span><br></code></pre></td></tr></table></figure><h4 id="83-删除排序链表中的重复元素-I"><a href="#83-删除排序链表中的重复元素-I" class="headerlink" title="83.删除排序链表中的重复元素 I"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83.删除排序链表中的重复元素 I</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *p =head;<br>        <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;next-&gt;val == p-&gt;val)&#123;<br>                p-&gt;next = p-&gt;next-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p=p-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *slow=head, *fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;val != slow-&gt;val)&#123;<br>                slow-&gt;next=fast;<br>                slow=slow-&gt;next;<br>            &#125;<br>                fast=fast-&gt;next;<br>        &#125;<br>        slow-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82.删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82.删除排序链表中的重复元素 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        ListNode *p = dummy;<br><br>        <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next)&#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val)&#123;<br>                <span class="hljs-type">int</span> tmp = p-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;val==tmp)&#123;<br>                    p-&gt;next = p-&gt;next-&gt;next;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br><span class="hljs-type">int</span> val;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> *next;<br><span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) :<br><span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-comment">//递归实现反转单链表</span><br>         <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span> ||  pHead-&gt;next==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pHead; <span class="hljs-comment">//递归结束条件</span><br>         ListNode* Last = <span class="hljs-built_in">ReverseList</span>(pHead-&gt;next);<br>         pHead-&gt;next-&gt;next = pHead;<br>         pHead-&gt;next = <span class="hljs-literal">NULL</span>;<br>         <span class="hljs-keyword">return</span> Last;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-comment">//迭代实现</span><br>        ListNode* prev = <span class="hljs-literal">NULL</span>;<br>        ListNode* curr = pHead;<br>        <span class="hljs-keyword">while</span>(curr)&#123;<br>            ListNode* next = curr-&gt;next;<br>            <span class="hljs-comment">//逐个节点反转</span><br>            curr-&gt;next = prev;<br>            <span class="hljs-comment">//更新指针位置</span><br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-comment">//返回反转后的头节点</span><br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ListNode* successor = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后驱节点</span><br>    <span class="hljs-function">ListNode <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//将链表的前n个节点反转（n&lt;=链表长度），并返回反转后的链表头节点</span><br>        <span class="hljs-comment">//base case;</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//记录第n+1个节点，后面要用</span><br>            successor = head-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//以head-&gt;next为起点，需要反转前n-1个节点</span><br>        ListNode* Last = <span class="hljs-built_in">reverseN</span>(head-&gt;next,n<span class="hljs-number">-1</span>);<br>        <br>        head-&gt;next-&gt;next = head;<br>        <span class="hljs-comment">//让反转之后的head节点和后面的节点连接起来</span><br>        head-&gt;next = successor;<br>        <span class="hljs-keyword">return</span> Last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">//base case;</span><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//相当于反转前n个元素</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverseN</span>(head, n);<br>        &#125;<br>        <span class="hljs-comment">//对于head-&gt;next来说，就是反转区间[m-1, n-1];</span><br>        head-&gt;next = <span class="hljs-built_in">reverseBetween</span>(head-&gt;next, m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">//反转前N个节点</span><br>    ListNode* successor = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//后驱节点</span><br>    <span class="hljs-function">ListNode <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//将链表的前n个节点反转（n&lt;=链表长度），并返回反转后的链表头节点</span><br>        <span class="hljs-comment">//base case;</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//记录第n+1个节点，后面要用</span><br>            successor = head-&gt;next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//以head-&gt;next为起点，需要反转前n-1个节点</span><br>        ListNode* Last = <span class="hljs-built_in">reverseN</span>(head-&gt;next,n<span class="hljs-number">-1</span>);<br>        <br>        head-&gt;next-&gt;next = head;<br>        <span class="hljs-comment">//让反转之后的head节点和后面的节点连接起来</span><br>        head-&gt;next = successor;<br>        <span class="hljs-keyword">return</span> Last;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="k个一组反转链表"><a href="#k个一组反转链表" class="headerlink" title="k个一组反转链表"></a>k个一组反转链表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//递归实现</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//区间[a, b)包含k个待反转元素</span><br>        ListNode* a=head;<br>        ListNode* b=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-comment">//base case,不足k个,不需要反转</span><br>            <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>            b = b-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//反转前k个元素</span><br>        ListNode* newHead = <span class="hljs-built_in">reverse</span>(a, b);<br>        a-&gt;next = <span class="hljs-built_in">reverseKGroup</span>(b, k);<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>    <span class="hljs-comment">//反转a到b之间的节点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* a, ListNode* b)</span></span>&#123;<br>        ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>        ListNode* curr = a;<br>        <span class="hljs-keyword">while</span>(curr!=b)&#123;<br>            ListNode* next = curr-&gt;next;<br>            curr-&gt;next = prev;<br>            prev = curr;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143.重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143.重排链表</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//反转链表 + 找链表中间节点 + 交叉合并两个链表</span><br>        <br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        ListNode* mid = <span class="hljs-built_in">midNode</span>(head);<br>        ListNode* L1 = head;<br>        ListNode* L2 = mid-&gt;next;<br>        mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        L2 = <span class="hljs-built_in">reveNode</span>(L2);<br>        <br>        <span class="hljs-built_in">mergeNode</span>(L1, L2);<br><br>    &#125;<br>    <span class="hljs-comment">//反转单链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reveNode</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* nxt=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">//找链表中间节点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">midNode</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <br>    <span class="hljs-comment">//交叉合并两个链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeNode</span><span class="hljs-params">(ListNode* a, ListNode* b)</span></span>&#123;<br>        ListNode* temp_a;<br>        ListNode* temp_b;<br>        <span class="hljs-keyword">while</span>(a &amp;&amp; b)&#123;<br>            temp_a = a-&gt;next;<br>            temp_b = b-&gt;next;<br><br>            a-&gt;next = b;<br>            a = temp_a;<br><br>            b -&gt;next =a;<br>            b = temp_b;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148.排序链表</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：归并排序</span><br><br>        <span class="hljs-comment">//base case </span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-comment">//快慢指针，找到链表中间节点，从中间节点一分为二</span><br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//切链</span><br>        fast = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(fast));<br>    &#125;<br><br>    <span class="hljs-comment">//合并两个链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* a, ListNode* b)</span></span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p = dummy;<br>        <span class="hljs-keyword">while</span>(a &amp;&amp; b)&#123;<br>            <span class="hljs-keyword">if</span>(a-&gt;val &lt; b-&gt;val)&#123;<br>                p-&gt;next = a;<br>                a = a-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p-&gt;next = b;<br>                b = b-&gt;next;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(a!=<span class="hljs-literal">nullptr</span>) p-&gt;next = a;<br>        <span class="hljs-keyword">if</span>(b!=<span class="hljs-literal">nullptr</span>) p-&gt;next = b;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234.回文链表</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：找到链表的中间节点，反转链表的后半部分，和前半部分一一对比</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//找到链表中间节点</span><br>        ListNode* Mide = <span class="hljs-built_in">midListNode</span>(head);<br><br>        <span class="hljs-comment">//反转后半部分</span><br>        ListNode* temp = <span class="hljs-built_in">reveListNode</span>(Mide);<br><br>        ListNode* p=head;<br>        ListNode* q=temp;<br>        <span class="hljs-keyword">while</span>(q)&#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;val != q-&gt;val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reveListNode</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode* nxt = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>    <span class="hljs-comment">//寻找链表中间节点</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">midListNode</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
          <category> 常见单链表的解题套路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2022/03/14/Docker/"/>
      <url>/2022/03/14/Docker/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker 是一个开源的应用容器引擎，基于 Go 语言实现，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上。</p></blockquote><span id="more"></span><h4 id="Centos7-安装-Docker"><a href="#Centos7-安装-Docker" class="headerlink" title="Centos7 安装 Docker"></a>Centos7 安装 Docker</h4><p>安装一些必要的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure><p>添加软件源信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><p>更新并安装Docker-CE</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum -y install docker-ce<br></code></pre></td></tr></table></figure><p>开启Docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service docker start<br></code></pre></td></tr></table></figure><p>验证Docker服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker --version<br>Docker version 18.03.1-ce, build 9ee9f40<br></code></pre></td></tr></table></figure><h4 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h4><p><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p><p><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</p><h4 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h4><h5 id="Docker-进程相关命令"><a href="#Docker-进程相关命令" class="headerlink" title="Docker 进程相关命令"></a>Docker 进程相关命令</h5><p>启动 docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure><p>停止 docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop docker<br></code></pre></td></tr></table></figure><p>重启 docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><p>查看 docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status docker<br></code></pre></td></tr></table></figure><p>设置开机启动 docker 服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable docker<br></code></pre></td></tr></table></figure><h5 id="Docker-镜像相关命令"><a href="#Docker-镜像相关命令" class="headerlink" title="Docker 镜像相关命令"></a>Docker 镜像相关命令</h5><p>查看镜像：查看本地所有的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br>docker images –q # 查看所用镜像的id<br></code></pre></td></tr></table></figure><p>搜素镜像：从网络中查找需要的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search 镜像名称<br></code></pre></td></tr></table></figure><p>拉取镜像：从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 镜像名称<br></code></pre></td></tr></table></figure><p>删除镜像：删除本地镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi 镜像id # 删除指定本地镜像<br>docker rmi `docker images -q` # 删除所有本地镜像<br></code></pre></td></tr></table></figure><h5 id="Docker-容器相关命令"><a href="#Docker-容器相关命令" class="headerlink" title="Docker 容器相关命令"></a>Docker 容器相关命令</h5><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps # 查看正在运行的容器<br>docker ps –a # 查看所有容器<br></code></pre></td></tr></table></figure><p>创建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run 参数<br></code></pre></td></tr></table></figure><blockquote><p>参数说明：<br>• -i： 保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器          后，容器自动关闭。<br>• -t： 为容器重新分配一个伪输入终端，通常与 -i 同时使用。<br>• -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出          后，容器不会关闭。<br>• -it    创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器<br>• –name：为创建的容器命名。</p></blockquote><p>进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec 参数 # 退出容器，容器不会关闭<br></code></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器名称<br></code></pre></td></tr></table></figure><p>停止容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器名称<br></code></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器名称<br></code></pre></td></tr></table></figure><p>查看容器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器名称<br></code></pre></td></tr></table></figure><h4 id="Docker-容器的数据卷"><a href="#Docker-容器的数据卷" class="headerlink" title="Docker 容器的数据卷"></a>Docker 容器的数据卷</h4><h5 id="数据卷概念及作用"><a href="#数据卷概念及作用" class="headerlink" title="数据卷概念及作用"></a>数据卷概念及作用</h5><p>思考：</p><blockquote><p>Docker 容器删除后，在容器中产生的数据还在吗？</p><p>Docker 容器和外部机器可以直接交换文件吗？</p><p>Docker 容器之间想要进行数据交互？</p></blockquote><p>数据卷概念：</p><ul><li>数据卷是宿主机中的一个目录或文件</li><li>当容器目录和数据卷目录绑定后，对方的修改会立即同步</li><li>一个数据卷可以被多个容器同时挂载</li><li>一个容器也可以被挂载多个数据卷</li></ul><p>数据卷作用：</p><ul><li>容器数据持久化</li><li>外部机器和容器间接通信</li><li>容器之间数据交换</li></ul><h5 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h5><p>创建启动容器时，使用 -v 参数 设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run ... –v 宿主机目录(文件):容器内目录(文件) ... <br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li>目录必须是绝对路径</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷</li></ul><h5 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h5><p>数据卷容器：多容器进行数据交换，多个容器挂载同一个数据卷</p><p>配置数据卷容器：</p><p>1.创建启动c3数据卷容器，使用 –v 参数 设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run –it --name=c3 –v /volume centos:7 /bin/bash<br></code></pre></td></tr></table></figure><p>2.创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash<br>docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash<br></code></pre></td></tr></table></figure><h5 id="数据卷小结"><a href="#数据卷小结" class="headerlink" title="数据卷小结"></a>数据卷小结</h5><ul><li>数据卷概念<br>宿主机的一个目录或文件</li><li>数据卷作用<br>1.容器数据持久化<br>2.客户端和容器数据交换<br>3.容器间数据交换</li><li>数据卷容器<br>1.创建一个容器，挂载一个目录，让其他容器继承自该容器( –volume-from )。<br>2.通过简单方式实现数据卷配置</li></ul><h4 id="Docker-应用部署"><a href="#Docker-应用部署" class="headerlink" title="Docker 应用部署"></a>Docker 应用部署</h4><h5 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署"></a>MySQL 部署</h5><p>案例需求：在Docker容器中部署MySQL，并通过外部mysql客户端操作MySQL Server</p><p>实现步骤：</p><p>① 搜索mysql镜像<br>② 拉取mysql镜像<br>③ 创建容器<br>④ 操作容器中的mysql</p><h5 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h5><p>案例需求：在Docker容器中部署Nginx，并通过外部机器访问Nginx</p><p>实现步骤：</p><p>① 搜索Nginx镜像<br>② 拉取Nginx镜像<br>③ 创建容器<br>④ 测试访问</p><h5 id="Redis-部署"><a href="#Redis-部署" class="headerlink" title="Redis 部署"></a>Redis 部署</h5><p>案例需求：在Docker容器中部署Redis，并通过外部机器访问Redis</p><p>实现步骤：</p><p>① 搜索Redis镜像<br>② 拉取Redis镜像<br>③ 创建容器<br>④ 测试访问</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><h5 id="Docker-镜像原理"><a href="#Docker-镜像原理" class="headerlink" title="Docker 镜像原理"></a>Docker 镜像原理</h5><p>思考：</p><blockquote><p>• Docker 镜像本质是什么？<br>• Docker 中一个centos镜像为什么只有200MB，而一个<br>   centos操作系统的iso文件要几个个G？<br>• Docker 中一个tomcat镜像为什么有500MB，而一个<br>   tomcat安装包只有70多MB？</p></blockquote><p>操作系统组成部分：</p><p>• 进程调度子系统<br>• 进程通信子系统<br>• 内存管理子系统<br>• 设备管理子系统<br>• <strong>文件管理子系统</strong><br>• 网络通信子系统<br>• 作业控制子系统</p><p>Linux文件系统由bootfs和rootfs两部分组成</p><ul><li>bootfs：包含bootloader（引导加载程序）和 kernel（内核）</li><li>rootfs： <strong>root文件系统</strong>，包含的就是典型 Linux 系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc 等标准目录和文件</li><li>不同的Linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等</li><li>Docker镜像是由特殊的文件系统叠加而成</li><li>最底端是 bootfs，并使用宿主机的bootf</li><li>第二层是 root文件系统rootfs,称为base image</li><li>然后再往上可以叠加其他的镜像文件</li><li>统一文件系统（Union File System）技术能够将不同的<br>层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</li><li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。</li><li>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><blockquote><p>Docker 镜像本质是什么？<br>    • 是一个分层文件系统</p><p>Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？<br>    • Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有           rootfs和其他镜像层</p><p>Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？<br>    • 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有    整个对外暴露的tomcat镜像大小500多MB</p></blockquote><p>镜像制作：</p><p>1、容器转为镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit 容器id 镜像名称:版本号<br>docker save -o 压缩文件名称 镜像名称:版本号<br>docker load –i 压缩文件名称<br></code></pre></td></tr></table></figure><p>2、dockerfile</p><h5 id="Dockerfile-概念及作用"><a href="#Dockerfile-概念及作用" class="headerlink" title="Dockerfile 概念及作用"></a>Dockerfile 概念及作用</h5><ul><li>Dockerfile 是一个文本文件</li><li>包含了一条条的指令</li><li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件<br>构建一个新的镜像开始工作了</li><li>对于运维人员：在部署时，可以实现应用的无缝移植</li></ul><p>Dochub网址：<a href="https://hub.docker.com/">https://hub.docker.com</a></p><h5 id="Dockerfile-关键字"><a href="#Dockerfile-关键字" class="headerlink" title="Dockerfile 关键字"></a>Dockerfile 关键字</h5><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是&#x2F;bin&#x2F;sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name&#x3D;value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080&#x2F;udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F; 使用的是绝对地址 如果不是&#x2F;开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h5 id="Dockerfile-案例"><a href="#Dockerfile-案例" class="headerlink" title="Dockerfile 案例"></a>Dockerfile 案例</h5><p>案例1需求：</p><p>自定义centos7镜像。要求：</p><ol><li>默认登录路径为 &#x2F;usr</li><li>可以使用vim</li></ol><p>实现步骤：</p><p>① 定义父镜像：FROM centos:7<br>② 定义作者信息：MAINTAINER itheima<br>③ 执行安装vim命令： RUN yum install -y vim<br>④ 定义默认的工作目录：WORKDIR &#x2F;usr<br>⑤ 定义容器启动执行的命令：CMD &#x2F;bin&#x2F;bash<br>⑥ 通过 dockerfile 构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</p><h4 id="Docker-服务编排"><a href="#Docker-服务编排" class="headerlink" title="Docker 服务编排"></a>Docker 服务编排</h4><h5 id="服务编排概念"><a href="#服务编排概念" class="headerlink" title="服务编排概念"></a>服务编排概念</h5><p>微服务架构应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启动停止，维护的工作量会很大。<br>• 要从Dockerfile build image 或者去dockerhub拉取image<br>• 要创建多个container<br>• 要管理这些container（启动停止删除）</p><p><strong>服务编排</strong>：按照一定的业务规则批量管理容器</p><h5 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h5><p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</p><ol><li>利用 Dockerfile 定义运行环境镜像</li><li>使用 docker-compose.yml 定义组成应用的各服务</li><li>运行 docker-compose up 启动应用</li></ol><p>安装Docker Compose</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我们以编译好的二进制包方式安装在Linux系统中。</span> <br>curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<br><span class="hljs-meta"># </span><span class="language-bash">设置文件可执行权限</span> <br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta"># </span><span class="language-bash">查看版本信息</span> <br>docker-compose -version<br></code></pre></td></tr></table></figure><p>卸载Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span><br>rm /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>使用docker compose编排nginx+springboot项目</p><p>1、创建docker-compose目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/docker-compose<br>cd ~/docker-compose<br></code></pre></td></tr></table></figure><p>2、编写 docker-compose.yml 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  nginx:<br>   image: nginx<br>   ports:<br>    - 80:80<br>   links:<br>    - app<br>   volumes:<br>    - ./nginx/conf.d:/etc/nginx/conf.d<br>  app:<br>    image: app<br>    expose:<br>      - &quot;8080&quot;<br></code></pre></td></tr></table></figure><p>3、创建.&#x2F;nginx&#x2F;conf.d目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ./nginx/conf.d<br></code></pre></td></tr></table></figure><p>4、在.&#x2F;nginx&#x2F;conf.d目录下 编写itheima.conf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen 80;<br>    access_log off;<br><br>    location / &#123;<br>        proxy_pass http://app:8080;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、在~&#x2F;docker-compose 目录下 使用docker-compose 启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure><p>6、测试访问  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://192.168.149.135/hello<br></code></pre></td></tr></table></figure><h4 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a>Docker私有仓库</h4><p>Docker官方的<a href="https://hub.docker.com/">Docker hub</a></p><p>是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</p><h5 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">1、拉取私有仓库镜像</span> <br>docker pull registry<br><span class="hljs-meta"># </span><span class="language-bash">2、启动私有仓库容器</span> <br>docker run -id --name=registry -p 5000:5000 registry<br><span class="hljs-meta"># </span><span class="language-bash">3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="hljs-string">&quot;repositories&quot;</span>:[]&#125; 表示私  <span class="hljs-comment">#有仓库 搭建成功</span></span><br><span class="hljs-meta"># </span><span class="language-bash">4、修改daemon.json</span>   <br>vim /etc/docker/daemon.json    <br><span class="hljs-meta"># </span><span class="language-bash">在上述文件中添加一个key，保存退出。此步用于让docker信任私有仓库地址；注意将私有仓库服务器ip修改为自</span>  <br><span class="hljs-meta"># </span><span class="language-bash">己私有仓库服务器真实ip</span> <br>&#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; <br><span class="hljs-meta"># </span><span class="language-bash">5、重启docker 服务</span> <br>systemctl restart docker<br>docker start registry<br></code></pre></td></tr></table></figure><h5 id="上传镜像到私有仓库"><a href="#上传镜像到私有仓库" class="headerlink" title="上传镜像到私有仓库"></a>上传镜像到私有仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">1、标记镜像为私有仓库的镜像</span>     <br>docker tag centos:7 私有仓库服务器IP:5000/centos:7 <br><span class="hljs-meta"># </span><span class="language-bash">2、上传标记的镜像</span>     <br>docker push 私有仓库服务器IP:5000/centos:7<br></code></pre></td></tr></table></figure><h5 id="从私有仓库拉取镜像"><a href="#从私有仓库拉取镜像" class="headerlink" title="从私有仓库拉取镜像"></a>从私有仓库拉取镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="language-bash">拉取镜像</span> <br>docker pull 私有仓库服务器ip:5000/centos:7<br></code></pre></td></tr></table></figure><h4 id="Docker相关概念"><a href="#Docker相关概念" class="headerlink" title="Docker相关概念"></a>Docker相关概念</h4><h5 id="docker容器虚拟化与传统虚拟机比较"><a href="#docker容器虚拟化与传统虚拟机比较" class="headerlink" title="docker容器虚拟化与传统虚拟机比较"></a>docker容器虚拟化与传统虚拟机比较</h5><p>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</p><ul><li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、<br>系统库和设置。</li><li>容器化软件在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li></ul><p>相同：</p><ul><li>容器和虚拟机具有相似的资源隔离和分配优势</li></ul><p>不同：</p><ul><li>容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。</li><li>传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统</li></ul><table><thead><tr><th align="center">特性</th><th align="center">容器</th><th align="center">虚拟机</th></tr></thead><tbody><tr><td align="center">启动</td><td align="center">秒级</td><td align="center">分钟级</td></tr><tr><td align="center">磁盘使用</td><td align="center">一般为MB</td><td align="center">一般为GB</td></tr><tr><td align="center">性能</td><td align="center">接近原生</td><td align="center">弱于</td></tr><tr><td align="center">系统支持量</td><td align="center">单机支持上千个容器</td><td align="center">一般几十个</td></tr></tbody></table><h4 id="Docker常见面试题及答案"><a href="#Docker常见面试题及答案" class="headerlink" title="Docker常见面试题及答案"></a>Docker常见面试题及答案</h4><h5 id="1、什么是-Docker-？"><a href="#1、什么是-Docker-？" class="headerlink" title="1、什么是 Docker ？"></a>1、什么是 Docker ？</h5><p>Docker 是一个容器化平台，它以容器的形式将应用程序及其所有依赖项打包在一起，以确保应用程序在任何环境中无缝运行</p><h5 id="2、什么是-Dockerfile-？"><a href="#2、什么是-Dockerfile-？" class="headerlink" title="2、什么是 Dockerfile ？"></a>2、什么是 Dockerfile ？</h5><p>Dockerfile 是一个文本文件，其中包含我们需要运行以构建 Docker 映像的所有命令。Docker 使用 Dockerfile 中的指令自动构建镜像。</p><h5 id="3、什么是-Docker-镜像？"><a href="#3、什么是-Docker-镜像？" class="headerlink" title="3、什么是 Docker 镜像？"></a>3、什么是 Docker 镜像？</h5><p>Docker 镜像是 Docker 容器的源代码，Docker 镜像用于创建容器</p><h5 id="4、什么是-Docker容器？"><a href="#4、什么是-Docker容器？" class="headerlink" title="4、什么是 Docker容器？"></a>4、什么是 Docker容器？</h5><p>Docker 容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行</p><h5 id="5、Docker-容器有几种状态？"><a href="#5、Docker-容器有几种状态？" class="headerlink" title="5、Docker 容器有几种状态？"></a>5、Docker 容器有几种状态？</h5><p>四种状态：运行、已暂停、重新启动、已退出</p><h5 id="6、Dockerfile-中最常见的指令是什么？"><a href="#6、Dockerfile-中最常见的指令是什么？" class="headerlink" title="6、Dockerfile 中最常见的指令是什么？"></a>6、Dockerfile 中最常见的指令是什么？</h5><p>FROM：指定基础镜像<br>LABEL：为镜像指定标签<br>RUN：运行指定的命令<br>CMD：容器启动时要运行的命令</p><h5 id="7、Dockerfile-中的命令-COPY-和-ADD-命令有什么区别？"><a href="#7、Dockerfile-中的命令-COPY-和-ADD-命令有什么区别？" class="headerlink" title="7、Dockerfile 中的命令 COPY 和 ADD 命令有什么区别？"></a>7、Dockerfile 中的命令 COPY 和 ADD 命令有什么区别？</h5><p>COPY与ADD的区别COPY的SRC只能是本地文件，其他用法一致</p><h5 id="8、docker-常用命令"><a href="#8、docker-常用命令" class="headerlink" title="8、docker 常用命令"></a>8、docker 常用命令</h5><p>docker pull 拉取或者更新指定镜像<br>docker push 将镜像推送至远程仓库<br>docker rm 删除容器<br>docker rmi 删除镜像<br>docker images 列出所有镜像<br>docker ps 列出所有容器</p><h5 id="9、Docker-架构组成"><a href="#9、Docker-架构组成" class="headerlink" title="9、Docker 架构组成"></a>9、Docker 架构组成</h5><p>三个架构组件包括 Docker 客户端、主机和注册表</p><p><strong>Docker 客户端</strong>：该组件执行构建和运行操作以与 Docker 主机通信。</p><p><strong>Docker 主机</strong>：该组件包含 Docker 守护程序、Docker 镜像和 Docker 容器。守护进程建立到 Docker Registry 的连接。</p><p><strong>Docker Registry</strong>：该组件存储 Docker 镜像。它可以是公共注册表，例如 Docker Hub 或 Docker Cloud，也可以是私有注册表。</p><h5 id="10、容器与主机之间的数据拷贝命令"><a href="#10、容器与主机之间的数据拷贝命令" class="headerlink" title="10、容器与主机之间的数据拷贝命令"></a>10、容器与主机之间的数据拷贝命令</h5><p>docker cp 命令用于容器与主机之间的数据拷贝<br>主机到容器：<br>docker cp  &#x2F;www 96f7f14e99ab:&#x2F;www&#x2F;<br>容器到主机：<br>docker cp  96f7f14e99ab:&#x2F;www &#x2F;tmp&#x2F;</p><h5 id="11、什么是-Docker-Swarm-？"><a href="#11、什么是-Docker-Swarm-？" class="headerlink" title="11、什么是 Docker Swarm ？"></a>11、什么是 Docker Swarm ？</h5><p>Docker Swarm 是一个容器编排工具，它允许我们跨不同主机管理多个容器。使用 Swarm，我们可以将多个 Docker 主机变成单个主机，以便于监控和管理</p><h5 id="12、虚拟化和容器化有什么区别？"><a href="#12、虚拟化和容器化有什么区别？" class="headerlink" title="12、虚拟化和容器化有什么区别？"></a>12、虚拟化和容器化有什么区别？</h5><p><strong>虚拟化</strong>：</p><p>虚拟化帮助我们在单个物理服务器上运行和托管多个操作系统。在虚拟化中，管理程序为客户操作系统提供了一个虚拟机。VM 形成了硬件层的抽象，因此主机上的每个 VM 都可以充当物理机</p><p><strong>容器化</strong>：</p><p>容器化为我们提供了一个独立的环境来运行我们的应用程序。我们可以在单个服务器或 VM 上使用相同的操作系统部署多个应用程序。容器构成了应用层的抽象，所以每个容器代表一个不同的应用</p><h5 id="13、什么是-Docker-引擎？"><a href="#13、什么是-Docker-引擎？" class="headerlink" title="13、什么是 Docker 引擎？"></a>13、什么是 Docker 引擎？</h5><p>Docker Engine 是一种开源容器化技术，我们可以使用它来构建和容器化我们的应用程序。Docker Engine 由以下组件支持：</p><ul><li>Docker 引擎 REST API</li></ul><ul><li>Docker 命令行界面 (CLI)</li><li>Docker 守护进程</li></ul><h5 id="14、如何访问正在运行的容器？"><a href="#14、如何访问正在运行的容器？" class="headerlink" title="14、如何访问正在运行的容器？"></a>14、如何访问正在运行的容器？</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">要访问正在运行的容器，我们可以使用以下命令：</span><br><span class="hljs-meta">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it &lt;container_id&gt; bash</span><br></code></pre></td></tr></table></figure><h5 id="15、描述-Docker-容器的生命周期"><a href="#15、描述-Docker-容器的生命周期" class="headerlink" title="15、描述 Docker 容器的生命周期"></a>15、描述 Docker 容器的生命周期</h5><p>Docker 容器经历以下阶段：</p><blockquote><ul><li>创建容器</li><li>运行容器</li><li>暂停容器（可选）</li><li>取消暂停容器（可选）</li><li>启动容器</li><li>停止容器</li><li>重启容器</li><li>杀死容器</li><li>销毁容器</li></ul></blockquote><h5 id="16、什么是-Docker-对象标签？"><a href="#16、什么是-Docker-对象标签？" class="headerlink" title="16、什么是 Docker 对象标签？"></a>16、什么是 Docker 对象标签？</h5><p>Docker 对象标签是存储为字符串的键值对。它们使我们能够将元数据添加到 Docker 对象，例如容器、网络、本地守护进程、图像、Swarm 节点和服务</p><h5 id="16、如何在生产中监控-Docker-？"><a href="#16、如何在生产中监控-Docker-？" class="headerlink" title="16、如何在生产中监控 Docker ？"></a>16、如何在生产中监控 Docker ？</h5><p>Docker 提供 docker stats 和 docker 事件等工具来监控生产中的 Docker。我们可以使用这些命令获取重要统计数据的报告。</p><p>Docker 统计数据：当我们使用容器 ID 调用 docker stats 时，我们获得容器的CPU，内存使用情况等。它类似于Linux中的top命令。</p><p>Docker事件：Docker 事件是一个命令，用于查看 Docker 守护程序中正在进行的活动流。<br>一些常见的Docker事件是：attach，commit，die，detach，rename，destroy 等。我们还可以使用各种选项来限制或过滤我们感兴趣的事件</p><h5 id="17、一些重要的-Docker-命令"><a href="#17、一些重要的-Docker-命令" class="headerlink" title="17、一些重要的 Docker 命令"></a>17、一些重要的 Docker 命令</h5><ul><li>build：为Docker构建一个镜像文件</li><li>create：用于创建新容器</li><li>kill：杀死一个容器</li><li>dockerd：用于启动 Docker 守护进程</li><li>commit：用于从容器更改创建新镜像</li></ul><h5 id="18、Docker-中的命名空间是什么？"><a href="#18、Docker-中的命名空间是什么？" class="headerlink" title="18、Docker 中的命名空间是什么？"></a>18、Docker 中的命名空间是什么？</h5><p>Docker Namespaces 是一种提供隔离工作区的技术，称为容器。一旦容器启动，就会为所述容器创建一组命名空间。这些命名空间为这些容器提供了一层隔离，因为每个容器在不同的命名空间中运行，其访问仅限于提到的命名空间。</p><h5 id="19、Docker-中的-compose-文件可以使用-JSON-代替-YAML-吗？"><a href="#19、Docker-中的-compose-文件可以使用-JSON-代替-YAML-吗？" class="headerlink" title="19、Docker 中的 compose 文件可以使用 JSON 代替 YAML 吗？"></a>19、Docker 中的 compose 文件可以使用 JSON 代替 YAML 吗？</h5><p>可以，Docker 撰写文件可以使用 JSON 代替 YAML。要使用 JSON 文件进行组合，文件名应指定如下：</p><p>“docker-compose -f docker-compose.json up。”</p><h5 id="20、什么是虚拟化？"><a href="#20、什么是虚拟化？" class="headerlink" title="20、什么是虚拟化？"></a>20、什么是虚拟化？</h5><p>在早期，虚拟化被称为一种逻辑划分大型机以允许多个应用程序同时运行的方法。但是随着时间的推移，行业能够允许在一个基于 x86 的系统上同时运行多个操作系统，虚拟化的含义发生了很大的变化。虚拟化允许用户在同一硬件上运行两个不同的操作系统。虽然主要操作系统是管理员，但每个客户操作系统都会经历诸如引导、加载内核等过程。它也非常适合安全性，因为可能不允许每个来宾操作系统完全访问主机操作系统，从而导致数据泄露。</p><p>主要有三种类型的虚拟化：</p><ul><li>半虚拟化</li><li>仿真</li><li>基于容器的虚拟化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三个线程顺序打印ABC</title>
      <link href="/2022/03/14/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0ABC/"/>
      <url>/2022/03/14/%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0ABC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                  三个线程顺序打印ABC</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>mutex m; <span class="hljs-comment">//互斥锁</span><br>std::condition_variable cond_var; <span class="hljs-comment">//创建条件变量对象</span><br><span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n=ch-<span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">mylock</span><span class="hljs-params">(m)</span></span>;<br>cond_var.<span class="hljs-built_in">wait</span>(mylock,[n]&#123; <span class="hljs-comment">//调用wait函数，先解锁mylock，然后判断lambda的返回值</span><br>            <span class="hljs-keyword">return</span> n==num;&#125;);<br>cout&lt;&lt;ch;<br>num=(num+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>;<br>mylock.<span class="hljs-built_in">unlock</span>();<br>cond_var.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">//唤醒所有等待条件变量的线程。</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;thread&gt; pool;<br>pool.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">thread</span>(func,<span class="hljs-string">&#x27;A&#x27;</span>));<br>pool.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">thread</span>(func,<span class="hljs-string">&#x27;B&#x27;</span>));<br>pool.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">thread</span>(func,<span class="hljs-string">&#x27;C&#x27;</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = pool.<span class="hljs-built_in">begin</span>(); it != pool.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>it-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用wait时，会执行以下步骤：1、对绑定的unique_lock对象解锁；2、判断调用对象的返回值。如果调用对象返回值为false，则wait就一直阻塞，一直等待被notify唤醒；如果调用对象为true，则会对绑定的unique_lock对象重新上锁，然后wait函数返回，继续执行后续的程序。当wait被notify唤醒时，会先重新对绑定的unique_lock对象上锁，然后执行上面的1、2步骤</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程/多进程 </category>
          
          <category> 三个线程顺序打印ABC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/2022/03/14/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2022/03/14/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                              給一个字符串s，找到s中的最长的回文子串</p></blockquote><blockquote><p>最长回文子串和回文子串</p></blockquote><span id="more"></span><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//定义一个函数来寻找最长回文串</span><br>    <span class="hljs-function">string <span class="hljs-title">palindrome</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 防止索引越界</span><br>    <span class="hljs-keyword">while</span> (l &gt;=<span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) &#123;<br>        <span class="hljs-comment">// 双指针，向两边展开</span><br>        l--; <br>        r++;<br>    &#125;<br>    <span class="hljs-comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span><br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(l+<span class="hljs-number">1</span>, r-l<span class="hljs-number">-1</span>);<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-comment">// 以 s[i] 为中心的最长回文子串</span><br>        string s1 = <span class="hljs-built_in">palindrome</span>(s, i, i);<br>        <span class="hljs-comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span><br>        string s2 = <span class="hljs-built_in">palindrome</span>(s, i, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// res = longest(res, s1, s2)</span><br>        res = res.<span class="hljs-built_in">size</span>() &gt; s1.<span class="hljs-built_in">size</span>() ? res : s1;<br>        res = res.<span class="hljs-built_in">size</span>() &gt; s2.<span class="hljs-built_in">size</span>() ? res : s2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N^2^)</p><p>空间复杂度：O(1)</p><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-built_in">Substring</span>(s,i,i);<br>            <span class="hljs-type">int</span> b=<span class="hljs-built_in">Substring</span>(s,i,i+<span class="hljs-number">1</span>);<br>            result += a+b;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Substring</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; right&lt;s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left]==s[right])&#123;<br>            left--;<br>            right++;<br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(N^2^)</p><p>空间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
          <category> 回文子串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子集、排列、组合</title>
      <link href="/2022/03/14/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/2022/03/14/%E5%AD%90%E9%9B%86%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回溯算法解决子集、排列、组合问题</p></blockquote><span id="more"></span><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h4><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序返回解集。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-comment">//将结果加入到res中</span><br>        res.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//做选择</span><br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(nums, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤消选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90.子集 II"></a>90.子集 II</h4><blockquote><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按任意顺序排列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//将元素排序</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//剪枝,值相同的相邻树枝，只遍历一次</span><br>            <span class="hljs-keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(nums, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤销选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h4><blockquote><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按任何顺序返回答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">dfs</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span>(k==temp.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//做选择</span><br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(n, k, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤消选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h4><blockquote><p>给你一个 无重复元素的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的所有不同组合 ，并以列表形式返回。你可以按任意顺序返回这些组合。candidates 中的同一个 数字可以无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//做选择</span><br>            temp.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(candidates, target, i);<br>            <span class="hljs-comment">//撤消选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            sum -= candidates[i];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h4><blockquote><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用 一次 。</p><p>注意：解集不能包含重复的组合。 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//剪枝，值相同的树枝，只遍历第一条</span><br>            <span class="hljs-keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            temp.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(candidates, target, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤消选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            sum -= candidates[i];<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216.组合总和 III"></a>216.组合总和 III</h4><blockquote><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 最多使用一次</li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-built_in">dfs</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-comment">//结束条件</span><br>        <span class="hljs-keyword">if</span>(sum&gt;n)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>()==k &amp;&amp; sum==n)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>            <span class="hljs-comment">//做选择</span><br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            sum += i;<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(k, n, i+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//撤消选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            sum -= i;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h4><blockquote><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其所有可能的全排列 。你可以按任意顺序返回答案。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; isVisited;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        isVisited.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">dfs</span>(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-comment">//触发结束条件</span><br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//剪枝函数</span><br>            <span class="hljs-keyword">if</span>(isVisited[i]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//做选择</span><br>            isVisited[i]=<span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(nums);<br>            <span class="hljs-comment">//撤消选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            isVisited[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h4><blockquote><p>给定一个可包含重复数字的序列 <code>nums</code> ，按任意顺序 返回所有不重复的全排列。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; isVisited;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-comment">//先排序，让相同的元素靠在一起</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        isVisited.<span class="hljs-built_in">resize</span>(n, <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">dfs</span>(nums);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-comment">//触发结束条件</span><br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>()==nums.<span class="hljs-built_in">size</span>())&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-comment">//剪枝</span><br>            <span class="hljs-keyword">if</span>(isVisited[i]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置</span><br>            <span class="hljs-comment">// 如果前面的相邻相等元素没有用过，则跳过</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i<span class="hljs-number">-1</span>] &amp;&amp; !isVisited[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>; <br>            <span class="hljs-comment">//做选择</span><br>            isVisited[i]=<span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-comment">//回溯</span><br>            <span class="hljs-built_in">dfs</span>(nums);<br>            <span class="hljs-comment">//撤销选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            isVisited[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31.下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31.下一个排列</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//思路：两趟遍历</span><br>        <span class="hljs-comment">//从后往前找到第一个逆序的数字，</span><br>        <span class="hljs-comment">//然后找到该逆序数字后面比它大的最小数字</span><br>        <span class="hljs-comment">//交换两个数的位置</span><br>        <span class="hljs-comment">//对一开始逆序数位置后面的进行反转</span><br><br>        <span class="hljs-type">int</span> i=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;<br>        <span class="hljs-comment">//从后往前找到第一个逆序的数字</span><br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>            i--;<br>        &#125;<br>        <span class="hljs-comment">//找到该逆序数字后面比它大的最小数字</span><br>        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span> &amp;&amp; nums[i]&gt;=nums[j])&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//交换</span><br>            <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-comment">//对一开始逆序数位置后面的进行反转</span><br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//时间复杂度：O(n)</span><br><span class="hljs-comment">//空间复杂度：O(1)</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> DFS </category>
          
          <category> 子集、排列、组合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 设计模式（李建忠视频笔记）</title>
      <link href="/2022/03/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/11/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计模式的软件处理的核心：抽象稳定，隔离变化。实现可扩展、灵活、低耦合、稳定的框架。</p></blockquote><blockquote><p>【设计模式】<a href="https://b23.tv/AuN6ZOL"> C++ 设计模式（全 26 讲）</a></p></blockquote><blockquote><p>设计模式的软件处理的核心：<strong>抽象稳定，隔离变化</strong>。实现可扩展、灵活、低耦合、稳定的框架。</p></blockquote><span id="more"></span><h3 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h3><p>目标：</p><ul><li>理解松耦合设计思想</li><li>掌握面向对象设计原则</li><li>掌握重构技法改善设计</li><li>掌握GOF核心设计模式</li></ul><h4 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h4><blockquote><p>“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。——Christopher Alexander</p></blockquote><h4 id="从面向对象谈起"><a href="#从面向对象谈起" class="headerlink" title="从面向对象谈起"></a>从面向对象谈起</h4><p><strong>底层思维</strong>：向下，如何把握机器底层从微观理解对象构造</p><ul><li>语言构造</li><li>编译转换</li><li>内存模型</li><li>运行时机制</li></ul><p><strong>抽象思维</strong>：向上，如何将我们的周围世界抽象为程序代码</p><ul><li>面向对象</li><li>组件封装</li><li>设计模式</li><li>架构模式</li></ul><h4 id="深入理解面向对象"><a href="#深入理解面向对象" class="headerlink" title="深入理解面向对象"></a>深入理解面向对象</h4><p><strong>向下</strong>：深入理解三大面向对象机制</p><ul><li>封装，隐藏内部实现</li><li>继承，复用现有代码</li><li>多态，改写对象行为</li></ul><p><strong>向上</strong>：深刻把握面向对象机制所带来的抽象意义，理解如何使用这些机制来表达现实世界，掌握什么是 “好的面向对象设计”</p><h4 id="软件设计固有的复杂性"><a href="#软件设计固有的复杂性" class="headerlink" title="软件设计固有的复杂性"></a>软件设计固有的复杂性</h4><blockquote><p>建筑商从来不会去想给一栋已建好的 100 层高的楼房底下再新修一个小地下室——这样做花费极大而且注定要失败。然而令人惊奇的是，软件系统的用户在要求作出类似改变时却不会仔细考虑，而且他们认为这只是需要简单编程的事。 ——Object-Oriented Analysis and Design with Applications</p></blockquote><h4 id="软件设计复杂的根本原因"><a href="#软件设计复杂的根本原因" class="headerlink" title="软件设计复杂的根本原因"></a>软件设计复杂的根本原因</h4><p><strong>变化</strong></p><ul><li>客户需求的变化</li><li>技术平台的变化</li><li>开发团队的变化</li><li>市场环境的变化</li><li>……</li></ul><h4 id="如何解决复杂性"><a href="#如何解决复杂性" class="headerlink" title="如何解决复杂性"></a>如何解决复杂性</h4><p><strong>分解</strong></p><ul><li>人们面对复杂性有一个常见的做法：即分而治之，将大问题分 解为多个小问题，将复杂问题分解为多个简单问题。</li></ul><p><strong>抽象</strong></p><ul><li>更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。 由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节， 而去处理泛化和理想化了的对象模型。</li></ul><p><strong>结构化 VS. 面向对象</strong></p><h4 id="软件设计的目标"><a href="#软件设计的目标" class="headerlink" title="软件设计的目标"></a>软件设计的目标</h4><p>什么是好的软件设计？软件设计的金科玉律：<strong>复用！</strong></p><h3 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h3><h4 id="面向对象设计，为什么？"><a href="#面向对象设计，为什么？" class="headerlink" title="面向对象设计，为什么？"></a>面向对象设计，为什么？</h4><p>变化是复用的天敌！面向对象设计最大的优势在于：<strong>抵御变化！</strong></p><h4 id="重新认识面向对象"><a href="#重新认识面向对象" class="headerlink" title="重新认识面向对象"></a>重新认识面向对象</h4><p><strong>理解隔离变化</strong></p><ul><li>从宏观层面来看，面向对象的构建方式更能适应软件的变化， 能将变化所带来的影响减为最小</li></ul><p><strong>各司其职</strong></p><ul><li>从微观层面来看，面向对象的方式更强调各个类的 “责任”</li><li>由于需求变化导致的新增类型不应该影响原来类型的实现——是所谓各负其责</li></ul><p><strong>对象是什么？</strong></p><ul><li>从语言实现层面来看，对象封装了代码和数据。</li><li>从规格层面讲，对象是一系列可被使用的公共接口。</li><li>从概念层面讲，对象是某种拥有责任的抽象。</li></ul><h4 id="面向对象设计原则-1"><a href="#面向对象设计原则-1" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h4><p><img src="/images/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.png" alt="设计原则"></p><p><strong>依赖倒置原则（DIP）</strong></p><ul><li>高层模块 (稳定) 不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</li><li>抽象 (稳定) 不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</li></ul><p><strong>开放封闭原则（OCP）</strong></p><ul><li>对扩展开放，对更改封闭。</li><li>类模块应该是可扩展的，但是不可修改。</li></ul><p><strong>单一职责原则（SRP）</strong></p><ul><li>一个类应该仅有一个引起它变化的原因。</li><li>变化的方向隐含着类的责任。</li></ul><p><strong>Liskov 替换原则（LSP）</strong></p><ul><li>子类必须能够替换它们的基类 (IS-A)。</li><li>继承表达类型抽象。</li></ul><p><strong>接口隔离原则（ISP）</strong></p><ul><li>不应该强迫客户程序依赖它们不用的方法。</li><li>接口应该小而完备。</li></ul><p><strong>优先使用对象组合，而不是类继承</strong></p><ul><li>类继承通常为 “白箱复用”，对象组合通常为 “黑箱复用”。</li><li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li><li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合 度低。</li></ul><p><strong>封装变化点</strong></p><ul><li>使用封装来创建对象之间的分界层，让设计者可以在分界层的 一侧进行修改，而不会对另一侧产生不良的影响，从而实现层 次间的松耦合。</li></ul><p><strong>针对接口编程，而不是针对实现编程</strong></p><ul><li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li><li>客户程序无需获知对象的具体类型，只需要知道对象所具有的 接口。</li><li>减少系统中各部分的依赖关系，从而实现 “高内聚、松耦合” 的类型设计方案。</li></ul><h4 id="面向接口设计"><a href="#面向接口设计" class="headerlink" title="面向接口设计"></a>面向接口设计</h4><p>产业强盛的标志：<strong>接口标准化!</strong></p><h4 id="将设计原则提升为设计经验"><a href="#将设计原则提升为设计经验" class="headerlink" title="将设计原则提升为设计经验"></a>将设计原则提升为设计经验</h4><ol><li><strong>设计习语 Design Idioms</strong><ul><li>Design Idioms 描述与特定编程语言相关的低层模式，技巧， 惯用法。</li></ul></li><li><strong>设计模式 Design Patterns</strong><ul><li>Design Patterns 主要描述的是 “类与相互通信的对象之间的组 织关系，包括它们的角色、职责、协作方式等方面。</li></ul></li><li><strong>架构模式 Architectural Patterns</strong><ul><li>Architectural Patterns 描述系统中与基本结构组织关系密切的 高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。</li></ul></li></ol><h4 id="GOF-23-模式分类"><a href="#GOF-23-模式分类" class="headerlink" title="GOF-23 模式分类"></a>GOF-23 模式分类</h4><p><strong>从目的来看</strong>：</p><ul><li>创建型（Creational）模式：将对象的部分创建工作延迟到子 类或者其他对象，从而应对需求变化为对象创建时具体类型实 现引来的冲击。</li><li>结构型（Structural）模式：通过类继承或者对象组合获得更灵 活的结构，从而应对需求变化为对象的结构带来的冲击。</li><li>行为型（Behavioral）模式：通过类继承或者对象组合来划分 类与对象间的职责，从而应对需求变化为多个交互的对象带来 的冲击。</li></ul><p><strong>从范围来看</strong>：</p><ul><li>类模式处理类与子类的静态关系。</li><li>对象模式处理对象间的动态关系。</li></ul><h4 id="从封装变化角度对模式分类"><a href="#从封装变化角度对模式分类" class="headerlink" title="从封装变化角度对模式分类"></a>从封装变化角度对模式分类</h4><p><img src="/images/%E4%BB%8E%E5%B0%81%E8%A3%85%E5%8F%98%E5%8C%96%E8%A7%92%E5%BA%A6%E5%AF%B9%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="从封装变化角度对模式分类"></p><p><strong>组件协作</strong>：</p><ul><li>Template Method – 模板方法</li><li>Observer &#x2F; Event – 观察者模式</li><li>Strategy – 策略模式</li></ul><p><strong>单一职责：</strong></p><ul><li>Decorator – 装饰器模式</li><li>Bridge – 桥接模式</li></ul><p><strong>对象创建:</strong></p><ul><li>Factory Method – 工厂方法</li><li>Abstract Factory – 抽象工厂</li><li>Prototype – 原型模式</li><li>Builder – 构建器模式 – 目前已经用的不多</li></ul><p><strong>对象性能：</strong></p><ul><li>Singleton – 单件模式</li><li>Flyweight – 享元模式</li></ul><p><strong>接口隔离:</strong></p><ul><li>Façade – 门面模式</li><li>Proxy – 代理模式</li><li>Mediator – 中介者模式 – 目前已经用的不多</li><li>Adapter – 适配器模式</li></ul><p><strong>状态变化：</strong></p><ul><li>Memento – 备忘录模式 – 目前已经用的不多</li><li>State – 状态模式</li></ul><p><strong>数据结构：</strong></p><ul><li>Composite – 组合模式</li><li>Iterator – 迭代器模式 – 目前已经用的不多</li><li>Chain of Resposibility – 职责链模式 – 目前已经用的不多</li></ul><p><strong>行为变化：</strong></p><ul><li>Command – 命令行模式 – 目前已经用的不多</li><li>Visitor – 访问器模式 – 目前已经用的不多</li></ul><p><strong>领域问题：</strong></p><ul><li>Interpreter – 解析器模式 – 目前已经用的不多</li></ul><h4 id="重构获得模式-Refactoring-to-Patterns"><a href="#重构获得模式-Refactoring-to-Patterns" class="headerlink" title="重构获得模式 Refactoring to Patterns"></a>重构获得模式 Refactoring to Patterns</h4><ul><li>面向对象设计模式是 “好的面向对象设计”，所谓“好的面向对 象设计” 指是那些可以满足 “应对变化，提高复用”的设计 。</li><li>现代软件设计的特征是 “需求的频繁变化”。设计模式的要点是 “寻找变化点，然后在变化点处应用设计模式，从而来更好地应对 需求的变化”.“什么时候、什么地点应用设计模式” 比“理解设计模式结构本身”更为重要。</li><li>设计模式的应用不宜先入为主，一上来就使用设计模式是对设计 模式的最大误用。没有一步到位的设计模式。敏捷软件开发实践提倡的 “Refactoring to Patterns” 是目前普遍公认的最好的使用设计模式的方法。</li></ul><h4 id="重构关键技法"><a href="#重构关键技法" class="headerlink" title="重构关键技法"></a>重构关键技法</h4><ul><li>静态 –&gt; 动态</li><li>早绑定 –&gt; 晚绑定</li><li>继承 –&gt; 组合</li><li>编译时依赖 –&gt; 运行时依赖</li><li>紧耦合 –&gt; 松耦合</li></ul><h3 id="Template-Method-模板方法模式"><a href="#Template-Method-模板方法模式" class="headerlink" title="Template Method 模板方法模式"></a>Template Method 模板方法模式</h3><h4 id="“组件协作”-模式"><a href="#“组件协作”-模式" class="headerlink" title="“组件协作” 模式:"></a>“组件协作” 模式:</h4><ul><li>现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作” 模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。</li><li>典型模式<ul><li>Template Method</li><li>Observer &#x2F; Event</li><li>Strategy</li></ul></li></ul><h4 id="动机（Motivation）"><a href="#动机（Motivation）" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 （比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</li><li>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？</li></ul><h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟 (变化) 到子类中。Template Method 使得子类可以不改变 (复用) 一个算法的结构即可重定义 (override 重写) 该算法的某些特定步骤。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）"><a href="#结构（Structure）" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模板方法模式"></p><h4 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Template Method 模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。<strong>它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本 实现结构</strong>。</li><li>除了可以灵活应对子步骤的变化外，<strong>“不要调用我，让我来调用你” 的反向控制结构是 Template Method 的典型应用</strong>。</li><li>在具体实现方面，被 Template Method 调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），<strong>但一般推荐将它们设置为 protected 方法</strong>。</li></ul><h2 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy 策略模式"></a>Strategy 策略模式</h2><h4 id="“组件协作”-模式-1"><a href="#“组件协作”-模式-1" class="headerlink" title="“组件协作” 模式:"></a>“组件协作” 模式:</h4><ul><li>现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作” 模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。</li><li>典型模式<ul><li>Template Method</li><li>Observer &#x2F; Event</li><li>Strategy</li></ul></li></ul><h4 id="动机（Motivation）-1"><a href="#动机（Motivation）-1" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。</li><li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</li></ul><h4 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序 (稳定) 而变化（扩展，子类化）。 ——《设计模式》 GoF</p></blockquote><h4 id="结构（Structure"><a href="#结构（Structure" class="headerlink" title="结构（Structure)"></a>结构（Structure)</h4><p><img src="/images/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt="策略模式"></p><h4 id="要点总结-1"><a href="#要点总结-1" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Strategy 及其子类为组件提供了一系列可重用的算法，从而可以使得类型<strong>在运行时</strong>方便地根据需要在各个算法之间进行切换。</li><li><strong>Strategy 模式提供了用条件判断语句以外的另一种选择</strong>，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要 Strategy 模式。</li><li><strong>如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象，从而节省对象开销</strong>。</li></ul><h3 id="Observer-观察者模式"><a href="#Observer-观察者模式" class="headerlink" title="Observer 观察者模式"></a>Observer 观察者模式</h3><h4 id="“组件协作”-模式-2"><a href="#“组件协作”-模式-2" class="headerlink" title="“组件协作” 模式:"></a>“组件协作” 模式:</h4><ul><li>现代软件专业分工之后的第一个结果是 “框架与应用程序的划分”，“组件协作” 模式通过晚期绑定，来实现框架与应用程序之 间的松耦合，是二者之间协作时常用的模式。</li><li>典型模式<ul><li>Template Method</li><li>Observer &#x2F; Event</li><li>Strategy</li></ul></li></ul><h4 id="动机（Motivation）-2"><a href="#动机（Motivation）-2" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，我们需要为某些对象建立一种 “通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</li><li>使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。</li></ul><h4 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>定义对象间的一种一对多（变化）的依赖关系，以便当一个 对象 (Subject) 的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-1"><a href="#结构（Structure）-1" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p><h4 id="要点总结-2"><a href="#要点总结-2" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>使用面向对象的抽象，Observer 模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</li><li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</li><li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li><li>Observer 模式是基于事件的 UI 框架中非常常用的设计模式，也是 MVC 模式的一个重要组成部分。</li></ul><h3 id="Decorator-装饰模式-–-继承和组合同时使用"><a href="#Decorator-装饰模式-–-继承和组合同时使用" class="headerlink" title="Decorator 装饰模式 – 继承和组合同时使用"></a>Decorator 装饰模式 – 继承和组合同时使用</h3><h4 id="“单一职责”-模式"><a href="#“单一职责”-模式" class="headerlink" title="“单一职责” 模式:"></a>“单一职责” 模式:</h4><ul><li>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</li><li>典型模式<ul><li>Decorator</li><li>Bridge</li></ul></li></ul><h4 id="动机（Motivation）-3"><a href="#动机（Motivation）-3" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在某些情况下我们可能会 “过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</li><li>如何使 “对象功能的扩展” 能够根据需要来动态地实现？同时避免 “扩展功能的增多” 带来的子类膨胀问题？从而使得任何 “功能扩展变化” 所导致的影响将为最低？</li></ul><h4 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator 模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-2"><a href="#结构（Structure）-2" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="装饰器模式"></p><h4 id="要点总结-3"><a href="#要点总结-3" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>通过采用组合而非继承的手法， Decorator 模式实现了在<strong>运行时</strong>动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的 “灵活性差” 和“多子类衍生问题”。</li><li>Decorator 类在接口上表现为 is-a Component 的继承关系，即 Decorator 类继承了 Component 类所具有的接口。但在实现上又表现为 has-a Component 的组合关系，即 Decorator 类又使用了另外一个 Component 类。</li><li>Decorator 模式的目的并非解决 “多子类衍生的多继承” 问题，Decorator 模式应用的要点在于解决 “主体类在多个方向上的扩展功能”——是为“装饰” 的含义。</li></ul><h3 id="Bridge-桥模式"><a href="#Bridge-桥模式" class="headerlink" title="Bridge 桥模式"></a>Bridge 桥模式</h3><h4 id="“单一职责”-模式-1"><a href="#“单一职责”-模式-1" class="headerlink" title="“单一职责” 模式:"></a>“单一职责” 模式:</h4><ul><li>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</li><li>典型模式<ul><li>Decorator</li><li>Bridge</li></ul></li></ul><h4 id="动机（Motivation）-4"><a href="#动机（Motivation）-4" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度， 乃至多个纬度的变化。</li><li>如何应对这种 “多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li></ul><h4 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>将抽象部分 (业务功能) 与实现部分 (平台实现) 分离，使它们都可以独立地变化。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-3"><a href="#结构（Structure）-3" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E6%A1%A5%E6%A8%A1%E5%BC%8F.png" alt="桥模式"></p><h4 id="要点总结-4"><a href="#要点总结-4" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>ridge 模式使用 “<strong>对象间的组合关系</strong>”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即 “子类化” 它们。</li><li>Bridge 模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge 模式是比多继承方案更好的解决方法。</li><li>Bridge 模式的应用一般在 “<strong>两个非常强的变化维度</strong>”，有时一个类也有多于两个的变化维度，这时可以使用 Bridge 的扩展模式。</li></ul><h3 id="Factory-Method-工厂方法"><a href="#Factory-Method-工厂方法" class="headerlink" title="Factory Method 工厂方法"></a>Factory Method 工厂方法</h3><h4 id="“对象创建”-模式"><a href="#“对象创建”-模式" class="headerlink" title="“对象创建” 模式"></a>“对象创建” 模式</h4><ul><li>通过 “对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>典型模式<ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul></li></ul><h4 id="动机（Motivation）-5"><a href="#动机（Motivation）-5" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</li><li>如何应对这种变化？如何绕过常规的对象创建方法 (new)，提供一种“封装机制” 来避免客户程序和这种 “具体对象创建工作” 的紧耦合？</li></ul><h4 id="模式定义-5"><a href="#模式定义-5" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-4"><a href="#结构（Structure）-4" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="工厂方法"></p><h4 id="要点总结-5"><a href="#要点总结-5" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Factory Method 模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系 (new) 会导致软件的脆弱。</li><li>Factory Method 模式通过面向对象的手法，将所要创建的具体对象工作<strong>延迟</strong>到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</li><li>Factory Method 模式解决 “<strong>单个对象</strong>” 的需求变化。缺点在于要求创建方法 &#x2F; 参数相同。</li></ul><h3 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h3><h4 id="“对象创建”-模式-1"><a href="#“对象创建”-模式-1" class="headerlink" title="“对象创建” 模式"></a>“对象创建” 模式</h4><ul><li>通过 “对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>典型模式<ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul></li></ul><h4 id="动机（Motivation）-6"><a href="#动机（Motivation）-6" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统中，经常面临着 “<strong>一系列相互依赖的对象</strong>” 的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</li><li>如何应对这种变化？如何绕过常规的对象创建方法 (new)，提供一种“封装机制” 来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合？</li></ul><h4 id="模式定义-6"><a href="#模式定义-6" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>提供一个接口，让该接口负责创建一系列 “相关或者相互依赖的对象”，无需指定它们具体的类。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-5"><a href="#结构（Structure）-5" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="抽象工厂方法"></p><h4 id="要点总结-6"><a href="#要点总结-6" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>如果没有应对 “<strong>多系列对象构建</strong>” 的需求变化，则没有必要使用 Abstract Factory 模式，这时候使用简单的工厂完全可以。</li><li>“系列对象” 指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。</li><li>Abstract Factory 模式主要在于应对 “新系列” 的需求变动。其缺点在于难以应对 “新对象” 的需求变动。</li></ul><h3 id="Prototype-原型模式"><a href="#Prototype-原型模式" class="headerlink" title="Prototype 原型模式"></a>Prototype 原型模式</h3><h4 id="“对象创建”-模式-2"><a href="#“对象创建”-模式-2" class="headerlink" title="“对象创建” 模式"></a>“对象创建” 模式</h4><ul><li>通过 “对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>典型模式<ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul></li></ul><h4 id="动机（Motivation）-7"><a href="#动机（Motivation）-7" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统中，经常面临着 “某些结构复杂的对象” 的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</li><li>如何应对这种变化？如何向 “客户程序（使用这些对象的程序）” 隔离出 “这些易变对象”，从而使得“依赖这些易变对象的客户程序” 不随着需求改变而改变？</li></ul><h4 id="模式定义-7"><a href="#模式定义-7" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>使用原型实例指定创建对象的种类，然后通过<strong>拷贝</strong>这些原型来创建新的对象。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-6"><a href="#结构（Structure）-6" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="原型模式"></p><h4 id="要点总结-7"><a href="#要点总结-7" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Prototype 模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求 “易变类” 拥有“稳定的接口”。</li><li>Prototype 模式对于 “如何创建易变的实体对象” 采用 “原型克隆” 的方法来做，它使得我们可以非常灵活的动态创建 “拥有某些稳定接口” 的新对象——所需工作仅仅时注册一个新类的对象（即原型），然后在任何需要的地方 Clone。</li><li>Prototype 模式中的 Clone 方法可以利用某些框架中的序列化来实现深拷贝。</li></ul><h3 id="Builder-构建器"><a href="#Builder-构建器" class="headerlink" title="Builder 构建器"></a>Builder 构建器</h3><h4 id="“对象创建”-模式-3"><a href="#“对象创建”-模式-3" class="headerlink" title="“对象创建” 模式"></a>“对象创建” 模式</h4><ul><li>通过 “对象创建” 模式绕开 new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li><li>典型模式<ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder</li></ul></li></ul><h4 id="动机（Motivation）-8"><a href="#动机（Motivation）-8" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统中，有时候面临着 “一个复杂对象” 的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</li><li>如何应对这种变化？如何提供一种 “封装机制” 来隔离出 “复杂对象的各个部分” 的变化，从而保持系统中的 “稳定构建算法” 不随着需求改变而改变？</li></ul><h4 id="模式定义-8"><a href="#模式定义-8" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程 (稳定) 可以创建不同的表示(变化)。 ——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-7"><a href="#结构（Structure）-7" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E6%9E%84%E5%BB%BA%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="构建器模式"></p><h4 id="要点总结-8"><a href="#要点总结-8" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Builder 模式主要用于 “分步骤构建一个复杂的对象”。在这其中 “分步骤” 是一个稳定的算法，而复杂对象的各个部分则经常变化。</li><li>变化点在哪里，封装哪里—— Builder 模式主要在于应对 “复杂对象各个部分” 的频繁需求变动。其缺点在于难以应对 “分步骤构建算法” 的需求变动。</li><li>在 Builder 模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#) 。</li></ul><h3 id="Singleton-单件模式"><a href="#Singleton-单件模式" class="headerlink" title="Singleton 单件模式"></a>Singleton 单件模式</h3><h4 id="“对象性能”-模式"><a href="#“对象性能”-模式" class="headerlink" title="“对象性能” 模式"></a>“对象性能” 模式</h4><ul><li>面向对象很好的解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>典型模式<ul><li>Singleton</li><li>Flyweight</li></ul></li></ul><h4 id="动机（Motivation）-9"><a href="#动机（Motivation）-9" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</li><li>如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？</li><li>这应该是类设计者的责任，而不是使用者的责任。</li></ul><h4 id="模式定义-9"><a href="#模式定义-9" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-8"><a href="#结构（Structure）-8" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F.png" alt="单件模式"></p><h4 id="要点总结-9"><a href="#要点总结-9" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Singleton 模式中的实例构造器可以设置为 protected 以允许子类派生。</li><li>Singleton 模式一般不要支持拷贝构造和 Clone 接口，因为这有可能导致多个对象实例，与 Singleton 模式的初衷违背。</li><li>如何实现多线程环境下安全的 Singleton？ 注意对双检查锁的正确实现。</li></ul><h3 id="Flyweight-享元模式"><a href="#Flyweight-享元模式" class="headerlink" title="Flyweight 享元模式"></a>Flyweight 享元模式</h3><h4 id="“对象性能”-模式-1"><a href="#“对象性能”-模式-1" class="headerlink" title="“对象性能” 模式"></a>“对象性能” 模式</h4><ul><li>面向对象很好的解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>典型模式<ul><li>Singleton</li><li>Flyweight</li></ul></li></ul><h4 id="动机（Motivation）-10"><a href="#动机（Motivation）-10" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行是代价——主要指内存需求方面的代价。</li><li>如何在避免大量细粒度对象问题的同时，让外部客户程序任然能够透明地使用面向对象的方式来进行操作？</li></ul><h4 id="模式定义-10"><a href="#模式定义-10" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>运用共享技术有效地支持大量细粒度的对象。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-9"><a href="#结构（Structure）-9" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="享元模式"></p><h4 id="要点总结-10"><a href="#要点总结-10" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>面向对象很好的解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight 主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。</li><li>Flyweight 采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li><li>对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。</li></ul><h3 id="Facade-门面模式"><a href="#Facade-门面模式" class="headerlink" title="Facade 门面模式"></a>Facade 门面模式</h3><h4 id="“接口隔离”-模式"><a href="#“接口隔离”-模式" class="headerlink" title="“接口隔离” 模式"></a>“接口隔离” 模式</h4><ul><li>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>典型模式<ul><li>Facade</li><li>Proxy</li><li>Adapter</li><li>Mediator</li></ul></li></ul><h4 id="系统间耦合的复杂度"><a href="#系统间耦合的复杂度" class="headerlink" title="系统间耦合的复杂度"></a>系统间耦合的复杂度</h4><p><img src="/images/%E7%B3%BB%E7%BB%9F%E9%97%B4%E8%80%A6%E5%90%88%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="系统间耦合的复杂度"></p><h4 id="动机（Motivation）-11"><a href="#动机（Motivation）-11" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>上述 A 方案的问题在于组件的客户和组件各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。</li><li>如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</li></ul><h4 id="模式定义-11"><a href="#模式定义-11" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>为子系统的一组接口提供一个一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-10"><a href="#结构（Structure）-10" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.png" alt="门面模式"></p><h4 id="要点总结-11"><a href="#要点总结-11" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>从客户程序的角度来看，Facade 模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种 “解耦” 的效果——内部子系统的任何变化不会影响到 Facade 接口的变化。</li><li>Facade 设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade 很多时候更是一种架构设计模式。</li><li>Facade 设计模式并非一个集装箱，可以任意的放进任何多个对象。Facade 模式中组件的内部应该是 “相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。</li></ul><h3 id="Proxy-代理模式"><a href="#Proxy-代理模式" class="headerlink" title="Proxy 代理模式"></a>Proxy 代理模式</h3><h4 id="“接口隔离”-模式-1"><a href="#“接口隔离”-模式-1" class="headerlink" title="“接口隔离” 模式"></a>“接口隔离” 模式</h4><ul><li>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>典型模式<ul><li>Facade</li><li>Proxy</li><li>Adapter</li><li>Mediator</li></ul></li></ul><h4 id="动机（Motivation）-12"><a href="#动机（Motivation）-12" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者、或者系统结构带来很多麻烦。</li><li>如何在不失去透明操作对象的同事来管理 &#x2F; 控制这些对象特有的复杂性？增加一层间接层是软件开发中常见的解决方式。</li></ul><h4 id="模式定义-12"><a href="#模式定义-12" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-11"><a href="#结构（Structure）-11" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="代理模式"></p><h4 id="要点总结-12"><a href="#要点总结-12" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>“增加一层间接层” 是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的 proxy 对象便是解决这一问题的常用手段。</li><li>具体 proxy 设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如 copy-on-write 技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做 proxy。</li><li>Proxy 并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</li></ul><h3 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h3><h4 id="“接口隔离”-模式-2"><a href="#“接口隔离”-模式-2" class="headerlink" title="“接口隔离” 模式"></a>“接口隔离” 模式</h4><ul><li>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>典型模式<ul><li>Facade</li><li>Proxy</li><li>Adapter</li><li>Mediator</li></ul></li></ul><h4 id="动机（Motivation）-13"><a href="#动机（Motivation）-13" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件系统中，由于应用环境的变化，常常需要将 “一些现存的对象” 放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li><li>如何应对这种 “迁移的变化”？ 如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</li></ul><h4 id="模式定义-13"><a href="#模式定义-13" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-12"><a href="#结构（Structure）-12" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="适配器模式"></p><h4 id="要点总结-13"><a href="#要点总结-13" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Adapter 模式主要应用于 “希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</li><li>GoF 23 定义了两种 Adapter 模式的实现结构：对象适配器和类适配器。但类适配器采用 “多继承” 的实现方式，一般不推荐使用。对象适配器采用 “对象组合” 的方式，更符合松耦合精神。</li><li>Adapter 模式可以实现的非常灵活，不必拘泥于 GoF23 中定义的两种结构。例如，完全可以将 Adapter 模式中的 “现存对象” 作为新的接口方法参数，来达到适配的目的。</li></ul><h3 id="Mediator-中介者"><a href="#Mediator-中介者" class="headerlink" title="Mediator 中介者"></a>Mediator 中介者</h3><h4 id="“接口隔离”-模式-3"><a href="#“接口隔离”-模式-3" class="headerlink" title="“接口隔离” 模式"></a>“接口隔离” 模式</h4><ul><li>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口是一种常见的解决方案。</li><li>典型模式<ul><li>Facade</li><li>Proxy</li><li>Adapter</li><li>Mediator</li></ul></li></ul><h4 id="动机（Motivation）-14"><a href="#动机（Motivation）-14" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，进程会出现多个对象相互关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</li><li>在这种情况下，我们可以使用一个 “中介对象” 来管理对象间的关联关系，避免相互交互的对象之间的紧耦合引用关系，从而更好地抵御变化。</li></ul><h4 id="模式定义-14"><a href="#模式定义-14" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖–&gt; 运行时依赖），从而使得其耦合松散（管理变化），而且可以独立地改变它们之间的交互。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-13"><a href="#结构（Structure）-13" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式"></p><h4 id="要点总结-14"><a href="#要点总结-14" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>将多个对象间复杂的关联关系解耦，Mediator 模式将多个对象间的控制逻辑进行集中管理，变 “多个对象相互关联” 为 “多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li><li>随着控制逻辑的复杂化，Mediator 具体对象的实现可能相当复杂。这个时候可以对 Mediator 对象进行分解处理。</li><li>Facade 模式是解耦系统间（单向）的对象关联关系；Mediator 模式是解耦系统内各个对象之间（双向）的关联关系。</li></ul><h3 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="State 状态模式"></a>State 状态模式</h3><h4 id="“状态变化”-模式"><a href="#“状态变化”-模式" class="headerlink" title="“状态变化” 模式"></a>“状态变化” 模式</h4><ul><li>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化” 模式为这一问题提供了一种解决方案。</li><li>典型模式<ul><li>State</li><li>Memento</li></ul></li></ul><h4 id="动机（Motivation）-15"><a href="#动机（Motivation）-15" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。</li><li>如何在运行时根据对象的状态来透明的更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？</li></ul><h4 id="模式定义-15"><a href="#模式定义-15" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-14"><a href="#结构（Structure）-14" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="状态模式"></p><h4 id="要点总结-15"><a href="#要点总结-15" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>State 模式将所有与一个特定状态相关的行为都放入一个 State 的子类对象中，在对象状态切换时，切换相应的对象；但同时维持 State 的接口，这样实现了具体操作与状态转换之间的解耦。</li><li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。</li><li>如果 State 对象没有实例变量，那么各个上下文可以共享同一个 State 对象，从而节省对象开销。</li></ul><h3 id="Memento-备忘录"><a href="#Memento-备忘录" class="headerlink" title="Memento 备忘录"></a>Memento 备忘录</h3><h4 id="“状态变化”-模式-1"><a href="#“状态变化”-模式-1" class="headerlink" title="“状态变化” 模式"></a>“状态变化” 模式</h4><ul><li>在组件构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？“状态变化” 模式为这一问题提供了一种解决方案。</li><li>典型模式<ul><li>State</li><li>Memento</li></ul></li></ul><h4 id="动机（Motivation）-16"><a href="#动机（Motivation）-16" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，某些对象的状态在转换过程中，可能由于某些需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。</li><li>如何实现对象状态的良好保存与恢复？但同时又不会因此而破坏对象本身的封装性。</li></ul><h4 id="模式定义-16"><a href="#模式定义-16" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-15"><a href="#结构（Structure）-15" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt="备忘录模式"></p><h4 id="要点总结-16"><a href="#要点总结-16" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。</li><li>Memento 模式的核心是信息隐藏，即 Originator 需要向外界隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。</li><li>由于现代语言运行时（如 C#、Java 等）都具有相当的对象序列化支持，因此往往采用效率较高、又容易正确实现的序列化方案来实现 Memento 模式。</li></ul><h3 id="Composite-组合模式"><a href="#Composite-组合模式" class="headerlink" title="Composite 组合模式"></a>Composite 组合模式</h3><h4 id="“数据结构”-模式"><a href="#“数据结构”-模式" class="headerlink" title="“数据结构” 模式"></a>“数据结构” 模式</h4><ul><li>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候。将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li><li>典型模式<ul><li>Composite</li><li>Iterator</li><li>Chain Of Resposibility</li></ul></li></ul><h4 id="动机（Motivation）-17"><a href="#动机（Motivation）-17" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件在某些情况下，客户代码过多的依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。</li><li>如何将 “客户代码与复杂的对象容器结构” 解耦？让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</li></ul><h4 id="模式定义-17"><a href="#模式定义-17" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>将对象组合成树形结构以表示 “部分—整体” 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-16"><a href="#结构（Structure）-16" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="组合模式"></p><h4 id="要点总结-17"><a href="#要点总结-17" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Composite 模式采用树形结构来实现普遍存在的对象容器，从而将 “一对多” 的关系转化为 “一对一” 的关系，使得客户代码可以一致地（复用）处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li><li>将 “客户代码与复杂的对象容器结构” 解耦是 Composite 的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的内部实现结构——发生依赖，从而更能 “应对变化”。</li><li>Composite 模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li></ul><h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><h4 id="“数据结构”-模式-1"><a href="#“数据结构”-模式-1" class="headerlink" title="“数据结构” 模式"></a>“数据结构” 模式</h4><ul><li>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候。将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li><li>典型模式<ul><li>Composite</li><li>Iterator</li><li>Chain Of Resposibility</li></ul></li></ul><h4 id="动机（Motivation）-18"><a href="#动机（Motivation）-18" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明的访问其中包含的元素；同时这种 “透明遍历” 也为 “同一种算法在多种集合对象上进行操作” 提供了可能。</li><li>使用面向对象技术将这种遍历机制抽象为 “迭代器对象” 为 “应对变化中的集合对象” 提供了一种优雅的方式。</li></ul><h4 id="模式定义-18"><a href="#模式定义-18" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-17"><a href="#结构（Structure）-17" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="迭代器模式"></p><h4 id="要点总结-18"><a href="#要点总结-18" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li></ul><h3 id="Chain-Of-Resposibility-职责链"><a href="#Chain-Of-Resposibility-职责链" class="headerlink" title="Chain Of Resposibility 职责链"></a>Chain Of Resposibility 职责链</h3><h4 id="“数据结构”-模式-2"><a href="#“数据结构”-模式-2" class="headerlink" title="“数据结构” 模式"></a>“数据结构” 模式</h4><ul><li>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候。将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问，是一种行之有效的解决方案。</li><li>典型模式<ul><li>Composite</li><li>Iterator</li><li>Chain Of Resposibility</li></ul></li></ul><h4 id="动机（Motivation）-19"><a href="#动机（Motivation）-19" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显式指定，将必不可少的带来请求发送者与接受者的紧耦合。</li><li>如何使请求的发送者不需要指定具体的接受者？让请求的接受者自己在运行时决定来处理请求，从而使两者解耦。</li></ul><h4 id="模式定义-19"><a href="#模式定义-19" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递请求，直到有一个对象处理它位置。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-18"><a href="#结构（Structure）-18" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="职责链模式"></p><h4 id="要点总结-19"><a href="#要点总结-19" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Chain Of Resposibility 模式的应用场合在于 “一个请求可能有多个接受者，但是最后真正的接受者只有一个”， 这时候请求发送者接受者的耦合有可能出现 “变化脆弱” 的症状，职责链的目的就是将二者解耦，从而更好的应对变化。</li><li>应用了 Chain Of Resposibility 模式后，对象的职责分派将更具灵活性。我们可以在运行时动态添加 &#x2F; 修改请求的处理职责。</li><li>如果请求传递到职责链的末尾仍得不到处理，应该有一个合理的缺省机制。这也是每一个接受者对象的责任，而不是发出请求的对象的责任。</li></ul><h3 id="Command-命令模式"><a href="#Command-命令模式" class="headerlink" title="Command 命令模式"></a>Command 命令模式</h3><h4 id="“行为变化”-模式"><a href="#“行为变化”-模式" class="headerlink" title="“行为变化” 模式"></a>“行为变化” 模式</h4><ul><li>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化” 模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li><li>典型模式<ul><li>Command</li><li>Visitor</li></ul></li></ul><h4 id="动机（Motivation）-20"><a href="#动机（Motivation）-20" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建的过程中，“行为请求者” 与 “行为实现者” 通常呈现一种 “紧耦合”。 但在某些场合——比如需要对行为进行 “记录、撤销 &#x2F; 重（undo&#x2F;redo）、事务” 等处理，这种无法抵御变化的紧耦合是不适合的。</li><li>在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</li></ul><h4 id="模式定义-20"><a href="#模式定义-20" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-19"><a href="#结构（Structure）-19" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt="命令模式"></p><h4 id="要点总结-20"><a href="#要点总结-20" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Command 模式的根本目的在于将 “行为请求者” 与 “行为实现者” 解耦，在面向对象语言中，常见的实现手段是 “将行为抽象为对象”。</li><li>实现 Command 接口的具体命令对象 ConcreateCommand 有时候根据需要可能会保存一些额外的状态信息。通过使用 Composite 模式，可以将多个 “命令” 封装为一个 “复合命令” MacroCommand。</li><li>Command 模式与 C++ 中的函数对象有些类似。但两者定义行为接口的规范有所区别：Command 以面向对象中的 “接口 - 实现” 来定义行为接口规范，更严格，但有性能损失；C++ 函数对象以函数签名来定义行为接口规范，更灵活，性能更高。</li></ul><h3 id="Visitor-访问器"><a href="#Visitor-访问器" class="headerlink" title="Visitor 访问器"></a>Visitor 访问器</h3><h4 id="“行为变化”-模式-1"><a href="#“行为变化”-模式-1" class="headerlink" title="“行为变化” 模式"></a>“行为变化” 模式</h4><ul><li>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化。“行为变化” 模式将组件的行为和组件本身进行解耦，从而支持组件行为的变化，实现两者之间的松耦合。</li><li>典型模式<ul><li>Command</li><li>Visitor</li></ul></li></ul><h4 id="动机（Motivation）-21"><a href="#动机（Motivation）-21" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在基类中做这样的更改，将会给子类带来很繁重的变更负担，甚至破坏原有设计。</li><li>如何在不更改类层次结构的前提下，在运行是根据需要透明的为类层次结构上的各个类动态添加新的操作，从而避免上述问题？</li></ul><h4 id="模式定义-21"><a href="#模式定义-21" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>表示一个作用于某对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-20"><a href="#结构（Structure）-20" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="访问者模式"></p><h4 id="要点总结-21"><a href="#要点总结-21" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Visitor 模式通过所谓双重分发（double dispatch）来实现在不更改（不添加新的操作 - 编译时）Element 类层次结构的前提下，在运行时透明的为类层次结构上的各个类动态添加新的操作（支持变化）。</li><li>所谓双重分发即 Visitor 模式中间包括了两个多态分发（注意其中的多态机制）：第一个为 accept 方法的多态辨析；第二个为 visitElementX 方法的多态辨析。</li><li>Visitor 模式的最大缺点在于扩展类层次结构（增添新的 Element 子类），会导致 Visitor 类的改变。因此 Visitor 模式适用于 “Element 类层次结构稳定，而其中的操作却经常面临频繁改动”。</li></ul><h3 id="Interpreter-解析器"><a href="#Interpreter-解析器" class="headerlink" title="Interpreter 解析器"></a>Interpreter 解析器</h3><h4 id="“领域规则”-模式"><a href="#“领域规则”-模式" class="headerlink" title="“领域规则” 模式"></a>“领域规则” 模式</h4><ul><li>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出该领域下的一般性解决方案。</li><li>典型模式<ul><li>Interpreter</li></ul></li></ul><h4 id="动机（Motivation）-22"><a href="#动机（Motivation）-22" class="headerlink" title="动机（Motivation）"></a>动机（Motivation）</h4><ul><li>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将会面临非常频繁的变化。</li><li>在这种情况下，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解析器来解释这样的句子，从而达到解决问题的目的。</li></ul><p><img src="/images/%E7%BB%93%E6%9E%84%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="结构重复出现的问题"></p><h4 id="模式定义-22"><a href="#模式定义-22" class="headerlink" title="模式定义"></a>模式定义</h4><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释语言中的句子。——《设计模式》GoF</p></blockquote><h4 id="结构（Structure）-21"><a href="#结构（Structure）-21" class="headerlink" title="结构（Structure）"></a>结构（Structure）</h4><p><img src="/images/%E8%A7%A3%E6%9E%90%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="解析器模式"></p><h4 id="要点总结-22"><a href="#要点总结-22" class="headerlink" title="要点总结"></a>要点总结</h4><ul><li>Interpreter 模式的应用场合是 Interpreter 模式应用中的难点，只有满足 “业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题” 才适合使用 Interpreter 模式。</li><li>使用 Interpreter 模式来表示文法规则，从而可以使用面向对象技巧来方便的 “扩展” 文法。</li><li>Interpreter 模式比较适合简单的文法表示，对于复杂的文法表示，Interpreter 模式会产生比较大的类层次结构，需要求助于语法分析器这样的标准工具。</li></ul><h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><h4 id="一个目标"><a href="#一个目标" class="headerlink" title="一个目标"></a>一个目标</h4><blockquote><p><strong>管理变化，提高复用！</strong></p></blockquote><h4 id="两种手段"><a href="#两种手段" class="headerlink" title="两种手段"></a>两种手段</h4><blockquote><p><strong>分解 vs. 抽象</strong></p></blockquote><h4 id="八大原则"><a href="#八大原则" class="headerlink" title="八大原则"></a>八大原则</h4><blockquote><ul><li><strong>依赖倒置原则（DIP）</strong></li><li><strong>开放封闭原则（OCP）</strong></li><li><strong>单一职责原则（SRP）</strong></li><li><strong>Liskov 替换原则（LSP）</strong></li><li><strong>接口隔离原则（ISP）</strong></li><li><strong>对象组合优于类继承</strong></li><li><strong>封装变化点</strong></li><li><strong>面向接口编程</strong></li></ul></blockquote><h4 id="重构技法"><a href="#重构技法" class="headerlink" title="重构技法"></a>重构技法</h4><blockquote><ul><li><strong>静态 –&gt; 动态</strong></li><li><strong>早绑定 –&gt; 晚绑定</strong></li><li><strong>继承 –&gt; 组合</strong></li><li><strong>编译时依赖 –&gt; 运行时依赖</strong></li><li><strong>紧耦合 –&gt; 松耦合</strong></li></ul></blockquote><h4 id="从封装变化角度对模式分类-1"><a href="#从封装变化角度对模式分类-1" class="headerlink" title="从封装变化角度对模式分类"></a>从封装变化角度对模式分类</h4><p><img src="/images/%E4%BB%8E%E5%B0%81%E8%A3%85%E5%8F%98%E5%8C%96%E8%A7%92%E5%BA%A6%E5%AF%B9%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.png" alt="从封装变化角度对模式分类"></p><h4 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++ 对象模型"></a>C++ 对象模型</h4><p><img src="/images/cplusplus%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt="cplusplus对象模型"></p><h4 id="关注变化点和稳定点"><a href="#关注变化点和稳定点" class="headerlink" title="关注变化点和稳定点"></a>关注变化点和稳定点</h4><p><img src="/images/%E5%8F%98%E5%8C%96%E7%82%B9%E5%92%8C%E7%A8%B3%E5%AE%9A%E7%82%B9.png" alt="变化点和稳定点"></p><h4 id="什么时候不用模式"><a href="#什么时候不用模式" class="headerlink" title="什么时候不用模式"></a>什么时候不用模式</h4><ul><li><strong>代码可读性很差时</strong></li><li><strong>需求理解还很浅时</strong></li><li><strong>变化没有显现时</strong></li><li><strong>不是系统的关键依赖点</strong></li><li><strong>项目没有复用价值时</strong></li><li><strong>项目将要发布时</strong></li></ul><h4 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h4><blockquote><ul><li><strong>不要为模式而模式</strong></li><li><strong>关注抽象类 &amp; 接口</strong></li><li><strong>理清变化点和稳定点</strong></li><li><strong>审视依赖关系</strong></li><li><strong>要有 Framework 和 Application 的区隔思维</strong></li><li><strong>良好的设计是演化的结果</strong></li></ul></blockquote><h4 id="设计模式成长之路"><a href="#设计模式成长之路" class="headerlink" title="设计模式成长之路"></a>设计模式成长之路</h4><blockquote><ul><li>“手中无剑，心中无剑”：见模式而不知</li><li>“手中有剑，心中无剑”：可以识别模式，作为应用开发人员使用模式</li><li>“手中有剑，心中有剑”：作为框架开发人员为应用设计某些模式</li><li>“手中无剑，心中有剑”：忘掉模式，只有原则</li></ul></blockquote><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p><img src="/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" alt="面向对象的三个基本特征"></p><blockquote><p>任何<strong>基类</strong>都要实现虚析构函数。 eg. <code>virtual ~Library()&#123;&#125;</code></p></blockquote><blockquote><p>将一些步骤延迟到子类中，其实就是定义一个虚函数让子类去实现或者重写这个函数。</p></blockquote><blockquote><p>虚函数和纯虚函数（纯虚函数子类必须实现，虚函数基类必须实现）</p><blockquote><ul><li><strong>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数</strong>。</li><li>定义一个函数为纯虚函数，才代表函数没有被实现。</li><li>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li></ul><p><strong>有纯虚函数的类是抽象类，不能生成对象，只能派生</strong>。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。</p><p>定义纯虚函数就是为了让基类不可实例化化，因为实例化这样的抽象数据结构本身并没有意义。或者给出实现也没有意义</p></blockquote><blockquote><p>Template Method 机制 – 虚函数的多态性</p></blockquote><blockquote><p>看类图的时候要养成标注那些是稳定的那些是变化的。</p></blockquote><blockquote><p>扩展就是继承 + 多态</p></blockquote><blockquote><p>继承表明子类遵循基类定义的规范</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> c++设计模式笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写线程池</title>
      <link href="/2022/03/11/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/03/11/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                                            手写线程池</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> threadnum):<span class="hljs-built_in">started</span>(<span class="hljs-literal">false</span>),<span class="hljs-built_in">thread_num</span>(threadnum) &#123;<br>        <span class="hljs-comment">//构造函数声明未启动和线程数量</span><br>&#125;<br>    ~<span class="hljs-built_in">ThreadPool</span>()&#123;<br>       <span class="hljs-comment">//析构函数是停止，阻塞所有线程并将其从线程列表剔除后删除，清空线程列表。</span><br>    <span class="hljs-built_in">stop</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_num; ++i) &#123;<br>     threadlist[i]-&gt;<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_num; ++i) &#123;<br>     <span class="hljs-keyword">delete</span> threadlist[i];<br>    &#125;<br>    threadlist.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空线程列表</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//线程执行函数,可自定义。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getThreadNum</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> thread_num; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//启动线程池函数，将num个线程绑定threadFunc自定义函数并执行，加入线程列表</span><br><span class="hljs-keyword">if</span> (thread_num &gt; <span class="hljs-number">0</span>) &#123;<br>started = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_num; ++i) &#123;<br>thread* pthread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">thread</span>(&amp;threadFunc, <span class="hljs-keyword">this</span>);<br>threadlist.<span class="hljs-built_in">push_back</span>(pthread);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//暂时停止线程，并由条件变量通知所有线程。</span><br>started = <span class="hljs-literal">false</span>;<br>condition.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">//用于唤醒所有等待条件变量的线程。</span><br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> thread_num;<br><span class="hljs-type">bool</span> started;<br>vector&lt;thread*&gt; threadlist;<br>condition_variable condition;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程/多进程 </category>
          
          <category> 手写线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket编程实践</title>
      <link href="/2022/03/11/socket%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/03/11/socket%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                       socket编程实践</p></blockquote><span id="more"></span><h4 id="socket编程实践"><a href="#socket编程实践" class="headerlink" title="socket编程实践"></a>socket编程实践</h4><h5 id="服务器端代码-server-cpp"><a href="#服务器端代码-server-cpp" class="headerlink" title="服务器端代码 server.cpp"></a>服务器端代码 server.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//创建套接字</span><br>    <span class="hljs-type">int</span> listenfd, connfd;<br><br>    <span class="hljs-keyword">if</span> ((listenfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;create socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//将套接字和IP、端口绑定</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serv_addr));    <span class="hljs-comment">//每个字节都用0填充</span><br>    serv_addr.sin_family = AF_INET;               <span class="hljs-comment">//使用IPv4地址</span><br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(INADDR_ANY);    <br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">1234</span>);              <span class="hljs-comment">//端口1234</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr)) == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;bind socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//进入监听状态，等待用户发起请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;listen socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//等待接收客户端请求</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_addr;<br>        <span class="hljs-keyword">if</span> ((connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr,       <span class="hljs-built_in">sizeof</span>(client_addr))) == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;accept socket error&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//有客户端建立连接之后</span><br>        <span class="hljs-keyword">if</span> ((childpid = fork()) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//创建子进程，子进程运行区域</span><br>            <span class="hljs-built_in">close</span>(listenfd);  <span class="hljs-comment">// 关闭监听套接字</span><br>            <span class="hljs-built_in">func</span>();    <span class="hljs-comment">// 自行定义处理客户端请求的函数</span><br>            <span class="hljs-built_in">close</span>(connfd);  <span class="hljs-comment">// 子进程执行完，关闭连接套接字</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程运行区域</span><br>            <span class="hljs-built_in">close</span>(connfd); <span class="hljs-comment">//  调用fork()后，父进程关闭连接套接字，等待其他连接的到来</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd); <span class="hljs-comment">//整个关掉</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span></span>&#123; <span class="hljs-comment">//自定义处理请求的函数</span><br>        <span class="hljs-comment">// 函数体</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="客户端代码-client-cpp"><a href="#客户端代码-client-cpp" class="headerlink" title="客户端代码 client.cpp"></a>客户端代码 client.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//创建套接字</span><br>    <span class="hljs-type">int</span> sockfd;<br>    <br>    <span class="hljs-keyword">if</span>((sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;create socket error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//向服务器（特定的IP和端口）发起请求</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-built_in">memset</span>(&amp;serv_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(serv_addr));            <span class="hljs-comment">//每个字节都用0填充</span><br>    serv_addr.sin_family = AF_INET;                      <span class="hljs-comment">//使用IPv4地址</span><br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);  <span class="hljs-comment">//具体的IP地址</span><br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">1234</span>);                    <span class="hljs-comment">//端口1234</span><br>    <span class="hljs-built_in">connect</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(serv_addr));<br>    <br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">connect</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;ser_vaddr, <span class="hljs-built_in">sizeof</span>(ser_vaddr)) == <span class="hljs-number">-1</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;connect error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//连接成功后开始发送数据</span><br>    <span class="hljs-type">char</span> message[<span class="hljs-number">4096</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;  ;i++)&#123;  <span class="hljs-comment">//可以一直发</span><br>        <span class="hljs-built_in">send</span>(sockfd, &amp;message, <span class="hljs-built_in">sizeof</span>(message));<br>    &#125;<br>    <br>    <span class="hljs-comment">//读取服务器传回的数据</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">40</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;  ;i++)&#123;   <span class="hljs-comment">// 一直接收</span><br>        <span class="hljs-built_in">read</span>(sockfd, &amp;buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br>    &#125;<br>   <br>    <span class="hljs-comment">//关闭套接字</span><br>    <span class="hljs-built_in">close</span>(sockfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> socket </category>
          
          <category> socket编程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2022/03/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                             单例模式</p></blockquote><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//实现单例步骤</span><br><span class="hljs-comment">//1.构造函数私有化</span><br><span class="hljs-comment">//2.增加静态私有的当前类的指针变量</span><br><span class="hljs-comment">//3.提供静态对外公共接口，获得单例对象</span><br><br><span class="hljs-comment">//单例 分为懒汉式 饿汉式</span><br><br><span class="hljs-comment">//1.懒汉式(需要的时候才会创建)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Single_lazy</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//静态锁，是由于静态函数只能访问静态成员</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">pthread_mutex_t</span> lock;<br>    <br>    <span class="hljs-comment">//私有化构造函数</span><br><span class="hljs-built_in">Single_lazy</span>() &#123;<br>        <span class="hljs-built_in">pthread_mutex_init</span>(&amp;lock, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//当前类的私有静态指针变量指向唯一实例</span><br><span class="hljs-type">static</span> Single_lazy *p;<br>    <br>    ~<span class="hljs-built_in">Single_lazy</span>()&#123;&#125;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//公有静态方法获取实例</span><br><span class="hljs-function"><span class="hljs-type">static</span> Single_lazy* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-type">pthread_mutex_t</span> single::lock;<br><br><span class="hljs-comment">//类外初始化</span><br>Single_lazy* Single_lazy::p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function">Single_lazy* <span class="hljs-title">Single_lazy::getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;lock);<br>        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;<br>            p = <span class="hljs-keyword">new</span> Single_lazy;<br>        &#125;<br>         <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;lock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//为什么要用双检测，只检测一次不行吗？</span><br><span class="hljs-comment">//如果只检测一次，在每次调用获取实例的方法时，都需要加锁，</span><br><span class="hljs-comment">//这将严重影响程序性能。双层检测可以有效避免这种情况，</span><br><span class="hljs-comment">//仅在第一次创建单例的时候加锁，</span><br><span class="hljs-comment">//其他时候都不再符合NULL==p的情况，</span><br><span class="hljs-comment">//直接返回已创建好的实例。</span><br><br><br><span class="hljs-comment">//局部静态变量之线程安全懒汉模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Single_lazy</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Single_lazy</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">Single_lazy</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Single_lazy* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function">Single_lazy* <span class="hljs-title">Single_lazy::getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> Single_lazy obj;<br>    <span class="hljs-keyword">return</span> &amp;obj;<br>&#125;<br><br><br><span class="hljs-comment">//2.饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Single_hungry</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//当前类的私有静态指针变量指向唯一实例</span><br><span class="hljs-type">static</span> Single_hungry* p;<br>    <br>    <span class="hljs-comment">//私有化构造函数</span><br>    <span class="hljs-built_in">Single_hungry</span>()&#123;&#125;<br>    ~<span class="hljs-built_in">Single_hungry</span>()&#123;&#125;<br>    <br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Single_hungry* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">//类外初始化</span><br>Single_hungry* Single_hungry::p = <span class="hljs-keyword">new</span> Single_hungry;<br><span class="hljs-function">Single_hungry* <span class="hljs-title">Single_hungry::getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//饿汉模式不需要用锁，就可以实现线程安全。</span><br><span class="hljs-comment">//原因在于，在程序运行时就定义了对象，并对其初始化。</span><br><span class="hljs-comment">//之后，不管哪个线程调用成员函数getinstance()，</span><br><span class="hljs-comment">//都只不过是返回一个对象的指针而已。所以是线程安全的，</span><br><span class="hljs-comment">//不需要在获取实例的成员函数中加锁。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>Single_lazy* p1 = Single_lazy::<span class="hljs-built_in">getInstance</span>();<br>Single_lazy* p2 = Single_lazy::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p1 == p2) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;两个指针指向同一块内存空间，是单例！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不是单例模式！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Single_hungry* p3 = Single_hungry::<span class="hljs-built_in">getInstance</span>();<br>Single_hungry* p4 = Single_hungry::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p3 == p4) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;两个指针指向同一块内存空间，是单例！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不是单例模式!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 单例模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对C语言的拓展</title>
      <link href="/2022/03/07/C++%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%A9%E5%B1%95/"/>
      <url>/2022/03/07/C++%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                   C++对C语言的拓展</p></blockquote><span id="more"></span><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h5 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h5><p>变量名实质上是一段连续存储空间的别名，是一个标号(门牌号)；<br>通过变量来申请并命名内存空间；<br>通过变量的名字可以使用存储空间。 </p><h5 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h5><p>变量名，本身是一段内存的引用，即别名(alias)。引用可以看作一个已定义变量的别名。<br>引用的语法：Type&amp; name &#x3D; var; </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>a =<span class="hljs-number">10</span>;    <span class="hljs-comment">//c编译器分配4个字节内存,a内存空间的别名</span><br><span class="hljs-type">int</span>&amp;b = a;<span class="hljs-comment">//b就是a的别名</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>引用没有定义，是一种关系型声明。声明它和原有某一变量(实体)的关系。故而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地址。 </li><li>声明的时候必须初始化，一经声明,不可变更。</li><li>可对引用，再次引用。多次引用的结果，是某一变量具有多个别名。 </li><li>&amp;符号前有数据类型时，是引用。其它皆为取地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>a,b;<br><span class="hljs-type">int</span>&amp;r=a;<br><span class="hljs-type">int</span>&amp;r=b;<span class="hljs-comment">//错误,不可更改原有的引⽤关系</span><br><span class="hljs-type">float</span> &amp;rr =b;<span class="hljs-comment">//错误,引⽤类型不匹配 cout&lt;&lt;&amp;a&lt;&lt;&amp;r&lt;&lt;endl;//变量与引⽤具有相同的地址。</span><br><span class="hljs-type">int</span>&amp;ra= r;<span class="hljs-comment">//可对引⽤更次引⽤,表⽰a变量有两个别名,分别是r和ra</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h5><p>普通引用在声明时必须用其它的变量进行初始化，引用作为函数参数声明时不进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span>age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printfT</span><span class="hljs-params">(Teacher *pT)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt; pT-&gt;age &lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//pT是t1的别名，相当于修改了t1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printfT2</span><span class="hljs-params">(Teacher &amp;pT)</span></span><br><span class="hljs-function"></span>&#123;<br>pT.age = <span class="hljs-number">33</span>;<br>cout&lt;&lt; pT.age &lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//pT和t1的是两个不同的变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printfT3</span><span class="hljs-params">(Teacher pT)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt; pT.age &lt;&lt;endl;<br>pT.age = <span class="hljs-number">45</span>;   <span class="hljs-comment">//只会修改pT变量，不会修改t1变量</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>Teachert1;<br>t1.age = <span class="hljs-number">35</span>;<br><span class="hljs-built_in">printfT</span>(&amp;t1);<br><span class="hljs-built_in">printfT2</span>(t1);                 <span class="hljs-comment">//pT是t1的别名</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t1.age:%d\n&quot;</span>, t1.age); <span class="hljs-comment">//33</span><br><span class="hljs-built_in">printfT3</span>(t1);                    <span class="hljs-comment">//pT是形参，t1 copy⼀份数据给pT</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;t1.age:%d\n&quot;</span>, t1.age); <span class="hljs-comment">//33</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="引用的意义"><a href="#引用的意义" class="headerlink" title="引用的意义"></a>引用的意义</h5><ul><li>引用作为其它变量的别名而存在，因此在一些场合可以代替指针</li><li>引用相对于指针来说具有更好的可读性和实用性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<span class="hljs-comment">//⽆法实现两数据的交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> *q)</span></span>;<span class="hljs-comment">//开辟了两个指针空间实现交换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br> <span class="hljs-type">int</span> tmp;<br> tmp = a;<br>     a = b;<br> b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>C++中引入引用后,可以用引用解决的问题。避免用指针来解决。</p></blockquote><h5 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h5><ul><li><p>引用在C++中的内部实现是一个常指针Type&amp; name &lt;&#x3D;&#x3D;&#x3D;&gt; Type* const name</p></li><li><p>C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。</p></li><li><p>从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>a =<span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-type">const</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>*a = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>x =<span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(x);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">间接赋值的3个必要条件 </span><br><span class="hljs-comment">1 定义两个变量 （一个实参一个形参） </span><br><span class="hljs-comment">2 建立关联 实参取地址传给形参 </span><br><span class="hljs-comment">3 *p形参去间接的修改实参的值 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">引用在实现上，只不过是把间接赋值成立的三个条件的后两步和二为一。</span><br><span class="hljs-comment">当实参传给形参引用的时候，只不过是c++编译器帮我们程序员手工取了一个实参地址，</span><br><span class="hljs-comment">传给了形参引用（常量指针）。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h5><p>1、当函数返回值为引用时，若返回栈变量，不能成为其它引用的初始值（不能作为左值使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">getA1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>a;<br>    a =<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getA2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>a;<br>a =<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>a1 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>a2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//值拷⻉</span><br>a1 = <span class="hljs-built_in">getA1</span>();<br><br>    <span class="hljs-comment">//将⼀个引⽤赋给⼀个变量，会有拷⻉动作</span><br><span class="hljs-comment">//理解：编译器类似做了如下隐藏操作，a2 =*(getA2())</span><br>a2 = <span class="hljs-built_in">getA2</span>();<br><br>    <span class="hljs-comment">//将⼀个引⽤赋给另⼀个引⽤作为初始值，由于是栈的引⽤，内存⾮法</span><br><span class="hljs-type">int</span>&amp;a3= <span class="hljs-built_in">getA2</span>();<br>cout&lt;&lt;<span class="hljs-string">&quot;a1 = &quot;</span>&lt;&lt;a1&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;a2 =&quot;</span>&lt;&lt;a2&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;a3 =&quot;</span>&lt;&lt;a3&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、当函数返回值为引用时，若返回静态变量或全局变量可以成为其他引用的初始值（可作为右值使用，也可作为左值使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">getA1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>a =<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getA2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>a =<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> a1 =<span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> a2 =<span class="hljs-number">0</span>;<br><br>   <span class="hljs-comment">//值拷⻉</span><br>   a1 =<span class="hljs-built_in">getA1</span>();<br><br>   <span class="hljs-comment">//将⼀个引⽤赋给⼀个变量，会有拷⻉动作</span><br>   <span class="hljs-comment">//理解： 编译器类似做了如下隐藏操作，a2 = *(getA2())</span><br>   a2 =<span class="hljs-built_in">getA2</span>();<br>   <br>   <span class="hljs-comment">//将⼀个引⽤赋给另⼀个引⽤作为初始值，由于是静态区域，内存合法</span><br>   <span class="hljs-type">int</span> &amp;a3 = <span class="hljs-built_in">getA2</span>();<br>cout&lt;&lt;<span class="hljs-string">&quot;a1 =&quot;</span>&lt;&lt;a1&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;a2 =&quot;</span>&lt;&lt;a2&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;a3 =&quot;</span>&lt;&lt;a3&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用作为函数返回值，如果返回值为引用可以当左值，如果返回值为普通变量不可以当左值。 </p></blockquote><h5 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span>age;<br>&#125;;<br><span class="hljs-comment">//在被调⽤函数 获取资源</span><br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">getTeacher</span><span class="hljs-params">(Teacher **p)</span></span><br><span class="hljs-function"></span>&#123;<br>Teacher*tmp = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span>(p ==<span class="hljs-literal">NULL</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>tmp= (Teacher *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Teacher));<br><span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">NULL</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br>tmp-&gt;age = <span class="hljs-number">33</span>;<br><span class="hljs-comment">// p是实参的地址 *实参的地址 去间接的修改实参的值</span><br>*p = tmp;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//指针的引⽤ 做函数参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTeacher2</span><span class="hljs-params">(Teacher* &amp;myp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//给myp赋值 相当于给main函数中的pT1赋值</span><br>myp= (Teacher *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Teacher));<br><span class="hljs-keyword">if</span>(myp == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>myp-&gt;age = <span class="hljs-number">36</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FreeTeacher</span><span class="hljs-params">(Teacher *pT1)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(pT1 == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> ;<br>    &#125;<br><span class="hljs-built_in">free</span>(pT1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>Teacher*pT1 = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//1c语⾔中的⼆级指针</span><br><span class="hljs-built_in">getTeacher</span>(&amp;pT1);<br>cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;pT1-&gt;age&lt;&lt;endl;<br><span class="hljs-built_in">FreeTeacher</span>(pT1);<br><span class="hljs-comment">//2c++中的引⽤（指针的引⽤）</span><br><span class="hljs-comment">//引⽤的本质 间接赋值后2个条件 让c++编译器帮我们程序员做了.</span><br><span class="hljs-built_in">getTeacher2</span>(pT1);<br>cout&lt;&lt;<span class="hljs-string">&quot;age:&quot;</span>&lt;&lt;pT1-&gt;age&lt;&lt;endl;<br><span class="hljs-built_in">FreeTeacher</span>(pT1);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h5><p>const 引用有较多使用。它可以防止对象的值被随意修改。因而具有一些特性。<br>1、const 对象的引用必须是 const 的,将普通引用绑定到 const 对象是不合法的。这个原因比较简单。既然对象是 const 的，表示不能被修改，引用当然也不能修改，必须使用 const 引用。实际上,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>; <br><span class="hljs-type">int</span> &amp;b=a;<br></code></pre></td></tr></table></figure><p>这种写法是不合法 的,编译不过。<br>2、const 引用可使用相关类型的对象（常量，非同类型的变量或表达式）初始化。这个是 const 引用与普通引用最大的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a=<span class="hljs-number">2</span>;  <span class="hljs-comment">//是合法的。</span><br><br><span class="hljs-type">double</span> x=<span class="hljs-number">3.14</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b=a;  <span class="hljs-comment">//也是合法的。</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">//普通引⽤</span><br>   <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>   <span class="hljs-type">int</span> &amp;b =a;<br>   cout&lt;&lt;<span class="hljs-string">&quot;b = &quot;</span>&lt;&lt; b &lt;&lt;endl;<br>   <br>   <span class="hljs-comment">//常引⽤</span><br>   <span class="hljs-type">int</span> x =<span class="hljs-number">20</span>;<br>   <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y= x;  <span class="hljs-comment">//常引⽤是限制变量为只读 不能通过y去修改x了</span><br>   <span class="hljs-comment">//y=21;      /error</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="const-引用的原理"><a href="#const-引用的原理" class="headerlink" title="const 引用的原理"></a>const 引用的原理</h5><p> const 引用的目的是，禁止通过修改引用值来改变被引用的对象。const 引用的初始化特性较为微妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> val = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = val;<br><span class="hljs-type">double</span> &amp; ref2 =val;<br>cout&lt;&lt;ref&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ref2&lt;&lt;endl; <span class="hljs-comment">// 3  3.14</span><br>val= <span class="hljs-number">4.14</span>;<br>cout&lt;&lt;ref&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ref2&lt;&lt;endl;  <span class="hljs-comment">// 3  4.14</span><br></code></pre></td></tr></table></figure><p>上述输出结果为 3、3.14 和 3、4.14。因为 ref 是 const 的,在初始化的过程中已经给定值，不允许修改。而被引用的对象是 val，是非 const 的，所以 val 的修改并未影响 ref 的值，而 ref2 的值发生了相应的改变。那么，为什么非 const 的引用不能使用相关类型初始化呢？实际上，const 引用使用相关类型对象初始化时发生了如下过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>temp = val;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = temp;<br></code></pre></td></tr></table></figure><p>如果 ref 不是 const 的，那么改变 ref 值，修改的是 temp，而不是 val。期望对 ref 的赋值会修改 val 的程序员会发现 val 实际并未修改。</p><blockquote><p>结论：<br>1）const int &amp; e 相当于 const int * const e<br>2）普通引用 相当于 int *const e<br>3）当使用常量（字面量）对const引用进行初始化时，C++编译器会为常量值<br>      分配空间，并将引用名作为这段空间的别名<br>4）使用字面量对const引用初始化后，将生成一个只读变量 </p></blockquote><h4 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h4><p>C语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去，避免了函数调用的开销。但是由于宏函数的处理发生在预处理阶段，缺失了语法检测和有可能带来的语意差错。</p><h5 id="内联函数基本概念"><a href="#内联函数基本概念" class="headerlink" title="内联函数基本概念"></a>内联函数基本概念</h5><p>C++提供了 inline 关键字，实现了真正的内嵌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>     a = <span class="hljs-number">20</span>;<br>     cout &lt;&lt; a &lt;&lt;endl; .<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>      <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">         //编译器将内联函数的函数体直接展开</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">           a = 20;</span><br><span class="hljs-comment">           cout  &lt;&lt;  a  &lt;&lt;endl ;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">       */</span><br>    <br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>特点：</p><p>1、内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。</p><p>2、C++编译器直接将函数体插入在函数调用的地方 。</p><p>3、内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。</p><p>4、内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）。</p><p>5、内联函数由编译器处理，直接将编译后的函数体插入调用的地方，宏代码片段由预处理器处理，进行简单的文      本替换，没有任何编译过程。</p><p>6、C++中内联编译的限制： </p><ul><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句 </li><li>函数体不能过于庞大 </li><li>不能对函数进行取址操作 </li><li>函数内联声明必须在调用语句之前</li></ul><p>7、编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。</p><h5 id="内联函数-vs-宏函数"><a href="#内联函数-vs-宏函数" class="headerlink" title="内联函数 vs 宏函数"></a>内联函数 vs 宏函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>优点:   内嵌代码，辟免压栈与出栈的开销<br>缺点:   代码替换，易使生成代码体积变大，易产生逻辑错误。<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQR(x) ((x)*(x))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>优点:   高度抽象,避免重复开发<br>缺点:   压栈与出栈,带来开销<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x*x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">5</span>)<br>     &#123;<br>         <span class="hljs-comment">//printf(&quot;%d\n&quot; , SQR(i++));</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span> ,<span class="hljs-built_in">sqr</span>(i++));<br>     &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="内联函数总结"><a href="#内联函数总结" class="headerlink" title="内联函数总结"></a>内联函数总结</h5><ul><li>优点: 避免调用时的额外开销(入栈与出栈操作) </li><li>代价: 由于内联函数的函数体在代码段中会出现多个“副本”，因此会增加代码段的空间。 </li><li>本质: 以牺牲代码段空间为代价，提高程序的运行时间的效率。 </li><li>适用场景: 函数体很“小”，且被“频繁</li></ul><h4 id="默认参数和占位参数"><a href="#默认参数和占位参数" class="headerlink" title="默认参数和占位参数"></a>默认参数和占位参数</h4><p>通常情况下，函数在调用时，形参从实参那里取得值。对于多次调用同一函数同一实参时，C++给出了更简单的处理办法。给形参以默认值，这样就不用从实参那里取值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单个默认参数  若你填写参数，使⽤你填写的，不填写使用默认</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> x = <span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;x：&quot;</span>&lt;&lt; x &lt;&lt;endl;<br>&#125;<br><br><span class="hljs-comment">//多个默认参数  在默认参数规则，如果默认参数出现，那么右边的都必须有默认参数</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">volume</span><span class="hljs-params">(<span class="hljs-type">float</span> length, <span class="hljs-type">float</span> weight= <span class="hljs-number">4</span>, <span class="hljs-type">float</span> high= <span class="hljs-number">5</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> length*weight*high;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">float</span> v= <span class="hljs-built_in">volume</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">float</span> v1 = <span class="hljs-built_in">volume</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br><span class="hljs-type">float</span> v2 = <span class="hljs-built_in">volume</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>);<br>cout&lt;&lt;v&lt;&lt;endl;<br>cout&lt;&lt;v1&lt;&lt;endl;<br>cout&lt;&lt;v2&lt;&lt;endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="默认参数规则"><a href="#默认参数规则" class="headerlink" title="默认参数规则"></a>默认参数规则</h5><p>只有参数列表后面部分的参数才可以提供默认，参数值一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值。</p><h5 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   函数占位参数</span><br><span class="hljs-comment">   占位参数只有参数类型声明，⽽没有参数名声明</span><br><span class="hljs-comment">   ⼀般情况下，在函数体内部⽆法使⽤占位参数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>b, <span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//error，必须把最后⼀个占位参数补上。</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;func(1, 2, 3)=%d\n&quot;</span>, <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载(Function Overload)：用同一个函数名定义不同的函数，当函数名和不同的参数搭配时函数的含义不同。</p><h5 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h5><p>1、函数名相同。<br>2、参数个数不同，参数的类型不同，参数顺序不同，均可构成重载。<br>3、返回值类型不同则不可以构成重载。 </p><h5 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h5><p>1、严格匹配,找到则调用。<br>2、通过隐式转换寻求一个匹配、找到则调用。</p><p>编译器调用重载函数的准则:<br>1.将所有同名函数作为候选者<br>2.尝试寻找可行的候选函数<br>3.精确匹配实参<br>4.通过默认参数能够匹配实参<br>5.通过默认类型转换匹配实参<br>6.匹配失败<br>7.最终寻找到的可行候选函数不唯一，则出现二义性，编译失败。<br>8.无法匹配所有候选者，函数未定义，编译失败。 </p><h5 id="重载底层实现"><a href="#重载底层实现" class="headerlink" title="重载底层实现"></a>重载底层实现</h5><p>C++利用 name mangling(倾轧)技术，来改名函数名，区分参数不同的同名函数。<br>实现原理：用 v c i f l d 表示 void char int float long double 及其引用。</p><h5 id="函数重载总结"><a href="#函数重载总结" class="headerlink" title="函数重载总结"></a>函数重载总结</h5><ul><li>重载函数在本质上是相互独立的不同函数 </li><li>函数的函数类型是不同的</li><li>函数返回值不能作为函数重载的依据</li><li>函数重载是由函数名和参数列表决定的</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找应用</title>
      <link href="/2022/03/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"/>
      <url>/2022/03/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二分查找应用：珂珂吃香蕉、在D天内送达包裹的能力、分割数组的最大值、每个小孩最多能分到多少糖果、寻找旋转排序数组中的最小值、搜索旋转排序数组</p></blockquote><span id="more"></span><h4 id="875-珂珂吃香蕉"><a href="#875-珂珂吃香蕉" class="headerlink" title="875.珂珂吃香蕉"></a>875.珂珂吃香蕉</h4><blockquote><p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxVal=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找到piles中的最大值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(piles[i]&gt;maxVal)&#123;<br>                maxVal=piles[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=maxVal;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fun</span>(piles, mid)&gt;h)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fun</span>(piles, mid)&lt;h)&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//收缩右边界</span><br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-comment">//以 x/h 的速度吃香蕉，返回吃完这堆香蕉需要的时间</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n=piles.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            sum+=piles[i]/x;<br>            <span class="hljs-keyword">if</span>(piles[i]%x&gt;<span class="hljs-number">0</span>)&#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1011-在D天内送达包裹的能力"><a href="#1011-在D天内送达包裹的能力" class="headerlink" title="1011.在D天内送达包裹的能力"></a>1011.在D天内送达包裹的能力</h4><blockquote><p>传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。</p><p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</p><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：weights = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>], days = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> days)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=weights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxVal=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(weights[i]&gt;maxVal)&#123;<br>                maxVal=weights[i];<br>            &#125;<br>            sum+=weights[i];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> left=maxVal;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fun</span>(weights, mid)&gt;days)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-type">int</span> days=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;weights.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum += weights[i];<br>            <span class="hljs-keyword">if</span>(sum&gt;x)&#123;<br>                days++;<br>                sum=weights[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410.分割数组的最大值"></a>410.分割数组的最大值</h4><blockquote><p>给定一个非负整数数组 <code>nums</code> 和一个整数 <code>m</code> ，你需要将这个数组分成 <code>m</code> 个非空的连续子数组。</p><p>设计一个算法使得这 <code>m</code> 个子数组各自和的最大值最小。</p></blockquote><blockquote><p>思路：这道题和前一道1011的运输问题是一模一样的。改写一下题目：你只有一艘货船，现在有若干货物，每个货物的重量是<code>nums[i]</code>，现在你需要在<code>m</code>天内将这些货物运走，请问你的货船的最小载重是多少？</p><p>货船每天运走的货物就是<code>nums</code>的一个子数组，在<code>m</code>天内运完就是将<code>nums</code>划分成<code>m</code>个子数组，让货船的载重尽可能小，就是让所有子数组中最大的那个子数组元素之和尽可能小。</p><p>代码跟上面那个题一模一样的</p><p>二分搜索，最小值为<code>nums</code>中的最大值，最大值为<code>nums</code>中所有值的和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxVal=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;maxVal)&#123;<br>                maxVal=nums[i];<br>            &#125;<br>            sum +=nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> left=maxVal;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fun</span>(nums, mid)&gt;m)&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-type">int</span> m=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span>(sum&gt;x)&#123;<br>                m++;<br>                sum=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2226-每个小孩最多能分到多少糖果"><a href="#2226-每个小孩最多能分到多少糖果" class="headerlink" title="2226.每个小孩最多能分到多少糖果"></a>2226.每个小孩最多能分到多少糖果</h4><blockquote><p>给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。</p><p>另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。</p><p>返回每个小孩可以拿走的 最大糖果数目 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例<span class="hljs-number">1</span>：<br>输入：candies = [<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumCandies</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candies, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=candies.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxVal=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(candies[i]&gt;maxVal)&#123;<br>                maxVal=candies[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=maxVal;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fun</span>(candies, k, mid))&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125; <br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fun</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candies, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k, <span class="hljs-type">int</span> x)</span></span>&#123;<br>        <span class="hljs-type">int</span> n=candies.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            res += candies[i]/x; <span class="hljs-comment">//注意x不能等于0；</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res&gt;=k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153.寻找旋转排序数组中的最小值</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">//数组中最后一个元素，最小值右边的一定比它小，最小值左边的一定比它大</span><br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])&#123;<br>                right=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33.搜索旋转排序数组</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k&lt;n &amp;&amp; nums[k] &gt;= nums[k<span class="hljs-number">-1</span>]) k++;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-type">int</span> left_val = <span class="hljs-built_in">BinarySearch</span>(nums, target, <span class="hljs-number">0</span>, k<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> right_val = <span class="hljs-built_in">BinarySearch</span>(nums, target, k, n<span class="hljs-number">-1</span>);<br><br>        <span class="hljs-keyword">if</span>(left_val!=<span class="hljs-number">-1</span>) res=left_val;<br>        <span class="hljs-keyword">if</span>(right_val!=<span class="hljs-number">-1</span>) res=right_val;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">//二分查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br><br>        <span class="hljs-type">int</span> left=low;<br>        <span class="hljs-type">int</span> right=high;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> mid = left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target) right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="852-山脉数组的顶峰索引"><a href="#852-山脉数组的顶峰索引" class="headerlink" title="852.山脉数组的顶峰索引"></a><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/">852.山脉数组的顶峰索引</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid]&lt;arr[mid+<span class="hljs-number">1</span>])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162.寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">162.寻找峰值</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[mid+<span class="hljs-number">1</span>])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287.寻找重复数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>(); <br><br>        <span class="hljs-comment">//在[1...n]查找nums中重复的元素</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">//统计nums中小于等于 mid 的元素个数</span><br>            <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;<br>                <span class="hljs-keyword">if</span>(num&lt;=mid)&#123;<br>                    count++;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(count&gt;mid)&#123;<br>                <span class="hljs-comment">//下一轮搜索的区间[left...mid]</span><br>                right=mid;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//下一轮搜索的区间[mid+1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11.盛水最多的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11.盛水最多的容器</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <br>        <span class="hljs-type">int</span> n=height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[left],height[right])*(right-left));<br>            <span class="hljs-keyword">if</span>(height[left]&lt;height[right]) left++;<br>            <span class="hljs-keyword">else</span> right--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分查找 </category>
          
          <category> 二分查应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找基础</title>
      <link href="/2022/03/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                 本⽂探究了⼏个最常⽤的⼆分查找场景：寻找⼀个数、寻找左侧边界、寻找右侧边界。</p></blockquote><span id="more"></span><h5 id="寻找⼀个数"><a href="#寻找⼀个数" class="headerlink" title="寻找⼀个数"></a>寻找⼀个数</h5><blockquote><p>这个场景是最简单的，可能也是最熟悉的，即搜索⼀个数，如果存在，返回其索引，否则返回 -1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-comment">// left + (right-left)/2 为防⽌溢出</span><br>        <span class="hljs-type">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="寻找左侧边界"><a href="#寻找左侧边界" class="headerlink" title="寻找左侧边界"></a>寻找左侧边界</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>; <br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右边界，锁定左边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">// 最后要检查 left 越界的情况</span><br>    <span class="hljs-keyword">if</span>(left&gt;=nums.<span class="hljs-built_in">size</span>() || nums[left]!=target)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right-left)/<span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>；<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩左边界，锁定右边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 right 越界的情况</span><br>    <span class="hljs-keyword">if</span>(right&lt;<span class="hljs-number">0</span> || nums[right]!=target)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分查找 </category>
          
          <category> 二分查找基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法</title>
      <link href="/2022/03/06/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/06/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​              本文对比较常用且比较高效的排序算法进行了总结和解析，并贴出了比较精简的实现代码。</p></blockquote><span id="more"></span><h4 id="常见排序算法比较"><a href="#常见排序算法比较" class="headerlink" title="常见排序算法比较"></a>常见排序算法比较</h4><p><img src="/images/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png" alt="常见排序算法比较"></p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>稳定: 如果a原本在b前面，而a&#x3D;b,排序之后a仍然在b的前面。</li><li>不稳定: 如果a原本在b的前面，而a&#x3D;b, 排之后a可能会出现在b的后面。</li><li>时间复杂度: 对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度: 是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li></ul><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote><p><strong>基本思想</strong>：从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 冒泡排序 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n-i<span class="hljs-number">-1</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">swap</span>(a[j], a[j+<span class="hljs-number">1</span>]);   <span class="hljs-comment">//交换数据</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote><p><strong>基本思想</strong>：基于分治法。在待排序表L[1…n]中任取一个元素pivot作为基准，通过一趟排序算法将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一趟快速排序。而后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//快排母函数</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>     <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Paritition</span>(a, low, high);<br>     <span class="hljs-built_in">QuickSort</span>(a, low, pivot - <span class="hljs-number">1</span>);<br>     <span class="hljs-built_in">QuickSort</span>(a, pivot + <span class="hljs-number">1</span>, high);<br>   &#125;<br> &#125;<br><br><span class="hljs-comment">//严蔚敏《数据结构》标准分割函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Paritition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = a[low];   <span class="hljs-comment">// 第一个元素设为枢轴，对表进行划分</span><br>    <span class="hljs-keyword">while</span>(low &lt; high) &#123;<br>         <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=pivot) --high;<br>         a[low] = a[high];  <span class="hljs-comment">// 将比枢轴小的元素移动到左端</span><br>         <span class="hljs-keyword">while</span> (low&lt;high &amp;&amp; a[low]&lt;=pivot) ++low;<br>         a[high] = a[low];  <span class="hljs-comment">// 将比枢轴大的元素移动到右端</span><br>    &#125;<br>    a[low] = pivot;     <span class="hljs-comment">// 枢轴元素存放到最终位置</span><br>    <span class="hljs-keyword">return</span> low;        <span class="hljs-comment">// 返回最终位置</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快排优化思想：主要是关于基准pivot的选择</span><br><span class="hljs-comment">//三种选法：固定选取，随机选取，三数取中法</span><br><br><span class="hljs-comment">//随机选取</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort_Random</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//快排母函数</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>     <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Parition_Random</span>(a, low, high);<br>     <span class="hljs-built_in">QuickSort_Random</span>(a, low, pivot - <span class="hljs-number">1</span>);<br>     <span class="hljs-built_in">QuickSort_Random</span>(a, pivot + <span class="hljs-number">1</span>, high);<br>   &#125;<br> &#125;<br><br><span class="hljs-comment">//随机选取，随机划分操作，随机选pivot</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Parition_Random</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">rand</span>()%(high-low)+low;<br>    <span class="hljs-built_in">swap</span>(a[low], a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Parition</span>(a, low, high);<br>&#125;<br><br><span class="hljs-comment">//严蔚敏《数据结构》标准分割函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Parition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = a[low];   <span class="hljs-comment">// 第一个元素设为枢轴，对表进行划分</span><br>    <span class="hljs-keyword">while</span>(low &lt; high) &#123;<br>         <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; a[high]&gt;=pivot) --high;<br>         a[low] = a[high];  <span class="hljs-comment">// 将比枢轴小的元素移动到左端</span><br>         <span class="hljs-keyword">while</span> (low&lt;high &amp;&amp; a[low]&lt;=pivot) ++low;<br>         a[high] = a[low];  <span class="hljs-comment">// 将比枢轴大的元素移动到右端</span><br>    &#125;<br>    a[low] = pivot;     <span class="hljs-comment">// 枢轴元素存放到最终位置</span><br>    <span class="hljs-keyword">return</span> low;        <span class="hljs-comment">// 返回最终位置</span><br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//三数取中的思想：选取数组开头，中间和结尾的元素，通过比较选中间的值作为快排的划分点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">selectMedianofThree</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123; <span class="hljs-comment">//三数取中</span><br>    <span class="hljs-keyword">if</span>((a-b)*(a-c)&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">if</span>((b-a)*(b-c)&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">if</span>((c-a)*(c-b)&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Parition</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> pivot=<span class="hljs-built_in">selectMedianofThree</span>(a[low], a[(low+high)/<span class="hljs-number">2</span>], a[high]);<br>    <span class="hljs-keyword">while</span>(low&lt;high)&#123;<br>        <span class="hljs-comment">//然后和第一种一样</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><blockquote><p><strong>基本思想</strong>： 将数组中的所有元素依次和前面的已经排好序的元素相比较（依次），如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//外层循环标识并决定待比较的数值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt; n; i++) &#123;           <span class="hljs-comment">//循环从第2个元素开始</span><br>        <span class="hljs-keyword">if</span>(a[i] &lt; a[i<span class="hljs-number">-1</span>]) &#123;<br>            <span class="hljs-type">int</span> temp = a[i];<br>            <span class="hljs-comment">//待比较数值确定其最终位置</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j] &gt; temp; j--) &#123;<br>                a[j+<span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">//移动</span><br>            &#125;<br>            a[j+<span class="hljs-number">1</span>] = temp;           <span class="hljs-comment">//此处就是a[j+1]=temp;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote><p><strong>基本思想</strong>：希尔排序也称缩小增量排序；希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时（用gap &#x3D; gap&#x2F;3+1 控制），保证了最后一次进行直接插入排序，算法终止。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> gap;<br><span class="hljs-keyword">while</span> (gap &lt; n / <span class="hljs-number">3</span>)<br>gap = gap * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>; <br><span class="hljs-keyword">for</span> (; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br><span class="hljs-type">int</span> temp = a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j] &gt; temp; j -= gap)<br>a[j + gap] = a[j];  <span class="hljs-comment">//移动</span><br>a[j + gap] = temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><blockquote><p><strong>基本思想</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; ++j)<br>            <span class="hljs-keyword">if</span>(a[j] &lt; a[i])<br>                <span class="hljs-built_in">swap</span>(a[i], a[j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><img src="/images/%E5%A0%86.png" alt="堆"></p><blockquote><p><strong>基本思想</strong>：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><ol><li>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</li><li>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 为 倒数第二层左右边的节点），从左至右，从下至上进行调整。</li><li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后将剩余的n-1个元素继续调整堆(只需调整堆顶元素)，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 堆排序的核心是建堆，传入参数为数组，数组长度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len)</span></span>&#123; <span class="hljs-comment">// 建立大根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;   <span class="hljs-comment">// 从最后一个非叶子节点的父结点开始建堆</span><br>        <span class="hljs-built_in">AdjustDown</span>(a, i, len);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 堆向下调整算法，传入参数为数组，根节点位置，数组长度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AdjustDown</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    a[<span class="hljs-number">0</span>] = a[k];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>*k; i &lt;= len; i *= <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 沿k较大的子节点向下筛选</span><br>        <span class="hljs-keyword">if</span>(i&lt;len &amp;&amp; a[i]&lt;a[i+<span class="hljs-number">1</span>])<br>            i++;                          <span class="hljs-comment">// 取k较大的子节点的下标</span><br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]&gt;=a[i]) <span class="hljs-keyword">break</span>;       <span class="hljs-comment">// 筛选结束</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            a[k] = a[i];            <span class="hljs-comment">// 将nums[i]调整到双亲节点上</span><br>            k = i;                        <span class="hljs-comment">// 修改k值，以便继续向下筛选</span><br>        &#125;<br>    &#125;<br>    a[k] = a[<span class="hljs-number">0</span>]                     <span class="hljs-comment">// 被筛选节点的值放入最终位置</span><br>&#125;<br><span class="hljs-comment">// 堆排序算法</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">Heap_sort</span>(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len) &#123;<br>    <span class="hljs-built_in">BuildMaxHeap</span>(a, len);              <span class="hljs-comment">// 初始建堆</span><br>    <span class="hljs-keyword">for</span>(i=len; i &gt; <span class="hljs-number">1</span>; i--) &#123;            <br>        <span class="hljs-built_in">swap</span>(a[i], a[<span class="hljs-number">1</span>]);           <span class="hljs-comment">// 输出堆顶元素（和堆底元素交换）</span><br>        <span class="hljs-built_in">AdjustDown</span>(a, <span class="hljs-number">1</span>, i<span class="hljs-number">-1</span>);         <span class="hljs-comment">// 调整，把剩下的i-1个元素调整成堆</span><br>    &#125; <br>&#125;<br><span class="hljs-comment">// 堆向上调整算法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AdjustUp</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-comment">// 参数k为向上调整的节点，也为堆的元素个数</span><br>    nums[<span class="hljs-number">0</span>] = nums[k];<br>    <span class="hljs-type">int</span> i = k/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]&lt;nums[<span class="hljs-number">0</span>]) &#123;<br>        nums[k] = nums[i];<br>        k = i;<br>        i = i/<span class="hljs-number">2</span>;<br>    &#125;<br>    nums[k] = nums[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote><p><strong>基本思想</strong>：归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法(Divide and Conquer)的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列; 即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p></blockquote><blockquote><p><strong>2-路归并</strong>：</p><ul><li>分解：将含有n个元素的待排序表分成含n&#x2F;2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。</li><li>合并：合并两个已经排序的子表得到排序结果。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(low&gt;=high)&#123;  <span class="hljs-comment">//终止递归的条件，子序列长度为1</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=low+(high-low)/<span class="hljs-number">2</span>;     <span class="hljs-comment">//取得序列中间的元素</span><br>    <span class="hljs-built_in">MergeSort</span>(nums, low, mid);    <span class="hljs-comment">//对左半边递归</span><br>    <span class="hljs-built_in">MergeSort</span>(nums, mid+<span class="hljs-number">1</span>, high); <span class="hljs-comment">//对右半边递归</span><br>    <span class="hljs-built_in">Merge</span>(nums, low, mid, high);  <span class="hljs-comment">//合并</span><br>&#125;<br><span class="hljs-comment">//合并两个已排序的子表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size())</span></span>;  <span class="hljs-comment">//辅助数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=low;i&lt;=high;i++)&#123;     <span class="hljs-comment">//将nums复制到辅助数组</span><br>        temp[i]=nums[i];            <span class="hljs-comment">//以便合并后的结果能够直接存入到nums中</span><br>    &#125;<br>    <span class="hljs-comment">//数组双指针技巧，合并两个有序数组</span><br>    <span class="hljs-comment">//low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素</span><br>    <span class="hljs-type">int</span> i=low, j=mid+<span class="hljs-number">1</span>;  <span class="hljs-comment">// mid+1为第2有序区第1个元素，j指向第1个元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<br>        <span class="hljs-keyword">if</span>(i==mid+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//左半边数组已全部被合并</span><br>            nums[k] = temp[j++];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==high+<span class="hljs-number">1</span>)&#123;<br>             <span class="hljs-comment">//右半边数组已全部被合并</span><br>            nums[k] = temp[i++];<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i]&gt;temp[j])&#123;<br>            nums[k] = temp[j++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            nums[k] = temp[i++];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对C语言的加强</title>
      <link href="/2022/03/05/C++%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A0%E5%BC%BA/"/>
      <url>/2022/03/05/C++%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A0%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​                                                                               C++对C语言的加强</p></blockquote><span id="more"></span><h5 id="namespace-命名空间"><a href="#namespace-命名空间" class="headerlink" title="namespace 命名空间"></a>namespace 命名空间</h5><ul><li>当使用的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。若不引入using namespace std ,需要这样做。std::cout。 </li><li>C++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 </li><li>C++命名空间的定义： namespace name { … } </li><li>using namespace NameSpaceA; </li><li>namespce定义可嵌套。</li></ul><h5 id="“实用性“增强"><a href="#“实用性“增强" class="headerlink" title="“实用性“增强"></a>“实用性“增强</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C语⾔中的变量都必须在作⽤域开始的位置定义！！</span><br><span class="hljs-comment">// C++中更强调语⾔的“实⽤性”，所有的变量都可以在需要使⽤时再定义。</span><br></code></pre></td></tr></table></figure><h5 id="变量检测增强"><a href="#变量检测增强" class="headerlink" title="变量检测增强"></a>变量检测增强</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">在C语⾔中，重复定义多个同名的全局变量是合法的</span><br><span class="hljs-comment">在C++中，不允许定义多个同名的全局变量</span><br><span class="hljs-comment">C语⾔中多个同名的全局变量最终会被链接到全局数据区的同⼀个地址空间上</span><br><span class="hljs-comment">intg_var;</span><br><span class="hljs-comment">intg_var =1;</span><br><span class="hljs-comment">C++直接拒绝这种⼆义性的做法。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-type">int</span>g_var;<br><span class="hljs-type">int</span>g_var =<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>*argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;g_var =%d\n&quot;</span>, g_var);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="struct-类型增强"><a href="#struct-类型增强" class="headerlink" title="struct 类型增强"></a>struct 类型增强</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">C语⾔的struct定义了⼀组变量的集合，C编译器并不认为这是⼀种新的类型</span><br><span class="hljs-comment">C++中的struct是⼀个新类型的定义声明</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="C-中所有变量和函数都必须有类型"><a href="#C-中所有变量和函数都必须有类型" class="headerlink" title="C++ 中所有变量和函数都必须有类型"></a>C++ 中所有变量和函数都必须有类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">C++中所有的变量和函数都必须有类型</span><br><span class="hljs-comment">C语⾔中的默认类型在C++中是不合法的</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在C语言中 </span><br><span class="hljs-comment">    int f( )；表示返回值为int，接受任意参数的函数 </span><br><span class="hljs-comment">    int f(void)；表示返回值为int的无参函数 </span><br><span class="hljs-comment">在C++中 </span><br><span class="hljs-comment">    int f( );和int f(void)具有相同的意义，都表示返回值为int的无参函数</span><br><span class="hljs-comment">C++更加强调类型，任意的程序元素都必须显示指明类型</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="新增bool-类型关键字"><a href="#新增bool-类型关键字" class="headerlink" title="新增bool 类型关键字"></a>新增bool 类型关键字</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">C++中的布尔类型</span><br><span class="hljs-comment">C++在C语⾔的基本类型系统之上增加了bool</span><br><span class="hljs-comment">C++中的bool可取的值只有true和false</span><br><span class="hljs-comment">理论上bool只占⽤⼀个字节，</span><br><span class="hljs-comment">如果多个bool变量定义在⼀起，可能会各占⼀个bit，这取决于编译器的实现</span><br><span class="hljs-comment">true代表真值，编译器内部⽤1来表⽰</span><br><span class="hljs-comment">false代表⾮真值，编译器内部⽤0来表⽰</span><br><span class="hljs-comment">bool类型只有true（⾮0）和false（0）两个值</span><br><span class="hljs-comment">C++编译器会在赋值时将⾮0值转换为true，0值转换为false</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="三目运算符功能增强"><a href="#三目运算符功能增强" class="headerlink" title="三目运算符功能增强"></a>三目运算符功能增强</h5><ul><li><p>C语言返回变量的值 C++语言是返回变量本身 </p><blockquote><p>C语言中的三目运算符返回的是变量值，不能作为左值使用<br>C++中的三目运算符可直接返回变量本身，因此可以出现在程序的任何地方 </p></blockquote></li><li><p>注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用 </p><blockquote><p>(a &lt; b ? 1 : b )&#x3D; 30; </p></blockquote></li><li><p>C语言如何支持类似C++的特性呢？ </p><blockquote><p>当左值的条件：要有内存空间；C++编译器帮助程序员取了一个地址</p></blockquote></li></ul><h5 id="const-增强"><a href="#const-增强" class="headerlink" title="const 增强"></a>const 增强</h5><h6 id="const-基础知识"><a href="#const-基础知识" class="headerlink" title="const 基础知识"></a>const 基础知识</h6><p>const修饰指针有三种情况</p><ol><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p1 = &amp;a;<br>    p1 = &amp;b; <span class="hljs-comment">//正确</span><br>    <span class="hljs-comment">//*p1 = 100; 报错</span><br>   <br>    <span class="hljs-comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span><br>    <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p2 = &amp;a;<br>    <span class="hljs-comment">//p2 = &amp;b; //错误</span><br>    *p2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//正确</span><br>    <br>    <span class="hljs-comment">//const既修饰指针又修饰常量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> p3 = &amp;a;<br>    <span class="hljs-comment">//p3 = &amp;b; //错误</span><br>    <span class="hljs-comment">//*p3 = 100; //错误</span><br>   <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p></blockquote><p>合理的利用const的好处，</p><ol><li>指针做函数参数，可以有效的提高代码可读性，减少bug；</li><li>清楚的分清参数的输入和输出特性</li></ol><h6 id="const-和-define"><a href="#const-和-define" class="headerlink" title="const 和 #define"></a>const 和 #define</h6><p>C++中的const修饰的，是一个真正的常量，而不是C中变量（只读）。在const修饰的常量编译期间，就已经确定下来了</p><p>C++中的const常量类似于宏定义</p><blockquote><p>const int c &#x3D; 5;   ≈   #define c 5</p></blockquote><p>C++中的const常量与宏定义不同</p><ul><li>const常量是由编译器处理的，提供类型检查和作用域检查</li><li>宏定义由预处理器处理，单纯的文本替换</li></ul><blockquote><ul><li><p>C语言中的const变量 </p><blockquote><p>C语言中const变量是只读变量，有自己的存储空间</p></blockquote></li><li><p>C++中的const常量可能分配存储空间,也可能不分配存储空间 </p><blockquote><p>当const常量为全局，并且需要在其它文件中使用，会分配存储空间<br>当使用&amp;操作符，取const常量的地址时，会分配存储空间<br>当const int &amp;a &#x3D; 10; const修饰引用时，也会分配存储空间</p></blockquote></li></ul></blockquote><h5 id="真正的枚举"><a href="#真正的枚举" class="headerlink" title="真正的枚举"></a>真正的枚举</h5><p>c 语言中枚举本质就是整型,枚举变量可以用任意整型赋值。而 c++中枚举变量, 只能用被枚举出来的元素初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>std;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">season</span>&#123;SPR,SUM,AUT,WIN&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">season</span>s =SPR;<br><span class="hljs-comment">//s= 0;    //error,但是C语⾔可以通过</span><br>s =SUM;<br>    cout&lt;&lt; <span class="hljs-string">&quot;s =&quot;</span> &lt;&lt; s &lt;&lt;endl;<span class="hljs-comment">//1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/04/hello-world/"/>
      <url>/2022/03/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
